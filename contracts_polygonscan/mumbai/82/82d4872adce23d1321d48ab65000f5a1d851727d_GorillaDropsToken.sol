/**
 *Submitted for verification at polygonscan.com on 2022-01-10
*/

/*
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNXKKKXNNNNNNNNNNNNNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNXOc,...';oOXNNNNNNNNNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNXo.        .cOXNNNNNNNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNXO:.           .;oOXNNNNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNXOc.                .lKNNNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNXOc.                   .:ONNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNKxc.                       cXNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNKkc'                         .dNNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNKOxo:'                             'xXNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN0o;..                                  .xNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN0l.                                      .kNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNXx'                                        lXNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN0kc.                                      .,l0NNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNXx'                                        c0XNNNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNKk;.                                        .kNNNNNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNKkl'.                                          .kNNNNNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNXKOxollc:;:llll:,.                                              'ONNNNNNNNN
NNNNNNNNNNNNNNNNNNNNNN0dc,.                                                              lXNNNNNNNNN
NNNNNNNNNNNNNNNNNNNXk:.                                                                 ;0NNNNNNNNNN
NNNNNNNNNNNNNNNNNXk;.                                                                  ,ONNNNNNNNNNN
NNNNNNNNNNNNNNNNKl.                                                                    .xXNNNNNNNNNN
NNNNNNNNNNNNNNN0;                                                                       'ONNNNNNNNNN
NNNNNNNNNNNNNN0;                                                                        'ONNNNNNNNNN
NNNNNNNNNNNNNXl                                                                         'ONNNNNNNNNN
NNNNNNNNNNNNNk.                                                                         'ONNNNNNNNNN
NNNNNNNNNNNNXc                                                                          'ONNNNNNNNNN
NNNNNNNNNNNNx.                                                                          :KNNNNNNNNNN
NNNNNNNNNNXd.                                                      :x;                  lNNNNNNNNNNN
NNNNNNNNN0c.                  .;lxc.                               'kk;                 oNNNNNNNNNNN
NNNNNNNXx'                  .:kKXKkolc:;;,...                     .;xX0l.              .kNNNNNNNNNNN
NNNNNNNk'                  ,xx:,',:kXNNNNXK0Oxoc:,,,'.....',,;cldkKOo;:xx;             ,0NNNNNNNNNNN
NNNNNN0;                 .lkl.    ,ONNNNNNNNNNNNNNNNXK000KXXNNNNNNNo.  .cOl.           lXNNNNNNNNNNN
NNNNNKc              ..,lkx,     .oNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNKk,    .x0,          .xNNNNNNNNNNNN
NNNNXd.            ,oOKOl,.       ,kNNNNNNNNNNNNNNNNNNNNNNNNNNNOc..   .:x0O,          ;KNNNNNNNNNNNN
NNNNO'           .oKNNNd.          .lOKNNNNNNNNNNNNNNNNNNNNNNNNo.    .o0o,.          .dNNNNNNNNNNNNN
NNNNd.           .dKNNNd.            .':xXNNNNNNNNNNNNNNNNNNNNNo     :0d.            ;0NNNNNNNNNNNNN
NNNNd.             .;lO0:               .xNNNNNNNNNNNNNNNNNNNNNx.   .xO,            .xNNNNNNNNNNNNNN
NNNNO'                ;00l'.............;kNNNNNNNNNNNNNNNNNNNNNXklc:dKO'           .oXNNNNNNNNNNNNNN
NNNNNk,               'kNNK000OOOOOOOOO0XNNNNNNNNNNNNNNNNNNNNNNNNNNNNNKl.         .lKNNNNNNNNNNNNNNN
NNNNNNKxooooooooooooooOXNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNX0kkkkkkkkk0XNNNNNNNNNNNNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN




  ______  _____   ______ _____               _______
 |  ____ |     | |_____/   |   |      |      |_____|
 |_____| |_____| |    \_ __|__ |_____ |_____ |     |
                                                    
 ______   ______  _____   _____  _______    _____   ______  ______
 |     \ |_____/ |     | |_____] |______   |     | |_____/ |  ____
 |_____/ |    \_ |_____| |       ______| . |_____| |    \_ |_____|
                                                                  



*/















pragma solidity ^0.4.26;

 interface IERC20 {
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender) external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        } else {
            uint256 c = a * b;
            assert(c / a == b);
            return c;
        }
    }


    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }


    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}



contract ErroneousToken {
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
}

contract ERC20Basic {
    uint256 public totalSupply;
    function balanceOf(address who) public constant returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract GorillaDropsToken is ERC20 {
    
    using SafeMath for uint256;
    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    mapping (address => bool) public Claimed; 


    string public symbol;
    string public  name;
    address public admin;
    uint8 public decimals;
    uint256 public totalSupply;
    uint256 public totalDistributed;
    uint256 public requestMinimum;
    uint256 public tokensPerEth;
    uint256 public nonPresaleBal; // 6m owner wallet
    uint256 public presaleBal; // 4m owner wallet



    // ============================================================================
    // Constructor
    // ============================================================================
    constructor() public {
        symbol = "GDrops";
        name = "GorillaDrops.org";
        decimals = 18;
        totalSupply = 10000000000000000000000000;
        requestMinimum = 20000000000000000;
        admin = 0x5A2d843Db97F7E2914b34306b316F7807399Ad83;
        tokensPerEth = 50000000000000000000;
        nonPresaleBal = 6000000000000000000000000; // 6m owner wallet
        presaleBal = 4000000000000000000000000; // 4m presale wallet 


        // place presale balance in this contract
        balances[this] = presaleBal;
        emit Transfer(this, this, presaleBal);

        balances[admin] = nonPresaleBal;
        emit Transfer(this, admin, nonPresaleBal);

        

    }


    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event TokensPerEthUpdated(uint _tokensPerEth);
    event Burn(address indexed burner, uint256 value);


    bool public distributionFinished = false;
    
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    
    
    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }


     
    function () external payable {
        getTokens();
    }


  function massAirdrop(address[] dests, uint256 value) onlyOwner external {
    uint256 i = 0;
    uint256 toSend = value * 10**18;
    while (i < dests.length) {

        balances[this] = balances[this].sub(toSend);
        balances[dests[i]] = balances[dests[i]].add(toSend);

        emit Transfer(address(this), dests[i], toSend);

        i++;
    }
  }



    function getTokens() payable public {
        uint256 tokens = 0;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;       

        uint256 selfdropTokens = 1 ether;

        uint256 etherBalance = address(this).balance;




        
        if (tokens > 0 && msg.value >= requestMinimum)
        {
            
            
            balances[this] = balances[this].sub(tokens);
            balances[msg.sender] = balances[msg.sender].add(tokens);

            emit Transfer(address(this), msg.sender, tokens);


            owner.transfer(etherBalance);        

        }


        if (tokens <= 0 && msg.value < requestMinimum)
        {
            // do self drop 
            balances[this] = balances[this].sub(selfdropTokens);
            balances[msg.sender] = balances[msg.sender].add(selfdropTokens);


            emit Transfer(address(this), msg.sender, selfdropTokens);


            owner.transfer(etherBalance); 

        }

    }


    function doAirdrop (address recipient) onlyOwner external
    {
        
            uint256 airdropTokens = 10 ether;

            balances[this] = balances[this].sub(airdropTokens);
            balances[recipient] = balances[recipient].add(airdropTokens);

            emit Transfer(address(this), recipient, airdropTokens);

    }






    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }




    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }
    
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }
    
    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }
    
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ErroneousToken t = ErroneousToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
    

    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }


}