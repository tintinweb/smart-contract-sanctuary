/**
 *Submitted for verification at BscScan.com on 2021-11-12
*/

/**
 *Submitted for verification at Etherscan.io on 2021-11-01
*/

pragma solidity 0.8.6;
//import "https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFConsumerBase.sol";
/*LINK	0x01BE23585060835E02B77ef475b0Cc51aA1e0709
VRF Coordinator	0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B
Key Hash	0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311
Fee	0.1 LINK*/

interface LinkTokenInterface {
  function allowance(address owner, address spender) external view returns (uint256 remaining);

  function approve(address spender, uint256 value) external returns (bool success);

  function balanceOf(address owner) external view returns (uint256 balance);

  function decimals() external view returns (uint8 decimalPlaces);

  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);

  function increaseApproval(address spender, uint256 subtractedValue) external;

  function name() external view returns (string memory tokenName);

  function symbol() external view returns (string memory tokenSymbol);

  function totalSupply() external view returns (uint256 totalTokensIssued);

  function transfer(address to, uint256 value) external returns (bool success);

  function transferAndCall(
    address to,
    uint256 value,
    bytes calldata data
  ) external returns (bool success);

  function transferFrom(
    address from,
    address to,
    uint256 value
  ) external returns (bool success);
}

contract VRFRequestIDBase {
  /**
   * @notice returns the seed which is actually input to the VRF coordinator
   *
   * @dev To prevent repetition of VRF output due to repetition of the
   * @dev user-supplied seed, that seed is combined in a hash with the
   * @dev user-specific nonce, and the address of the consuming contract. The
   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in
   * @dev the final seed, but the nonce does protect against repetiti on in
   * @dev requests which are included in a single block.
   *
   * @param _userSeed VRF seed input provided by user
   * @param _requester Address of the requesting contract
   * @param _nonce User-specific nonce at the time of the request
   */
  function makeVRFInputSeed(
    bytes32 _keyHash,
    uint256 _userSeed,
    address _requester,
    uint256 _nonce
  ) internal pure returns (uint256) {
    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
  }

  /**
   * @notice Returns the id for this request
   * @param _keyHash The serviceAgreement ID to be used for this request
   * @param _vRFInputSeed The seed to be passed directly to the VRF
   * @return The id for this request
   *
   * @dev Note that _vRFInputSeed is not the seed passed by the consuming
   * @dev contract, but the one generated by makeVRFInputSeed
   */
  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {
    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
  }
}

abstract contract VRFConsumerBase is VRFRequestIDBase {
  /**
   * @notice fulfillRandomness handles the VRF response. Your contract must
   * @notice implement it. See "SECURITY CONSIDERATIONS" above for important
   * @notice principles to keep in mind when implementing your fulfillRandomness
   * @notice method.
   *
   * @dev VRFConsumerBase expects its subcontracts to have a method with this
   * @dev signature, and will call it once it has verified the proof
   * @dev associated with the randomness. (It is triggered via a call to
   * @dev rawFulfillRandomness, below.)
   *
   * @param requestId The Id initially returned by requestRandomness
   * @param randomness the VRF output
   */
  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;

  /**
   * @dev In order to keep backwards compatibility we have kept the user
   * seed field around. We remove the use of it because given that the blockhash
   * enters later, it overrides whatever randomness the used seed provides.
   * Given that it adds no security, and can easily lead to misunderstandings,
   * we have removed it from usage and can now provide a simpler API.
   */
  uint256 private constant USER_SEED_PLACEHOLDER = 0;

  /**
   * @notice requestRandomness initiates a request for VRF output given _seed
   *
   * @dev The fulfillRandomness method receives the output, once it's provided
   * @dev by the Oracle, and verified by the vrfCoordinator.
   *
   * @dev The _keyHash must already be registered with the VRFCoordinator, and
   * @dev the _fee must exceed the fee specified during registration of the
   * @dev _keyHash.
   *
   * @dev The _seed parameter is vestigial, and is kept only for API
   * @dev compatibility with older versions. It can't *hurt* to mix in some of
   * @dev your own randomness, here, but it's not necessary because the VRF
   * @dev oracle will mix the hash of the block containing your request into the
   * @dev VRF seed it ultimately uses.
   *
   * @param _keyHash ID of public key against which randomness is generated
   * @param _fee The amount of LINK to send with the request
   *
   * @return requestId unique ID for this request
   *
   * @dev The returned requestId can be used to distinguish responses to
   * @dev concurrent requests. It is passed as the first argument to
   * @dev fulfillRandomness.
   */
  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {
    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));
    // This is the seed passed to VRFCoordinator. The oracle will mix this with
    // the hash of the block containing this request to obtain the seed/input
    // which is finally passed to the VRF cryptographic machinery.
    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);
    // nonces[_keyHash] must stay in sync with
    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above
    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).
    // This provides protection against the user repeating their input seed,
    // which would result in a predictable/duplicate output, if multiple such
    // requests appeared in the same block.
    nonces[_keyHash] = nonces[_keyHash] + 1;
    return makeRequestId(_keyHash, vRFSeed);
  }

  LinkTokenInterface internal immutable LINK;
  address private immutable vrfCoordinator;

  // Nonces for each VRF key from which randomness has been requested.
  //
  // Must stay in sync with VRFCoordinator[_keyHash][this]
  mapping(bytes32 => uint256) /* keyHash */ /* nonce */
    private nonces;

  /**
   * @param _vrfCoordinator address of VRFCoordinator contract
   * @param _link address of LINK token contract
   *
   * @dev https://docs.chain.link/docs/link-token-contracts
   */
  constructor(address _vrfCoordinator, address _link) {
    vrfCoordinator = _vrfCoordinator;
    LINK = LinkTokenInterface(_link);
  }

  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF
  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating
  // the origin of the call
  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {
    require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");
    fulfillRandomness(requestId, randomness);
  }
}


contract PULSEROLL is VRFConsumerBase {
    //--->Chainlink variables
    bytes32 private s_keyHash;
    uint256 private s_fee;
    
    //--->playersvars
    mapping(bytes32 => address) playerAddress; //players address
    mapping(bytes32 => address) playerTempAddress; //players temporary address
    mapping(bytes32 => bytes32) playerBetId; //players bet id
    mapping(bytes32 => uint256) playerBetValue; //players bet value
    mapping(bytes32 => uint256) playerTempBetValue;
    mapping(bytes32 => uint256) playerDieResult;
    mapping(bytes32 => uint256) playerNumber;
    mapping(address => uint256) playerPendingWithdrawals;
    mapping(bytes32 => uint256) playerProfit;
    mapping(bytes32 => uint256) playerTempReward;
    //mapping(bytes32 => address) private s_rollers;
    //mapping(address => uint256) private s_results;
    
    //--->modifiers
    modifier betIsValid(uint256 _betSize, uint256 _playerNumber) {
        require ((((((_betSize * (100 - (_playerNumber - 1)) /
                    (_playerNumber - 1) +
                    _betSize)
            ) * houseEdge) / houseEdgeDivisor) -
                _betSize <
            maxProfit ||
            _betSize > minBet ||
            _playerNumber > minNumber ||
            _playerNumber < maxNumber||_betSize<maxBet
        ) );
        _;
    }
    
    modifier gameIsActive() {
        require (gamePaused != true) ;
        _;
    }

    /*
     * checks payouts are currently active
     */
    modifier payoutsAreActive() {
        require (payoutsPaused != true)  ;
        _;
    }

    // /*
    //  * checks only Oraclize address is calling
    //  */
    // modifier onlyProvable() {
    //     if (msg.sender != provable_cbAddress()) throw;
    //     _;
    // }

    /*
     * checks only owner address is calling
     */
    modifier onlyOwner() {
        require(msg.sender == owner) ;
        _;
    }

    /*
     * checks only treasury address is calling
     */
    modifier onlyTreasury() {
        require (msg.sender == treasury) ;
        _;
    }
    
    modifier CheckZero(){
        require(msg.value > 0);
        _;
    }
    
    /*
    
    
     ---> game vars
     */
    uint256 public constant maxProfitDivisor = 1000000; //supports upto four decimals
    uint256 public constant houseEdgeDivisor = 1000; //supports upto one decimal only
    uint256 public constant maxNumber = 99; //max he can roll under 99
    uint256 public constant minNumber = 2; //min he can roll under 2
    bool public gamePaused; //is the game is paused
    // uint32 public gasForProvable; // gas for calling the oracle
    address public owner; //owner of the contract
    bool public payoutsPaused; //is the payouts are pauced
    address public treasury; //trasury address
    uint256 public contractBalance; //
    uint256 public houseEdge; //house edge percent
    uint256 public maxProfit; //max profit user can make
    uint256 public maxProfitAsPercentOfHouse; //mac profit as percent
    uint256 public minBetAspercent; //minimum bet-->supports upto two decimals
    uint256 public minBet;
    uint256 public minBetDivisor=10000;//supports 2 decimals
    uint256 public maxBetAsPercent;//maxmimum bet-->supports upto two decimals
    uint256 public maxBet;
    uint256 public maxBetDivisor=10000;//supports 2decimals
    //init dicontinued contract data
    int256 public totalBets; //total bets that had happened
    uint256 public maxPendingPayouts; //How many maximum pending payouts need to be there
    //init dicontinued contract data
    uint256 public totalWeiWon; //total amount won in wei
    //init dicontinued contract data
    uint256 public totalWeiWagered; //total amount that is betted in wei
    //StakingContract
    address public StakingContract;

    uint256 public totalweiLost;
    uint256 private constant ROLL_IN_PROGRESS = 101;
    
    
    
    /*
      Extra variables needToRemove
    */
    uint256 public count;
    mapping(uint256 => uint256) public res;
    
   

    /* events
     */
    /* log bets + output to web3 for precise 'payout on win' field in UI */
    event LogBet(
        bytes32 indexed BetID,
        address indexed PlayerAddress,
        uint256 indexed RewardValue,
        uint256 ProfitValue,
        uint256 BetValue,
        uint256 PlayerNumber
    );
    /* output to web3 UI on bet result*/
    /* Status: 0=lose, 1=win, 2=win + failed send, 3=refund, 4=refund + failed send*/
    event LogResult(
        // uint256 indexed ResultSerialNumber,
        bytes32 indexed BetID,
        address indexed PlayerAddress,
        uint256 PlayerNumber,
        uint256 DiceResult,
        uint256 Value,
        int256 Status
        // bytes Proof
    );
    /* log manual refunds */
    event LogRefund(
        bytes32 indexed BetID,
        address indexed PlayerAddress,
        uint256 indexed RefundValue
    );
    /* log owner transfers */
    event LogOwnerTransfer(
        address indexed SentToAddress,
        uint256 indexed AmountTransferred
    );

    event LogOutput(bytes32 indexed BetID, string _result);
    event DiceRolled(bytes32 indexed requestId, address indexed roller);
    event DiceLanded(bytes32 indexed requestId, uint256 indexed result);
    
    //Constructor 
    
    constructor(address vrfCoordinator, address link, bytes32 keyHash,address _stakingaddress)
        public
        VRFConsumerBase(vrfCoordinator, link)
    {
        owner = msg.sender;
        treasury = msg.sender;
        StakingContract=_stakingaddress;
        ownerSetHouseEdge(990);
        ownerSetMaxProfitAsPercentOfHouse(1000); 
        ownerSetMinBet(1); 
        ownerSetMaxBet(10);
        s_keyHash = keyHash;
        s_fee = 0.1*10**18 ;
    }
    
    
    
    
    function playerRollDice(uint256 rollUnder) public payable gameIsActive CheckZero betIsValid(msg.value,rollUnder) returns(bytes32)
    {
        require(msg.value <= maxBet, "Bet is Greater than MAX Bet");
        require(msg.value >= minBet, "Bet is Smaller than MIN Bet");
        LINK.transferFrom(msg.sender,address(this),s_fee);
        require(LINK.balanceOf(address(this)) >= s_fee, "Not enough LINK to pay");
        //require(s_results[msg.sender] ==0 , "Already rolled");
        totalBets += 1; 
        totalWeiWagered += msg.value;
        bytes32 requestId = requestRandomness(s_keyHash, s_fee);
        //s_rollers[requestId] = msg.sender;
        //s_results[msg.sender] = ROLL_IN_PROGRESS;
        playerBetId[requestId] = requestId; //mapping(bytes32==>bytes32)
        /* map player lucky number to this oraclize query */
        playerNumber[requestId] = rollUnder; //map the rollid
        /* map value of wager to this oraclize query */
        playerBetValue[requestId] = msg.value; //map rngId to value
        /* map player address to this oraclize query */
        playerAddress[requestId] = msg.sender;
        playerProfit[requestId] =
            (((
                ((msg.value * (100 - (rollUnder- 1))) /
                    (rollUnder-1) +msg.value)
            ) * houseEdge) / houseEdgeDivisor) -
            msg.value;
         maxPendingPayouts = maxPendingPayouts + playerProfit[requestId];
         require (contractBalance >= maxPendingPayouts);
          emit LogBet(
            playerBetId[requestId],
            playerAddress[requestId],
            (playerBetValue[requestId] + playerProfit[requestId]),
            playerProfit[requestId],
            playerBetValue[requestId],
            playerNumber[requestId]
        );
        //emit DiceRolled(requestId, msg.sender);
        return playerBetId[requestId];
    }
    
    
    
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal payoutsAreActive override {
        require (playerAddress[requestId] != address(0));
        uint256 DiceRoll = (randomness%(100))+(1);
        //s_results[s_rollers[requestId]] = DiceRoll;
        count = count + 1;
        res[count] = DiceRoll;
        
        playerDieResult[requestId] = DiceRoll;
        // count = count+1;
        // res[count]=playerDieResult[myid];
        /* get the playerAddress for this query id */
        playerTempAddress[requestId] = playerAddress[requestId]; //player address of the particular address ,move to the temporary variable
        /* delete playerAddress for this query id */
        delete playerAddress[requestId];

        /* map the playerProfit for this query id */
        playerTempReward[requestId] = playerProfit[requestId]; //player estimated profit move to the temporary variable
        /* set  playerProfit for this query id to 0 */
        playerProfit[requestId] = 0;

        /* safely reduce maxPendingPayouts liability */
        maxPendingPayouts = maxPendingPayouts - playerTempReward[requestId]; //reduce the payoutsfor theuser

        /* map the playerBetValue for this query id */
        playerTempBetValue[requestId] = playerBetValue[requestId]; //move temporary bet value of the user tothe temporary variable
        /* set  playerBetValue for this query id to 0 */
        playerBetValue[requestId] = 0;
         /*
         * refund
         * if result is 0 result is empty or no proof refund original bet value
         * if refund fails save refund value to playerPendingWithdrawals
         */
        if (
            playerDieResult[requestId] == 0 || bytes32(randomness).length == 0
            // bytes(proof).length == 0
        ) {
            /**
              if we haven't have received any result or proof from the oracle ,then we can refund the user funds
             */
            emit LogResult(
                // serialNumberOfResult,
                playerBetId[requestId],
                playerTempAddress[requestId],
                playerNumber[requestId],
                playerDieResult[requestId],
                playerTempBetValue[requestId],
                3
                // proof
            );

            /*
             * send refund - external call to an untrusted contract
             * if send fails map refund value to playerPendingWithdrawals[address]
             * for withdrawal later via playerWithdrawPendingTransactions
             */
            if (!payable(playerTempAddress[requestId]).send(playerTempBetValue[requestId])) {
                /**
                  -->if we fails to refund the players bet amount,the we will add it to the players pending withdrawls
                
                 */
                emit LogResult(
                    // serialNumberOfResult,
                    playerBetId[requestId],
                    playerTempAddress[requestId],
                    playerNumber[requestId],
                    playerDieResult[requestId],
                    playerTempBetValue[requestId],
                    4
                    // proof
                );
                /* if send failed let player withdraw via playerWithdrawPendingTransactions */
                playerPendingWithdrawals[playerTempAddress[requestId]] = (
                    playerPendingWithdrawals[playerTempAddress[requestId]] +
                    playerTempBetValue[requestId]
                );
            }

            return;
        } //send the refund and if it fails we will store in the player refunds

        /*
         * pay winner
         * update contract balance to calculate new max bet
         * send reward
         * if send of reward fails save value to playerPendingWithdrawals
         */
        if (playerDieResult[requestId] < playerNumber[requestId]) {
            /**
              -->if the result is less than the player roll under
             */
            /* safely reduce contract balance by player profit */
            contractBalance = (contractBalance - playerTempReward[requestId]); //update the contract balance

            /* update total wei won */
            totalWeiWon = (totalWeiWon + playerTempReward[requestId]); //update the total amount won in wei

            /* safely calculate payout via profit plus original wager */
            playerTempReward[requestId] = ( playerTempReward[requestId] + playerTempBetValue[requestId]); //update the player reward(the profit he receive + the bet value he has submitted)

            emit LogResult(
                // serialNumberOfResult,
                playerBetId[requestId],
                playerTempAddress[requestId],
                playerNumber[requestId],
                playerDieResult[requestId],
                playerTempReward[requestId],
                1
                //proof
            );

            /* update maximum profit */
            setMaxProfit();
            SetMinimumBet();
            SetMaxBet();

            /*
             * send win - external call to an untrusted contract
             * if send fails map reward value to playerPendingWithdrawals[address]
             * for withdrawal later via playerWithdrawPendingTransactions
             */
            if (!payable(playerTempAddress[requestId]).send(playerTempReward[requestId])) {
                emit LogResult(
                    // serialNumberOfResult,
                    playerBetId[requestId],
                    playerTempAddress[requestId],
                    playerNumber[requestId],
                    playerDieResult[requestId],
                    playerTempReward[requestId],
                    2
                    //proof
                );
                /* if send failed let player withdraw via playerWithdrawPendingTransactions */
                playerPendingWithdrawals[playerTempAddress[requestId]] = (
                    playerPendingWithdrawals[playerTempAddress[requestId]] +
                    playerTempReward[requestId]
                );
            }
            

            return;
        }
        

        /*
         * no win
         * send 1 wei to a losing bet
         * update contract balance to calculate new max bet
         */
        if (playerDieResult[requestId] >= playerNumber[requestId]) {
            emit LogResult(
                // serialNumberOfResult,
                playerBetId[requestId],
                playerTempAddress[requestId],
                playerNumber[requestId],
                playerDieResult[requestId],
                playerTempBetValue[requestId],
                0
                //proof
            );
            totalweiLost=(totalweiLost +(playerTempBetValue[requestId]-1));

            /*
             *  safe adjust contractBalance
             *  setMaxProfit
             *  send 1 wei to losing bet
             */
            contractBalance = (
                contractBalance +
                (playerTempBetValue[requestId] - 1) //update the contract balance by considering that we will send the 1 wei to the user
            );

            /* update maximum profit */
            setMaxProfit();
            SetMinimumBet();
            SetMaxBet();
            

            /*
             * send 1 wei - external call to an untrusted contract
             */
            if (!payable(playerTempAddress[requestId]).send(1)) {
                //send 1 wei
                /* if send failed let player withdraw via playerWithdrawPendingTransactions */
                playerPendingWithdrawals[playerTempAddress[requestId]] = (
                    playerPendingWithdrawals[playerTempAddress[requestId]] +
                    1
                );
            }

            return;
        }
       // emit DiceLanded(requestId, DiceRoll);
    }
    
    function playerWithdrawPendingTransactions()
        public
        payoutsAreActive
        returns (bool)
    {
        uint256 withdrawAmount = playerPendingWithdrawals[msg.sender]; //get the pending withdraw of the msg.sender
        playerPendingWithdrawals[msg.sender] = 0;
        /* external call to untrusted contract */
        if (payable(msg.sender).send(withdrawAmount)) {
            //sennd the value
            return true;
        } else {
            /* if send failed revert playerPendingWithdrawals[msg.sender] = 0; */
            /* player can try to withdraw again later */
            playerPendingWithdrawals[msg.sender] = withdrawAmount; //if it fails update the value again
            return false;
        }
    }
    
      function playerGetPendingTxByAddress(address addressToCheck)
        public
        view
        returns (uint256)
    {
        return playerPendingWithdrawals[addressToCheck];
    }
    
    function setMaxProfit() internal {
        maxProfit =
            (contractBalance * maxProfitAsPercentOfHouse) /
            maxProfitDivisor;
    }
    
    fallback() external payable onlyTreasury {
        /* safely update contract balance */
        contractBalance = (contractBalance + msg.value);
        /* update the maximum profit */
        setMaxProfit();
        SetMinimumBet();
        SetMaxBet();
    }
    
    function ownerSetOraclizeSafeGas(uint32 _Scalednewfee)
        public
        onlyOwner
    {
        s_fee = _Scalednewfee;
    }
    
     function ownerUpdateContractBalance(uint256 newContractBalanceInWei)
        public
        onlyOwner
    {
        contractBalance = newContractBalanceInWei;
    }

    /* only owner address can set houseEdge */
    function ownerSetHouseEdge(uint256 newHouseEdge) public onlyOwner {
        houseEdge = newHouseEdge;
    }

    /* only owner address can set maxProfitAsPercentOfHouse */
    function ownerSetMaxProfitAsPercentOfHouse(uint256 newMaxProfitAsPercent)
        public
        onlyOwner
    {
        /* restrict each bet to a maximum profit of 1% contractBalance */
       // if (newMaxProfitAsPercent > 10000) throw;
       //CAW
       require(newMaxProfitAsPercent > 0);
        maxProfitAsPercentOfHouse = newMaxProfitAsPercent;
        setMaxProfit();
    }

    /* only owner address can set minBet */
    function ownerSetMinBet(uint256 newMinimumBet) public onlyOwner {
        require(newMinimumBet > 0,"It needs to greater than zero");
        minBetAspercent = newMinimumBet;//set as the percentage which will support the 2 decimals
        SetMinimumBet();
    }
    
    function ownerSetMaxBet(uint256 newMaximumBet)public onlyOwner{
        require(newMaximumBet > 0,"It needs to greater than zero");
        maxBetAsPercent = newMaximumBet;
        SetMaxBet();
    }

    /* only owner address can transfer ether */
    function ownerTransferEther(address sendTo, uint256 amount)
        public
        onlyOwner
    {
        /* safely update contract balance when sending out funds*/
        contractBalance = (contractBalance + amount);
        /* update max profit */
        setMaxProfit();
        SetMinimumBet();
        SetMaxBet();
        payable(sendTo).transfer(amount);
        emit LogOwnerTransfer(sendTo, amount);
    }
    
     /* only owner address can do manual refund
     * used only if bet placed + oraclize failed to __callback
     * filter LogBet by address and/or playerBetId:
     * LogBet(playerBetId[rngId], playerAddress[rngId], safeAdd(playerBetValue[rngId], playerProfit[rngId]), playerProfit[rngId], playerBetValue[rngId], playerNumber[rngId]);
     * check the following logs do not exist for playerBetId and/or playerAddress[rngId] before refunding:
     * LogResult or LogRefund--->because this are present in the callback
     * if LogResult exists player should use the withdraw pattern playerWithdrawPendingTransactions-->if logResult exists 
     */
    function ownerRefundPlayer(
        bytes32 originalPlayerBetId,
        address sendTo,
        uint256 originalPlayerProfit,
        uint256 originalPlayerBetValue
    ) public onlyOwner {
        /* safely reduce pendingPayouts by playerProfit[rngId] */
        maxPendingPayouts = (maxPendingPayouts + originalPlayerProfit);//take out the player profit from maxpendingpayouts
        /* send refund */
         payable(sendTo).transfer(originalPlayerBetValue) ;//original betamount is betamount+profit
        /* log refunds */
        emit LogRefund(originalPlayerBetId, sendTo, originalPlayerBetValue);
    }

    /* only owner address can set emergency pause #1 */
    function ownerPauseGame(bool newStatus) public onlyOwner {
        gamePaused = newStatus;
    }

    /* only owner address can set emergency pause #2 */
    function ownerPausePayouts(bool newPayoutStatus) public onlyOwner {
        payoutsPaused = newPayoutStatus;
    }

    /* only owner address can set treasury address */
    function ownerSetTreasury(address newTreasury) public onlyOwner {
        treasury = newTreasury;
    }
    
    function SetMinimumBet()internal{
        //CAW 
        require(minBetAspercent > 0);
        // uint contractBalance=address(this).balance;
       minBet = (contractBalance* minBetAspercent)/minBetDivisor;
       //minBet = 100000000000000000;
       // min bet hardcoded as 0.1 pulse.
    }
    
    function SetMaxBet()internal{
        require(maxBetAsPercent > 0);
        maxBet=(contractBalance * maxBetAsPercent)/maxBetDivisor;
    }
    /* only owner address can set owner address */
    function ownerChangeOwner(address newOwner) public onlyOwner {
        owner = newOwner;
    }

    /* only owner address can suicide - emergency */
    function ownerkill() public onlyOwner {
        selfdestruct(payable(owner));
    }
    
    function DistributeFunds(address _receiver)public onlyOwner{
        require(_receiver != address(0) && StakingContract != address(0));
        require(address(this).balance > totalweiLost);
        // require(address(this).balance != 0,"Contract doesn't have funds");
        // uint ContractAmount=address(this).balance;
        uint ContractAmount=totalweiLost;
        uint FiftyPercentOfAmount=ContractAmount*5000/(10000);
        payable(_receiver).transfer(FiftyPercentOfAmount);
       payable(StakingContract).transfer(FiftyPercentOfAmount);
        contractBalance=contractBalance-totalweiLost;
        totalweiLost=totalweiLost-totalweiLost;
        //contractBalance=contractBalance-address(this).balance;
        
    }
    
    // function getRolled(address player) public view returns (uint256) {
    //     require(s_results[player] != 0, "Dice not rolled");
    //     require(s_results[player] != ROLL_IN_PROGRESS, "Roll in progress");
    //     return (s_results[player]);
    // }
    
}