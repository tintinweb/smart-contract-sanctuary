/*

Welcome to the MEGA ecosystem!

Trusted. Professional. Unruggable. 
The only source of passive income you'll ever need. 
The MEGABinance ecosystem contains a variety of dividend tokens with completely unique tokenomics and never before seen safety features.


Join the mission -> https://t.me/megabinancecoin
                 -> https://megabinance.com




*** MEGABNB ***

        Welcome to the first MEGABinance token.
        This coin offers generous dividends paid in BNB. 
        Just hodl $MEGABNB in your wallet and receive BNB dividends automagically!
        No claiming. No stress. Just passive income.
        
        The functionality of this code does not rely on team decisions after deployment! All parameters are set indefinetly to create a fully trustless system.

        * 100% Scam-Proof 
        * 100% Rug-Proof 
        * 100% Trustless


* Tokenomics

        * 10% BNB Reflection
        * 3% Liquidity Fee  
        * 2% Marketing Fee

        * 2% Max wallet balance to avoid token concentration 
        * 0.5% Max transaction amount to avoid whale transactions  
        * 10 sec cooldown timer to avoid algorithmic trading activity



* Introducing Unique Safety Features

        MEGABinance is all about transparency, safety and rewarding projects for all investors.
        All of our tokens are designed by our experienced development team and we were not shy to take extra steps
        and work extra hard to be able to confidently say this:
   
        THIS COIN IS UNRUGGABLE! - Seriously!

            * All of the team wallets are locked indefinetly - no team member can ever sell tokens.
              The team wallet lock is hardcoded in the contract and can not be changed after deployment. 
              The wallets will be locked forever. This feature was never before seen in any project!
            * Max. transaction limits avoid whale activity and huge price fluctuations caused by volume.
            * Max. transaction limits can not be changed after deployment. Transaction limits are set forever!
            * Max. wallet sizes avoid existance of whale wallets.
            * Transaction cooldown timers are set to use block timestamps to ensure enforcement of the cooldown rule.
            * Cooldown can not be disabled or changed after deployment. Cooldown of 10sec is set forever!


    If you have any questions regarding the contract or the project itself, join our telegram group and ask the team directly -> t.me/megabinancecoin or learn more on -> megabinance.com
    We are here for you!        

    Enjoy this project and your rewards! 
    We are glad to have you here and stay tuned for more MEGABinance projects.       
    - For a better crypto world.

                                                                                                                                                                                                        
                                                                                                                                                                               
                                                                                                                                                           
                                                                                                                                                                                                      
                                                                                                                                                                                    
                                                                                                                                                                                                        
             `````````         ```````````    ````````````````````         `..---..`                  ``````````    ````````````````          ````````        ```````    ````````````````               
            /mmmmmmmmm:       `ymmmmmmmmmd`   ymmmmmmmmmmmmmmmmmmy     .:shmmNMMNNmdy+.              .hmmmmmmmmm-   ommmmmmmmmmmmmmddyo:`    .mmmmmmmmo       dmmmmmo    dmmmmmmmmmmmmmddhy+.           
           `dMMMMMMMMM+      `hMMMMMMMMMMy   -NMMMMMMMMMMMMMMMMMM+   .smMMMMMMMMMMMMMMNs.           -dMMMMMMMMMM:   sMMMMMMMMMMMMMMMMMMMd-   .MMMMMMMMMo      NMMMMMy    NMMMMMMMMMMMMMMMMMMNy`         
           :MMMMMMMMMMs     `dMMMMMMMMMMM-   yMMMMMMMNNNNNNNNNNNm`  +NMMMMMMMNmmmNMMMMMMm.         -mMMMMMNMMMMM:   sMMMMMMNdddddNMMMMMMMm   .MMMMMMMMMMs`    NMMMMMy    NMMMMMMdddddmNMMMMMMMs         
           hMMMMMMMMMMd    `dMMMMMMMMMMMh   .NMMMMMMo```````````   sMMMMMMMh:`   :mMMMMNNo        :NMMMMMssMMMMM:   sMMMMMMs     `hMMMMMMM.  .MMMMMMMMMMMy`   NMMMMMy    NMMMMMM-     .NMMMMMMh         
          -MMMMMMdMMMMN   .dMMMMNdMMMMMM:   oMMMMMMN:````````     /MMMMMMMo       -++/--.        /NMMMMMs oMMMMM:   sMMMMMMs    `-dMMMMMMh   .MMMMMMNMMMMMh`  NMMMMMy    NMMMMMM-    `/MMMMMMM/         
          yMMMMMm:MMMMM` `dMMMMN:dMMMMMd   `mMMMMMMMMMMMMMMMN.   `dMMMMMMh    -::::::::::-      +MMMMMMy  oMMMMM:   sMMMMMMMMMMMMMMMMMMd+    .MMMMMM/mMMMMMd` NMMMMMy    NMMMMMMMMMMMMMMMMMNy-          
         .MMMMMM+`MMMMM-`mMMMMN-/MMMMMM/   +MMMMMMMMMMMMMMMMy    .MMMMMMMo   `NMMMMMMMMMM+     sMMMMMMy`  oMMMMM:   sMMMMMMMMMMMMMMMMmy+-    .MMMMMM/.mMMMMMd`mMMMMMy    NMMMMMMMMMMMMMMMMds/`          
         sMMMMMN.`mMMMM/dMMMMm- dMMMMMm`  `mMMMMMMmsssssssss.    .MMMMMMMo   :mmmMMMMMMMm`   `yMMMMMMMmdddNMMMMM:   sMMMMMMmyyyyyymMMMMMMh`  .MMMMMM/ `dMMMMMdmMMMMMy    NMMMMMMhyyyyyhMMMMMMN+         
        .NMMMMMy  yMMMMNMMMMm. -MMMMMMo   /MMMMMMM:              `hNMMMMMN.   `:hMMMMMMM+   `hMMMMMMMMMMMMMMMMMM:   sMMMMMMs      `NMMMMMMy  .MMMMMM/  `hMMMMMMMMMMMy    NMMMMMM-      /MMMMMMM:        
        oMMMMMM:  +MMMMMMMMd.  yMMMMMN`   dMMMMMMNsoooooooooo+    `/:::::/:-/sdNMMMMMMMm`  .dMMMMMMdhhhhhhmMMMMM:   sMMMMMMy-----:oMMMMMMMh  .MMMMMM/   `yMMMMMMMMMMy    NMMMMMM/-----:hMMMMMMM/        
       `mMMMMMd   -MMMMMMMd`  .MMMMMMs   :MMMMMMMMMMMMMMMMMMMy     +mNmmmNNNMMMMMMMMMMM/  -mMMMMMMy`      oMMMMM:   sMMMMMMMNNNNNNMMMMMMMN:  .MMMMMM/    `yMMMMMMMMMy    NMMMMMMNNNNNNMMMMMMMMd`        
       /MMMMMM:   `MMMMMMh`   sMMMMMN.   hMMMMMMMMMMMMMMMMMMN:      -sdNMMMMMMNdsyMMMMm` :mMMMMMMy`       oMMMMM:   sMMMMMMMMMMMMMMMMMNmy-   .MMMMMM/     `sMMMMMMMMy    NMMMMMMMMMMMMMMMMMNdo`         
       :+++++/     /++++/`    /+++++:    /++++++++++++++++++/         `.-/++/-.` -++++-  :++++++/`        -++++/`   :+++++++++++++++/:-`     `++++++.       /+++++++:    +++++++++++++++//-.`           
                                                                                                                                                                                                        
                                                                                                                                                                                                        
                                             
*/



// SPDX-License-Identifier: MIT


pragma solidity ^0.6.2;

import "./DividendPayingToken.sol";
import "./SafeMath.sol";
import "./IterableMapping.sol";
import "./Ownable.sol";
import "./IUniswapV2Pair.sol";
import "./IUniswapV2Factory.sol";
import "./IUniswapV2Router.sol";

contract MegaBNB is ERC20, Ownable {
    using SafeMath for uint256;

    IUniswapV2Router02 public uniswapV2Router;
    address public  uniswapV2Pair;

    bool private swapping;
    bool public swapEnabled;

    MegaBNBDividendTracker public dividendTracker;

    address public deadWallet = 0x000000000000000000000000000000000000dEaD;

    uint256 public decimalNumber = 4; //Reuseable decimal definition

    // Thresholds for wallets and transactions
    uint256 public maxWalletBalance = 2000000000 * (10**decimalNumber);           // 2% of total Supply (2.000.000.000 Tokens) 
    uint256 public maxTxAmount = 500000000 * (10**decimalNumber);                 // 0.5% of total Supply (500.000.000 Tokens) 
    
    // Threshold for token swap
    uint256 public swapTokensAtAmount = 200000000 * (10**decimalNumber);          // 0.2% of total Supply (200.000.000 Tokens) 
    
    mapping (address => uint256) _lastTX;
    bool coolDownEnabled = true;

    // Fee definitions
    uint256 public BNBRewardsFee = 10;
    uint256 public liquidityFee = 3;
    uint256 public marketingFee = 2;
    
    uint256 public totalFees = BNBRewardsFee.add(liquidityFee).add(marketingFee);
    
    // Main Wallets
    address public liquidityWallet;
    address public marketingWallet;
    
    // Team Wallets
    address private teamWalletYachty;
    address private teamWalletDrake;
    address private teamWalletZucchini;
    address private teamWalletAlice;

    // use by default 500,000 gas to process auto-claiming dividends
    uint256 public gasForProcessing = 500000;

     // exlcude from fees, max transaction amount and dividends
    mapping (address => bool) private _isExcludedFromFees;
    mapping (address => bool) private _isExcludedFromMaxTxAmount;
    mapping (address => bool) private _isExcludedFromDividends;

    // exclude Team Wallets from selling
    mapping(address => bool) private _isExcludedTeamFromSell;


    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses
    // could be subject to a maximum transfer amount
    mapping (address => bool) public automatedMarketMakerPairs;

    event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress);

    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);

    event ExcludeFromFees(address indexed account, bool isExcluded);
    event ExcludeFromMaxTxAmount(address indexed account, bool isExcluded);
    event ExcludeFromDividends(address indexed account, bool isExcluded);
    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);

    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);

    event LiquidityWalletUpdated(address indexed newLiquidityWallet, address indexed oldLiquidityWallet);

    event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);

    event SwapAndLiquify(
        uint256 tokensSwapped,
        uint256 ethReceived,
        uint256 tokensIntoLiqudity
    );

    event SendDividends(
    	uint256 tokensSwapped,
    	uint256 amount
    );

    event SendMarketing(
    	uint256 tokensSwapped,
    	uint256 amount
    );

    event ProcessedDividendTracker(
    	uint256 iterations,
    	uint256 claims,
        uint256 lastProcessedIndex,
    	bool indexed automatic,
    	uint256 gas,
    	address indexed processor
    );

    constructor() public ERC20("MegaBNB", "MBNB") {

    	dividendTracker = new MegaBNBDividendTracker();
    	IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);
         // Create a uniswap pair for this new token
        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());

        uniswapV2Router = _uniswapV2Router;
        uniswapV2Pair = _uniswapV2Pair;

        //Main wallet definitions
        liquidityWallet = owner();
        marketingWallet = 0x1A7f41A6A94619a82Ec0a8A2F4fc678B40658dE2;

        //MegaBinance team wallets 
        teamWalletYachty = 0xC6f55A80DEf7488d60b7017EAE98198caD6288f0;
        teamWalletDrake = 0x88a8b7495280a1459A1a2F6a67bE0Bff4d1b1654;
        teamWalletZucchini = 0x97109c16c8524e56dA790A8b976f9D014f67284a;
        teamWalletAlice = 0x3f2d6B004c2857bf22A9C044ba2B6F75920a8aE8;

        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);


        // Excluded from receiving dividends
        dividendTracker.excludeFromDividends(address(dividendTracker),true);
        dividendTracker.excludeFromDividends(address(this),true);
        dividendTracker.excludeFromDividends(address(deadWallet),true);
        dividendTracker.excludeFromDividends(address(_uniswapV2Router),true);


        // Excluded from fee payments
        excludeFromFees(owner(), true);
        excludeFromMaxTxAmount(owner(), true);
        excludeFromFees(address(marketingWallet), true);
        excludeFromFees(address(this), true);


        // Excluded from selling tokens
        excludeTeamFromSell(address(teamWalletYachty), true);
        excludeTeamFromSell(address(teamWalletDrake), true);
        excludeTeamFromSell(address(teamWalletZucchini), true);
        excludeTeamFromSell(address(teamWalletAlice), true);


        // _mint is an internal function in ERC20.sol that is only called here, and CAN NOT be called ever again
        _mint(owner(), 1 * 10**11 * (10**decimalNumber));

    }


    receive() external payable {    }


    function updateDividendTracker(address newAddress) public onlyOwner {
        require(newAddress != address(dividendTracker), "MegaBNB: The dividend tracker already has that address");

        MegaBNBDividendTracker newDividendTracker = MegaBNBDividendTracker(payable(newAddress));

        require(newDividendTracker.owner() == address(this), "MegaBNB: The new dividend tracker must be owned by the MegaBNB token contract");

        newDividendTracker.excludeFromDividends(address(newDividendTracker), true);
        newDividendTracker.excludeFromDividends(address(this), true);
        newDividendTracker.excludeFromDividends(owner(), true);
        newDividendTracker.excludeFromDividends(address(uniswapV2Router), true);

        emit UpdateDividendTracker(newAddress, address(dividendTracker));

        dividendTracker = newDividendTracker;
    }

    function updateUniswapV2Router(address newAddress) public onlyOwner {
        require(newAddress != address(uniswapV2Router), "MegaBNB: The router already has that address");
        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));
        uniswapV2Router = IUniswapV2Router02(newAddress);
        address _uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())
            .createPair(address(this), uniswapV2Router.WETH());
        uniswapV2Pair = _uniswapV2Pair;
    }

    function excludeFromFees(address account, bool excluded) public onlyOwner {
        require(_isExcludedFromFees[account] != excluded, "MegaBNB: Account is already the value of 'excluded'");
        _isExcludedFromFees[account] = excluded;

        emit ExcludeFromFees(account, excluded);
    }

    function excludeFromMaxTxAmount(address account, bool excluded) public onlyOwner {
        require(_isExcludedFromMaxTxAmount[account] != excluded, "MegaBNB: Account is already the value of 'excluded'");
        _isExcludedFromMaxTxAmount[account] = excluded;

        emit ExcludeFromMaxTxAmount(account, excluded);
    }

    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {
        for(uint256 i = 0; i < accounts.length; i++) {
            _isExcludedFromFees[accounts[i]] = excluded;
        }

        emit ExcludeMultipleAccountsFromFees(accounts, excluded);
    }

    function setLiqudiityWallet(address newWallet) external onlyOwner{
        liquidityWallet = newWallet;
    }

    function setMarketingWallet(address newWallet) external onlyOwner{
        marketingWallet = newWallet;
    }

    function setSwapTokensAtAmount(uint256 amount) external onlyOwner{
        swapTokensAtAmount = amount * 10**decimalNumber;
    }
    
    function setCoolDownEnabled(bool _enabled) external onlyOwner{
        coolDownEnabled = _enabled;
    }

    function setBNBRewardsFee(uint256 value) external onlyOwner{
        BNBRewardsFee = value;
        totalFees = BNBRewardsFee.add(liquidityFee).add(marketingFee);
    }

    function setLiquidityFee(uint256 value) external onlyOwner{
        liquidityFee = value;
        totalFees = BNBRewardsFee.add(liquidityFee).add(marketingFee);
    }

    function setMarketingFee(uint256 value) external onlyOwner{
        marketingFee = value;
        totalFees = BNBRewardsFee.add(liquidityFee).add(marketingFee);
    }

    function setMaxWalletBalance(uint256 amount) external onlyOwner{
        maxWalletBalance = amount * 10**decimalNumber;
    }

    function setMaxTxAmount(uint256 amount) internal {
        maxTxAmount = amount * 10**decimalNumber;
    }

    //Internal function that excludes team members from selling tokens
    function excludeTeamFromSell(address account, bool excluded) internal {
        _isExcludedTeamFromSell[account] = excluded;
    }

    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {
        require(pair != uniswapV2Pair, "MegaBNB: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs");

        _setAutomatedMarketMakerPair(pair, value);
    }


    function _setAutomatedMarketMakerPair(address pair, bool value) private {
        require(automatedMarketMakerPairs[pair] != value, "MegaBNB: Automated market maker pair is already set to that value");
        automatedMarketMakerPairs[pair] = value;

        if(value) {
            dividendTracker.excludeFromDividends(pair, true);
        }

        emit SetAutomatedMarketMakerPair(pair, value);
    }


    function updateGasForProcessing(uint256 newValue) public onlyOwner {
        require(newValue >= 200000 && newValue <= 600000, "MegaBNB: gasForProcessing must be between 200,000 and 600,000");
        require(newValue != gasForProcessing, "MegaBNB: Cannot update gasForProcessing to same value");
        emit GasForProcessingUpdated(newValue, gasForProcessing);
        gasForProcessing = newValue;
    }

    function updateClaimWait(uint256 claimWait) external onlyOwner {
        dividendTracker.updateClaimWait(claimWait);
    }

    function getClaimWait() external view returns(uint256) {
        return dividendTracker.claimWait();
    }

    function getTotalDividendsDistributed() external view returns (uint256) {
        return dividendTracker.totalDividendsDistributed();
    }

    function isExcludedFromFees(address account) public view returns(bool) {
        return _isExcludedFromFees[account];
    }

    function isExcludedFromMaxTxAmount(address account) public view returns(bool) {
        return _isExcludedFromMaxTxAmount[account];
    }

    function isExcludedFromDividends(address account) public view returns(bool) {
        return _isExcludedFromDividends[account];
    }

    function withdrawableDividendOf(address account) public view returns(uint256) {
    	return dividendTracker.withdrawableDividendOf(account);
  	}

	function dividendTokenBalanceOf(address account) public view returns (uint256) {
		return dividendTracker.balanceOf(account);
	}

	function setSwapEnabled(bool _enabled) external onlyOwner{
	    swapEnabled = _enabled;
	}

	function excludeFromDividends(address account, bool excluded) external onlyOwner{

        require(_isExcludedFromDividends[account] != excluded, "MegaBNB: Account is already the value of 'excluded'");
        
        dividendTracker.excludeFromDividends(account, excluded);

        emit ExcludeFromDividends(account, excluded);

 }

    function getAccountDividendsInfo(address account)
        external view returns (
            address,
            int256,
            int256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256) {
        return dividendTracker.getAccount(account);
    }

	function getAccountDividendsInfoAtIndex(uint256 index)
        external view returns (
            address,
            int256,
            int256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256) {
    	return dividendTracker.getAccountAtIndex(index);
    }

	function processDividendTracker(uint256 gas) external {
		(uint256 iterations, uint256 claims, uint256 lastProcessedIndex) = dividendTracker.process(gas);
		emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);
    }

    function claim() external {
		dividendTracker.processAccount(msg.sender, false);
    }

    function getLastProcessedIndex() external view returns(uint256) {
    	return dividendTracker.getLastProcessedIndex();
    }

    function getNumberOfDividendTokenHolders() external view returns(uint256) {
        return dividendTracker.getNumberOfTokenHolders();
    }


    // Token transfer function

 function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(!_isExcludedTeamFromSell[from], "Team Wallets can not sell");

        if(amount == 0) {
            super._transfer(from, to, 0);
            return;
        }



        //For buy
        if(!_isExcludedFromFees[to] && !automatedMarketMakerPairs[to]){

            //Check for exceeding max wallet balance
            require(balanceOf(to).add(amount) <= maxWalletBalance, 'Balance is exceeding maxWalletBalance');
        }
        


        //For sell
        if(!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {

            //Check for cooldown
            if(coolDownEnabled){
                uint256 timePassed = block.timestamp.sub(_lastTX[from]); // Use block timestamp for cooldown enforcement
                require(timePassed > 10 seconds, "Must wait 10 seconds between trades"); //Hardcoded 10 sec cooldown - can not be changed
            }
            
            require(amount <= maxTxAmount, "Amount is exceeding maxTxAmount"); //Check for exceeding max transaction amount
            _lastTX[from] = block.timestamp; //Set new last transaction timestamp for cooldown of next trade
        }


        //For Buy
        if(!_isExcludedFromFees[to] && automatedMarketMakerPairs[from]){
            if(coolDownEnabled){
                uint256 timePassed = block.timestamp.sub(_lastTX[to]); // Use block timestamp for cooldown enforcement
                require(timePassed > 10 seconds, "Must wait 10 seconds between trades"); //Hardcoded 10 sec cooldown - can not be changed
            }

            require(amount <= maxTxAmount, "Amount is exceeding maxTxAmount"); //Check for exceeding max transaction amount
            _lastTX[to] = block.timestamp; //Set new last transaction timestamp for cooldown of next trade
        }


		uint256 contractTokenBalance = balanceOf(address(this)); //get current contract token balance

        bool canSwap = contractTokenBalance >= swapTokensAtAmount; //check wether swap threshold is reached already

        
        if( canSwap &&
            !swapping &&
            !automatedMarketMakerPairs[from] &&
            swapEnabled
        ) {
            swapping = true;
            contractTokenBalance = swapTokensAtAmount;


            // Swap and send marketing tokens
            uint256 marketingTokens = contractTokenBalance.mul(marketingFee).div(totalFees);
            swapAndSendMarketing(marketingTokens);

            // Swap and add liquidity tokens
            uint256 swapTokens = contractTokenBalance.mul(liquidityFee).div(totalFees);
            swapAndLiquify(swapTokens);

             // Swap and send dividend tokens
            uint256 sellTokens = balanceOf(address(this));
            swapAndSendDividends(sellTokens);

            swapping = false;
        }


        bool takeFee = !swapping;

        // Only take fees if account is not explicitly excluded from fees
        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {
            takeFee = false;
        }

     

        if(takeFee) {

            uint256 fees = amount.mul(totalFees).div(100);
        	amount = amount.sub(fees); //Calculate transaction amount with substracted fees
            super._transfer(from, address(this), fees); // Transfer fees to contract
        }

        super._transfer(from, to, amount); //Transfer tokens

        // Update dividend tracker
        try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}
        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}

        
        if(!swapping) {
	    	uint256 gas = gasForProcessing;

	    	try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {
	    		emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);
	    	}
	    	catch {

	    	}
        }
    }


    function swapAndLiquify(uint256 tokens) private {
       // split the contract balance into halves
        uint256 half = tokens.div(2);
        uint256 otherHalf = tokens.sub(half);

        // capture the contract's current ETH balance.
        // this is so that we can capture exactly the amount of ETH that the
        // swap creates, and not make the liquidity event include any ETH that
        // has been manually sent to the contract
        uint256 initialBalance = address(this).balance;

        // swap tokens for ETH
        swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered

        // how much ETH did we just swap into?
        uint256 newBalance = address(this).balance.sub(initialBalance);

        // add liquidity to uniswap
        addLiquidity(otherHalf, newBalance);

        emit SwapAndLiquify(half, newBalance, otherHalf);
    }


    function swapTokensForEth(uint256 tokenAmount) private {


        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();

        _approve(address(this), address(uniswapV2Router), tokenAmount);

        // make the swap
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0, // accept any amount of ETH
            path,
            address(this),
            block.timestamp
        );

    }

    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {

        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapV2Router), tokenAmount);

        // add the liquidity
        uniswapV2Router.addLiquidityETH{value: ethAmount}(
            address(this),
            tokenAmount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            liquidityWallet,
            block.timestamp
        );

    }

        function swapAndSendMarketing(uint256 tokens) private{
        swapTokensForEth(tokens);
        uint256 marketing = address(this).balance;

        (bool success,) = address(marketingWallet).call{value: marketing}("");

        if(success) {
   	 		 emit SendMarketing(tokens, marketing);
        }
    }

    function swapAndSendDividends(uint256 tokens) private{
        swapTokensForEth(tokens);
        uint256 dividends = address(this).balance;

        (bool success,) = address(dividendTracker).call{value: dividends}("");

        if(success) {
   	 		 emit SendDividends(tokens, dividends);
        }
    }
}

contract MegaBNBDividendTracker is Ownable, DividendPayingToken {
    using SafeMath for uint256;
    using SafeMathInt for int256;
    using IterableMapping for IterableMapping.Map;

    IterableMapping.Map private tokenHoldersMap;
    uint256 public lastProcessedIndex;

    mapping (address => bool) public excludedFromDividends;
    mapping (address => bool) private _isExcludedFromDividends;
    mapping (address => uint256) public lastClaimTimes;


    uint256 public decimalNumber = 4; //Change depending on token

    uint256 public claimWait;
    uint256 public minimumTokenBalanceForDividends;

    event ExcludeFromDividends(address indexed account);
    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);

    event Claim(address indexed account, uint256 amount, bool indexed automatic);

    constructor() public DividendPayingToken("MegaBNB_Dividen_Tracker", "MBNB_Dividend_Tracker") {
    	claimWait = 3600 seconds;
        minimumTokenBalanceForDividends = 200000 * (10**decimalNumber); //must hold 200.000 tokens
    }

    function _transfer(address, address, uint256) internal override {
        require(false, "MegaBNB_Dividend_Tracker: No transfers allowed");
    }

    /* 
    If you read this, you are one of the special investors who actually read the smart contracts that the team deploys.
    If you are here and read these words, please feel invited to join our special telegram channel for our professional investors.
    We will have special promotions, sweepstakes and AMAs for our elite investors only. Join us on t.me/megabinanceelite ðŸ¤«
    We are glad to have you! Enjoy the rest of the contract. 
    */
    
    function withdrawDividend() public override {
        require(false, "MegaBNB_Dividend_Tracker: withdrawDividend disabled. Use the 'claim' function on the main MegaBNB contract.");
    }

    function setMinimumTokenBalanceForDividends(uint256 amount) external onlyOwner{
        minimumTokenBalanceForDividends = amount * 10**decimalNumber;
    }

    function excludeFromDividends(address account, bool excluded) external onlyOwner {
    	require(_isExcludedFromDividends[account] !=excluded, "MegaBNB: Account is already the value of 'excluded'");
    	_isExcludedFromDividends[account] = excluded;

    	_setBalance(account, 0);
    	tokenHoldersMap.remove(account);

    	emit ExcludeFromDividends(account);
    }

    function updateClaimWait(uint256 newClaimWait) external onlyOwner {
        require(newClaimWait >= 60 && newClaimWait <= 14400, "MegaBNB_Dividend_Tracker: claimWait must be updated to between 1 Minute and 4 hours");
        require(newClaimWait != claimWait, "MegaBNB_Dividend_Tracker: Cannot update claimWait to same value");
        emit ClaimWaitUpdated(newClaimWait, claimWait);
        claimWait = newClaimWait;
    }

    function getLastProcessedIndex() external view returns(uint256) {
    	return lastProcessedIndex;
    }

    function getNumberOfTokenHolders() external view returns(uint256) {
        return tokenHoldersMap.keys.length;
    }



    function getAccount(address _account)
        public view returns (
            address account,
            int256 index,
            int256 iterationsUntilProcessed,
            uint256 withdrawableDividends,
            uint256 totalDividends,
            uint256 lastClaimTime,
            uint256 nextClaimTime,
            uint256 secondsUntilAutoClaimAvailable) {
        account = _account;

        index = tokenHoldersMap.getIndexOfKey(account);

        iterationsUntilProcessed = -1;

        if(index >= 0) {
            if(uint256(index) > lastProcessedIndex) {
                iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));
            }
            else {
                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length > lastProcessedIndex ?
                                                        tokenHoldersMap.keys.length.sub(lastProcessedIndex) :
                                                        0;


                iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));
            }
        }


        withdrawableDividends = withdrawableDividendOf(account);
        totalDividends = accumulativeDividendOf(account);

        lastClaimTime = lastClaimTimes[account];

        nextClaimTime = lastClaimTime > 0 ?
                                    lastClaimTime.add(claimWait) :
                                    0;

        secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp ?
                                                    nextClaimTime.sub(block.timestamp) :
                                                    0;
    }

    function getAccountAtIndex(uint256 index)
        public view returns (
            address,
            int256,
            int256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256) {
    	if(index >= tokenHoldersMap.size()) {
            return (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0, 0, 0);
        }

        address account = tokenHoldersMap.getKeyAtIndex(index);

        return getAccount(account);
    }

    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {
    	if(lastClaimTime > block.timestamp)  {
    		return false;
    	}

    	return block.timestamp.sub(lastClaimTime) >= claimWait;
    }

    function setBalance(address payable account, uint256 newBalance) external onlyOwner {
    	if(excludedFromDividends[account]) {
    		return;
    	}

    	if(newBalance >= minimumTokenBalanceForDividends) {
            _setBalance(account, newBalance);
    		tokenHoldersMap.set(account, newBalance);
    	}
    	else {
            _setBalance(account, 0);
    		tokenHoldersMap.remove(account);
    	}

    	processAccount(account, true);
    }

    function process(uint256 gas) public returns (uint256, uint256, uint256) {
    	uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;

    	if(numberOfTokenHolders == 0) {
    		return (0, 0, lastProcessedIndex);
    	}

    	uint256 _lastProcessedIndex = lastProcessedIndex;

    	uint256 gasUsed = 0;

    	uint256 gasLeft = gasleft();

    	uint256 iterations = 0;
    	uint256 claims = 0;

    	while(gasUsed < gas && iterations < numberOfTokenHolders) {
    		_lastProcessedIndex++;

    		if(_lastProcessedIndex >= tokenHoldersMap.keys.length) {
    			_lastProcessedIndex = 0;
    		}

    		address account = tokenHoldersMap.keys[_lastProcessedIndex];

    		if(canAutoClaim(lastClaimTimes[account])) {
    			if(processAccount(payable(account), true)) {
    				claims++;
    			}
    		}

    		iterations++;

    		uint256 newGasLeft = gasleft();

    		if(gasLeft > newGasLeft) {
    			gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));
    		}

    		gasLeft = newGasLeft;
    	}

    	lastProcessedIndex = _lastProcessedIndex;

    	return (iterations, claims, lastProcessedIndex);
    }

    function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) {
        uint256 amount = _withdrawDividendOfUser(account);

    	if(amount > 0) {
    		lastClaimTimes[account] = block.timestamp;
            emit Claim(account, amount, automatic);
    		return true;
    	}

    	return false;
    }
}

/*
                                     ,-.. _. ,. ,._               
                                 .-'         .     '.             
                                /             .      /_./.        
                               '                        '.        
                              .                           '       
                             '            =\ : , \         \      
                            '            '` `   `  =        '     
                            |,.        _\           ',       \    
                            /   \    ."               ',.    /    
                           || ,' `  ,                  ' \_.'     
                           |\ -. / ,       `'":,      /           
                         ,-= .   ,'       '_   `;.    |           
                        /  /  -'            "'`    ,:,     " If you don't find a way to make money       
                     _,/|,'    ,                   '         while you sleep, you'll work until you die."
              ___,--' | |                    (    /          - Warren Buffet
         _,-'`        . .      .            , '- _'      .-.  
       ,'              \        .       `,'"`';/.          ,'   ) 
     ,`                 .'       :     /  ';\\   '.     ,'    .'  
   ,'                   |.\       ';.'.,. .;.\\  ,..:_'_    .     
  /  .                    '.       .'';_:;'`  '_(        ' '-.    
  |   .                     '.'.,-'   ,       (    '" - ._    )   
 / .   `                      '.             _,'-._        ` (    
/    .                        _ |   '      .' '.    ' .  _    )   
                                          '      '        '   '   





MEGABinance Project 1 - "MEGABNB"
Official Deployment No. 001 

www.megabinance.com
                                                                                                                                                                                                        







*/