/**
 *Submitted for verification at Etherscan.io on 2022-01-15
*/

/*
* Generated by @Thrasher66099
*/

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IByteContract {
    function burn(address _from, uint256 _amount) external;
    function getReward(address _to) external;
    function updateRewardOnMint(address _user, uint256 tokenId) external;
    function updateReward(address _from, address _to, uint256 _tokenId) external;
}

interface ICitizen {
	function getRewardRate(address _user) external view returns(uint256);
    function getRewardsRateForTokenId(uint256) external view returns(uint256);
    function getCurrentOrFinalTime() external view returns(uint256);
    function reduceRewards(uint256, address) external;
    function increaseRewards(uint256, address) external;
    function getEnd() external returns(uint256);
}

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NTBytesBridge is Ownable {

    ICitizen public citizenContract;
    IByteContract public bytesContract;

    mapping(address=>uint256) correctionMapping;

    /*bytes functions
    function burn(address _from, uint256 _amount) external;
    function getReward(address _to) external;
    function updateRewardOnMint(address _user, uint256 tokenId) external;
    function updateReward(address _from, address _to, uint256 _tokenId) external;*/

    /*CITIZEN FUNCTIONS
	function getRewardRate(address _user) external view returns(uint256);
    function getRewardsRateForTokenId(uint256) external view returns(uint256);
    function getCurrentOrFinalTime() external view returns(uint256);
    function reduceRewards(uint256, address) external;
    function increaseRewards(uint256, address) external;
    function getEnd() external returns(uint256);*/

    function setCitizenContract(address _address) public onlyOwner
    {
        citizenContract = ICitizen(_address);
    }

    function setBytesContract(address _address) public onlyOwner
    {
        bytesContract = IByteContract(_address);
    }


    function burn(address _from, uint256 _amount) external
    {
        require(msg.sender == address(citizenContract), "You are not approved to burn tokens");
        bytesContract.burn(_from, _amount);
    }

    function getReward(address _to) external
    {
        require(msg.sender == address(citizenContract), "Citizen contract must get rewards");
        bytesContract.getReward(_to);
    }

    function updateRewardOnMint(address _user, uint256 tokenId) external
    {
        require(msg.sender == address(citizenContract), "You cannot update rewards on mint");
        //Set correctionMapping here to be used in next getRewardRate call
        correctionMapping[_user] = citizenContract.getRewardsRateForTokenId(tokenId);
        bytesContract.updateRewardOnMint(_user, tokenId);
    }

    function updateReward(address _from, address _to, uint256 _tokenId) external
    {
        require(msg.sender == address(citizenContract), "You cannot update rewards");
        bytesContract.updateReward(_from, _to, _tokenId);
    }

    function getRewardRate(address _user) external view returns(uint256)
    {
        uint256 _value = citizenContract.getRewardRate(_user);
        //The first time getRewardRate is called after a mint we adjust for the error case
        if(correctionMapping[_user] > 0)
        {
            _value -= correctionMapping[_user];
        }

        return _value;
    }
    function getRewardsRateForTokenId(uint256 tokenId) external view returns(uint256)
    {
        return citizenContract.getRewardsRateForTokenId(tokenId);
    }

    function getCurrentOrFinalTime() external view returns(uint256)
    {
        return citizenContract.getCurrentOrFinalTime();
    }

    function reduceRewards(uint256 _obsolete, address _user) external
    {
        //Do nothing. This is now an obsolete call that only exists for call handling in older functions.
    }

    //The uint256 signature parameter is no longer used inside the function, but is needed for legacy call handling
    function increaseRewards(uint256 _obsolete, address _user) external
    {
        if(correctionMapping[_user] > 0)
        {
            //IncreaseRewards is called at the end of the updateRewardOnMint call and thus is the perfect place to remove the correction mapping
            //data after it has been utilized
            delete correctionMapping[_user];
        }
    }
    function getEnd() external returns(uint256)
    {
        return citizenContract.getEnd();
    }
    
    constructor() Ownable() {
        setCitizenContract(0xb668beB1Fa440F6cF2Da0399f8C28caB993Bdd65);
        setBytesContract(0x7d647b1A0dcD5525e9C6B3D14BE58f27674f8c95);
    }
}