{{
  "language": "Solidity",
  "sources": {
    "solidity/contracts/system/KeepFactorySelection.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {IBondedECDSAKeepFactory} from \"@keep-network/keep-ecdsa/contracts/api/IBondedECDSAKeepFactory.sol\";\n\n/// @title Bonded ECDSA keep factory selection strategy.\n/// @notice The strategy defines the algorithm for selecting a factory. tBTC\n/// uses two bonded ECDSA keep factories, selecting one of them for each new\n/// deposit being opened.\ninterface KeepFactorySelector {\n\n    /// @notice Selects keep factory for the new deposit.\n    /// @param _seed Request seed.\n    /// @param _keepStakedFactory Regular, KEEP-stake based keep factory.\n    /// @param _fullyBackedFactory Fully backed, ETH-bond-only based keep factory.\n    /// @return The selected keep factory.\n    function selectFactory(\n        uint256 _seed,\n        IBondedECDSAKeepFactory _keepStakedFactory,\n        IBondedECDSAKeepFactory _fullyBackedFactory\n    ) external view returns (IBondedECDSAKeepFactory);\n}\n\n/// @title Bonded ECDSA keep factory selection library.\n/// @notice tBTC uses two bonded ECDSA keep factories: one based on KEEP stake\n/// and ETH bond, and another based only on ETH bond. The library holds\n/// a reference to both factories as well as a reference to a selection strategy\n/// deciding which factory to choose for the new deposit being opened.\nlibrary KeepFactorySelection {\n\n    struct Storage {\n        uint256 requestCounter;\n\n        IBondedECDSAKeepFactory selectedFactory;\n\n        KeepFactorySelector factorySelector;\n\n        // Standard ECDSA keep factory: KEEP stake and ETH bond.\n        // Guaranteed to be set for initialized factory.\n        IBondedECDSAKeepFactory keepStakedFactory;\n\n        // Fully backed ECDSA keep factory: ETH bond only.\n        IBondedECDSAKeepFactory fullyBackedFactory;\n    }\n\n    /// @notice Initializes the library with the default KEEP-stake-based\n    /// factory. The default factory is guaranteed to be set and this function\n    /// must be called when creating contract using this library.\n    /// @dev This function can be called only one time.\n    function initialize(\n        Storage storage _self,\n        IBondedECDSAKeepFactory _defaultFactory\n    ) public {\n        require(\n            address(_self.keepStakedFactory) == address(0),\n            \"Already initialized\"\n        );\n\n        _self.keepStakedFactory = IBondedECDSAKeepFactory(_defaultFactory);\n        _self.selectedFactory = _self.keepStakedFactory;\n    }\n\n    /// @notice Returns the selected keep factory.\n    /// This function guarantees that the same factory is returned for every\n    /// call until selectFactoryAndRefresh is executed. This lets to evaluate\n    /// open keep fee estimate on the same factory that will be used later for\n    /// opening a new keep (fee estimate and open keep requests are two\n    /// separate calls).\n    /// @return Selected keep factory. The same vale will be returned for every\n    /// call of this function until selectFactoryAndRefresh is executed.\n    function selectFactory(\n        Storage storage _self\n    ) public view returns (IBondedECDSAKeepFactory) {\n        return _self.selectedFactory;\n    }\n\n    /// @notice Returns the selected keep factory and refreshes the choice\n    /// for the next select call. The value returned by this function has been\n    /// evaluated during the previous call. This lets to return the same value\n    /// from selectFactory and selectFactoryAndRefresh, thus, allowing to use\n    /// the same factory for which open keep fee estimate was evaluated (fee\n    /// estimate and open keep requests are two separate calls).\n    /// @return Selected keep factory.\n    function selectFactoryAndRefresh(\n        Storage storage _self\n    ) external returns (IBondedECDSAKeepFactory) {\n        IBondedECDSAKeepFactory factory = selectFactory(_self);\n        refreshFactory(_self);\n\n        return factory;\n    }\n\n    /// @notice Sets the minimum bondable value required from the operator to\n    /// join the sortition pool for tBTC.\n    /// @param _minimumBondableValue The minimum bond value the application\n    /// requires from a single keep.\n    /// @param _groupSize Number of signers in the keep.\n    /// @param _honestThreshold Minimum number of honest keep signers.\n    function setMinimumBondableValue(\n        Storage storage _self,\n        uint256 _minimumBondableValue,\n        uint256 _groupSize,\n        uint256 _honestThreshold\n    ) external {\n        if (address(_self.keepStakedFactory) != address(0)) {\n            _self.keepStakedFactory.setMinimumBondableValue(\n                _minimumBondableValue,\n                _groupSize,\n                _honestThreshold\n            );\n        }\n        if (address(_self.fullyBackedFactory) != address(0)) {\n            _self.fullyBackedFactory.setMinimumBondableValue(\n                _minimumBondableValue,\n                _groupSize,\n                _honestThreshold\n            );\n        }\n    }\n\n    /// @notice Refreshes the keep factory choice. If either ETH-bond-only factory\n    /// or selection strategy is not set, KEEP-stake factory is selected.\n    /// Otherwise, calls selection strategy providing addresses of both\n    /// factories to make a choice. Additionally, passes the selection seed\n    /// evaluated from the current request counter value.\n    function refreshFactory(Storage storage _self) internal {\n        if (\n            address(_self.fullyBackedFactory) == address(0) ||\n            address(_self.factorySelector) == address(0)\n        ) {\n            // KEEP-stake factory is guaranteed to be there. If the selection\n            // can not be performed, this is the default choice.\n            _self.selectedFactory = _self.keepStakedFactory;\n            return;\n        }\n\n        _self.requestCounter++;\n        uint256 seed = uint256(\n            keccak256(abi.encodePacked(address(this), _self.requestCounter))\n        );\n        _self.selectedFactory = _self.factorySelector.selectFactory(\n            seed,\n            _self.keepStakedFactory,\n            _self.fullyBackedFactory\n        );\n\n        require(\n            _self.selectedFactory == _self.keepStakedFactory ||\n                _self.selectedFactory == _self.fullyBackedFactory,\n            \"Factory selector returned unknown factory\"\n        );\n    }\n\n    /// @notice Sets addresses of the keep factories and the selection strategy\n    /// contracts.\n    /// KeepFactorySelection can work without the keep factory selection\n    /// strategy set, always selecting the default KEEP-stake-based factory.\n    /// Once both fully-backed keep factory and factory selection strategy are\n    /// set, KEEP-stake-based factory is no longer the default choice and it is\n    /// up to the selection strategy to decide which factory should be chosen.\n    /// @dev Can be called multiple times! It's responsibility of a contract\n    /// using this library to limit and protect updates.\n    /// @param _keepStakedFactory Address of the regular, KEEP-stake based keep\n    /// factory.\n    /// @param _fullyBackedFactory Address of the fully-backed, ETH-bond-only based\n    /// keep factory.\n    /// @param _factorySelector Address of the keep factory selection strategy.\n    function setFactories(\n        Storage storage _self,\n        address _keepStakedFactory,\n        address _fullyBackedFactory,\n        address _factorySelector\n    ) internal {\n        require(\n            address(_keepStakedFactory) != address(0),\n            \"Invalid KEEP-staked factory address\"\n        );\n\n        _self.keepStakedFactory = IBondedECDSAKeepFactory(_keepStakedFactory);\n        _self.fullyBackedFactory = IBondedECDSAKeepFactory(_fullyBackedFactory);\n        _self.factorySelector = KeepFactorySelector(_factorySelector);\n    }\n}\n"
    },
    "@keep-network/keep-ecdsa/contracts/api/IBondedECDSAKeepFactory.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\n/// @title Bonded ECDSA Keep Factory\n/// @notice Factory for Bonded ECDSA Keeps.\ninterface IBondedECDSAKeepFactory {\n    /// @notice Open a new ECDSA Keep.\n    /// @param _groupSize Number of members in the keep.\n    /// @param _honestThreshold Minimum number of honest keep members.\n    /// @param _owner Address of the keep owner.\n    /// @param _bond Value of ETH bond required from the keep.\n    /// @param _stakeLockDuration Stake lock duration in seconds.\n    /// @return Address of the opened keep.\n    function openKeep(\n        uint256 _groupSize,\n        uint256 _honestThreshold,\n        address _owner,\n        uint256 _bond,\n        uint256 _stakeLockDuration\n    ) external payable returns (address keepAddress);\n\n    /// @notice Gets a fee estimate for opening a new keep.\n    /// @return Uint256 estimate.\n    function openKeepFeeEstimate() external view returns (uint256);\n\n    /// @notice Gets the total weight of operators\n    /// in the sortition pool for the given application.\n    /// @param _application Address of the application.\n    /// @return The sum of all registered operators' weights in the pool.\n    /// Reverts if sortition pool for the application does not exist.\n    function getSortitionPoolWeight(\n        address _application\n    ) external view returns (uint256);\n\n    /// @notice Sets the minimum bondable value required from the operator to\n    /// join the sortition pool of the given application. It is up to the\n    /// application to specify a reasonable minimum bond for operators trying to\n    /// join the pool to prevent griefing by operators joining without enough\n    /// bondable value.\n    /// @dev The default minimum bond value for each sortition pool created\n    /// is 20 ETH.\n    /// @param _minimumBondableValue The minimum unbonded value the application\n    /// requires from a single keep.\n    /// @param _groupSize Number of signers in the keep.\n    /// @param _honestThreshold Minimum number of honest keep signers.\n    function setMinimumBondableValue(\n        uint256 _minimumBondableValue,\n        uint256 _groupSize,\n        uint256 _honestThreshold\n    ) external;\n}\n"
    },
    "@keep-network/keep-ecdsa/contracts/api/IBondedECDSAKeep.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\n/// @title ECDSA Keep\n/// @notice Contract reflecting an ECDSA keep.\ncontract IBondedECDSAKeep {\n    /// @notice Returns public key of this keep.\n    /// @return Keeps's public key.\n    function getPublicKey() external view returns (bytes memory);\n\n    /// @notice Returns the amount of the keep's ETH bond in wei.\n    /// @return The amount of the keep's ETH bond in wei.\n    function checkBondAmount() external view returns (uint256);\n\n    /// @notice Calculates a signature over provided digest by the keep. Note that\n    /// signatures from the keep not explicitly requested by calling `sign`\n    /// will be provable as fraud via `submitSignatureFraud`.\n    /// @param _digest Digest to be signed.\n    function sign(bytes32 _digest) external;\n\n    /// @notice Distributes ETH reward evenly across keep signer beneficiaries.\n    /// @dev Only the value passed to this function is distributed.\n    function distributeETHReward() external payable;\n\n    /// @notice Distributes ERC20 reward evenly across keep signer beneficiaries.\n    /// @dev This works with any ERC20 token that implements a transferFrom\n    /// function.\n    /// This function only has authority over pre-approved\n    /// token amount. We don't explicitly check for allowance, SafeMath\n    /// subtraction overflow is enough protection.\n    /// @param _tokenAddress Address of the ERC20 token to distribute.\n    /// @param _value Amount of ERC20 token to distribute.\n    function distributeERC20Reward(address _tokenAddress, uint256 _value)\n        external;\n\n    /// @notice Seizes the signers' ETH bonds. After seizing bonds keep is\n    /// terminated so it will no longer respond to signing requests. Bonds can\n    /// be seized only when there is no signing in progress or requested signing\n    /// process has timed out. This function seizes all of signers' bonds.\n    /// The application may decide to return part of bonds later after they are\n    /// processed using returnPartialSignerBonds function.\n    function seizeSignerBonds() external;\n\n    /// @notice Returns partial signer's ETH bonds to the pool as an unbounded\n    /// value. This function is called after bonds have been seized and processed\n    /// by the privileged application after calling seizeSignerBonds function.\n    /// It is entirely up to the application if a part of signers' bonds is\n    /// returned. The application may decide for that but may also decide to\n    /// seize bonds and do not return anything.\n    function returnPartialSignerBonds() external payable;\n\n    /// @notice Submits a fraud proof for a valid signature from this keep that was\n    /// not first approved via a call to sign.\n    /// @dev The function expects the signed digest to be calculated as a sha256\n    /// hash of the preimage: `sha256(_preimage)`.\n    /// @param _v Signature's header byte: `27 + recoveryID`.\n    /// @param _r R part of ECDSA signature.\n    /// @param _s S part of ECDSA signature.\n    /// @param _signedDigest Digest for the provided signature. Result of hashing\n    /// the preimage.\n    /// @param _preimage Preimage of the hashed message.\n    /// @return True if fraud, error otherwise.\n    function submitSignatureFraud(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    )\n        external returns (bool _isFraud);\n\n    /// @notice Closes keep when no longer needed. Releases bonds to the keep\n    /// members. Keep can be closed only when there is no signing in progress or\n    /// requested signing process has timed out.\n    /// @dev The function can be called only by the owner of the keep and only\n    /// if the keep has not been already closed.\n    function closeKeep() external;\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}