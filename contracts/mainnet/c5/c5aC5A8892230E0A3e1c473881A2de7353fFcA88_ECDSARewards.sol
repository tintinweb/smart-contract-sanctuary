{{
  "language": "Solidity",
  "sources": {
    "solidity/contracts/ECDSARewards.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓▌        ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"@keep-network/keep-core/contracts/Rewards.sol\";\nimport \"./BondedECDSAKeepFactory.sol\";\nimport \"./BondedECDSAKeep.sol\";\n\n/// @title KEEP ECDSA Signer Subsidy Rewards for the Sep 2020 release.\n/// @notice Contract distributes KEEP rewards to signers that were part of\n/// the keeps which were created by the BondedECDSAKeepFactory contract.\n///\n/// The amount of KEEP to be distributed is determined by funding the contract,\n/// and additional KEEP can be added at any time.\n///\n/// When an interval is over, it will be allocated a percentage of the remaining\n/// unallocated rewards based on its weight, and adjusted by the number of keeps\n/// created in the interval if the quota is not met.\n///\n/// The adjustment for not meeting the keep quota is a percentage that equals\n/// the percentage of the quota that was met; if the number of keeps created is\n/// 80% of the quota then 80% of the base reward will be allocated for the\n/// interval.\n///\n/// Any unallocated rewards will stay in the unallocated rewards pool,\n/// to be allocated for future intervals. Intervals past the initially defined\n/// schedule have a weight of the last scheduled interval.\n///\n/// Keeps can receive rewards once the interval they were created in is over,\n/// and the keep has been marked as closed.\n/// There is no time limit to receiving rewards, nor is there need to wait for\n/// all keeps from the interval to be marked as closed.\n/// Calling `receiveReward` automatically allocates the rewards for the interval\n/// the specified keep was created in and all previous intervals.\n///\n/// If a keep is terminated, that fact can be reported to the reward contract.\n/// Reporting a terminated keep returns its allocated reward to the pool of\n/// unallocated rewards.\ncontract ECDSARewards is Rewards {\n    // The amount of tokens each individual beneficiary address\n    // can receive in a single interval is capped to 3M tokens.\n    uint256 public beneficiaryRewardCap = 3000000 * 10**18;\n\n    // BondedECDSAKeepFactory deployment date, Sep-14-2020 interval started.\n    // https://etherscan.io/address/0xA7d9E842EFB252389d613dA88EDa3731512e40bD\n    uint256 internal constant ecdsaFirstIntervalStart = 1600041600;\n\n    /// Weights of the 24 reward intervals assigned over\n    // 24 * termLength days.\n    uint256[] internal intervalWeights = [\n        4,\n        8,\n        10,\n        12,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15,\n        15\n    ];\n\n    // Each interval is 30 days long.\n    uint256 internal constant termLength = 30 days;\n\n    uint256 internal constant minimumECDSAKeepsPerInterval = 1000;\n\n    // The total amount of rewards allocated to the given beneficiary address,\n    // in the given interval.\n    // `allocatedRewards[beneficiary][interval] -> amount`\n    mapping(address => mapping(uint256 => uint256)) internal allocatedRewards;\n    // The amount of interval rewards withdrawn to the given beneficiary.\n    mapping(address => mapping(uint256 => uint256)) internal withdrawnRewards;\n\n    BondedECDSAKeepFactory internal factory;\n    TokenStaking internal tokenStaking;\n\n    constructor(\n        address _token,\n        address payable _factoryAddress,\n        address _tokenStakingAddress\n    )\n        public\n        Rewards(\n            _token,\n            ecdsaFirstIntervalStart,\n            intervalWeights,\n            termLength,\n            minimumECDSAKeepsPerInterval\n        )\n    {\n        factory = BondedECDSAKeepFactory(_factoryAddress);\n        tokenStaking = TokenStaking(_tokenStakingAddress);\n    }\n\n    /// @notice Get the amount of rewards allocated\n    /// for the specified operator's beneficiary in the specified interval.\n    /// @param interval The interval\n    /// @param operator The operator\n    /// @return The amount allocated\n    function getAllocatedRewards(uint256 interval, address operator)\n        external\n        view\n        returns (uint256)\n    {\n        address beneficiary = tokenStaking.beneficiaryOf(operator);\n        return allocatedRewards[beneficiary][interval];\n    }\n\n    /// @notice Get the amount of rewards already withdrawn\n    /// for the specified operator's beneficiary in the specified interval.\n    /// @param interval The interval\n    /// @param operator The operator\n    /// @return The amount already withdrawn\n    function getWithdrawnRewards(uint256 interval, address operator)\n        external\n        view\n        returns (uint256)\n    {\n        address beneficiary = tokenStaking.beneficiaryOf(operator);\n        return withdrawnRewards[beneficiary][interval];\n    }\n\n    /// @notice Get the amount of rewards withdrawable\n    /// for the specified operator's beneficiary in the specified interval.\n    /// @param interval The interval\n    /// @param operator The operator\n    /// @return The amount withdrawable\n    function getWithdrawableRewards(uint256 interval, address operator)\n        external\n        view\n        returns (uint256)\n    {\n        address beneficiary = tokenStaking.beneficiaryOf(operator);\n        uint256 allocated = allocatedRewards[beneficiary][interval];\n        uint256 withdrawn = withdrawnRewards[beneficiary][interval];\n        return allocated.sub(withdrawn);\n    }\n\n    /// @notice Withdraw all available rewards for the given interval.\n    /// The rewards will be paid to the beneficiary of the specified operator.\n    /// @param interval The interval\n    /// @param operator The operator\n    function withdrawRewards(uint256 interval, address operator) external {\n        address beneficiary = tokenStaking.beneficiaryOf(operator);\n\n        uint256 allocated = allocatedRewards[beneficiary][interval];\n        uint256 alreadyWithdrawn = withdrawnRewards[beneficiary][interval];\n\n        require(allocated > alreadyWithdrawn, \"No rewards to withdraw\");\n\n        uint256 withdrawableRewards = allocated.sub(alreadyWithdrawn);\n\n        withdrawnRewards[beneficiary][interval] = allocated;\n\n        token.safeTransfer(beneficiary, withdrawableRewards);\n    }\n\n    function _getKeepCount() internal view returns (uint256) {\n        return factory.getKeepCount();\n    }\n\n    function _getKeepAtIndex(uint256 i) internal view returns (bytes32) {\n        return fromAddress(factory.getKeepAtIndex(i));\n    }\n\n    function _getCreationTime(bytes32 _keep)\n        internal\n        view\n        isAddress(_keep)\n        returns (uint256)\n    {\n        return factory.getKeepOpenedTimestamp(toAddress(_keep));\n    }\n\n    function _isClosed(bytes32 _keep)\n        internal\n        view\n        isAddress(_keep)\n        returns (bool)\n    {\n        return BondedECDSAKeep(toAddress(_keep)).isClosed();\n    }\n\n    function _isTerminated(bytes32 _keep)\n        internal\n        view\n        isAddress(_keep)\n        returns (bool)\n    {\n        return BondedECDSAKeep(toAddress(_keep)).isTerminated();\n    }\n\n    // A keep is recognized if it was opened by this factory.\n    function _recognizedByFactory(bytes32 _keep)\n        internal\n        view\n        isAddress(_keep)\n        returns (bool)\n    {\n        return factory.getKeepOpenedTimestamp(toAddress(_keep)) != 0;\n    }\n\n    /// @notice Get the members of the specified keep, and distribute the reward\n    /// amount between them. The reward isn't paid out immediately,\n    /// but is instead kept in the reward contract until each operator\n    /// individually requests to withdraw the rewards.\n    function _distributeReward(bytes32 _keep, uint256 amount)\n        internal\n        isAddress(_keep)\n    {\n        address[] memory members = BondedECDSAKeep(toAddress(_keep))\n            .getMembers();\n        uint256 interval = intervalOf(_getCreationTime(_keep));\n\n        uint256 memberCount = members.length;\n        uint256 dividend = amount.div(memberCount);\n        uint256 remainder = amount.mod(memberCount);\n\n        uint256[] memory allocations = new uint256[](memberCount);\n\n        for (uint256 i = 0; i < memberCount - 1; i++) {\n            allocations[i] = dividend;\n        }\n        allocations[memberCount - 1] = dividend.add(remainder);\n\n        for (uint256 i = 0; i < memberCount; i++) {\n            address beneficiary = tokenStaking.beneficiaryOf(members[i]);\n            uint256 addedAllocation = allocations[i];\n            uint256 prevAllocated = allocatedRewards[beneficiary][interval];\n            uint256 newAllocation = prevAllocated.add(addedAllocation);\n            if (newAllocation > beneficiaryRewardCap) {\n                uint256 deallocatedAmount = newAllocation.sub(\n                    beneficiaryRewardCap\n                );\n                newAllocation = beneficiaryRewardCap;\n                deallocate(deallocatedAmount);\n            }\n            allocatedRewards[beneficiary][interval] = newAllocation;\n        }\n    }\n\n    function toAddress(bytes32 keepBytes) internal pure returns (address) {\n        return address(bytes20(keepBytes));\n    }\n\n    function fromAddress(address keepAddress) internal pure returns (bytes32) {\n        return bytes32(bytes20(keepAddress));\n    }\n\n    function validAddressBytes(bytes32 keepBytes) internal pure returns (bool) {\n        return fromAddress(toAddress(keepBytes)) == keepBytes;\n    }\n\n    modifier isAddress(bytes32 _keep) {\n        require(validAddressBytes(_keep), \"Invalid keep address\");\n        _;\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/Rewards.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity ^0.5.17;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\n\nimport \"./KeepToken.sol\";\n\n/// @title KEEP Signer Subsidy Rewards\n/// @notice A contract for distributing KEEP token rewards to keeps.\n/// When a reward contract is created, the creator defines a reward schedule\n/// consisting of one or more reward intervals and their interval weights,\n/// the length of reward intervals, and the quota of how many keeps must be\n/// created in an interval for the full reward for that interval to be paid out.\n///\n/// The amount of KEEP to be distributed is determined by funding the contract,\n/// and additional KEEP can be added at any time.\n/// The reward contract is funded with `approveAndCall` with no extra data,\n/// but it also collects any KEEP mistakenly sent to it in any other way.\n///\n/// An interval is defined by the timestamps [startOf, endOf);\n/// a keep created at the time `startOf(i)` belongs to interval `i`\n/// and one created at `endOf(i)` belongs to `i+1`.\n///\n/// When an interval is over, it will be allocated a percentage of the remaining\n/// unallocated rewards based on its weight, and adjusted by the number of keeps\n/// created in the interval if the quota is not met.\n///\n/// The adjustment for not meeting the keep quota is a percentage that equals\n/// the percentage of the quota that was met; if the number of keeps created is\n/// 80% of the quota then 80% of the base reward will be allocated for the\n/// interval.\n///\n/// Any unallocated rewards will stay in the unallocated rewards pool,\n/// to be allocated for future intervals. Intervals past the initially defined\n/// schedule have a weight of 100%, meaning that all remaining unallocated\n/// rewards will be allocated to the interval.\n///\n/// Keeps of the appropriate type can receive rewards once the interval they\n/// were created in is over, and the keep has closed happily.\n/// There is no time limit to receiving rewards, nor is there need to wait for\n/// all keeps from the interval to close.\n/// Calling `receiveReward` automatically allocates the rewards for the interval\n/// the specified keep was created in and all previous intervals.\n///\n/// If a keep is terminated, that fact can be reported to the reward contract.\n/// Reporting a terminated keep returns its allocated reward to the pool of\n/// unallocated rewards.\n///\n/// @dev A concrete implementation of the abstract rewards contract must specify\n/// functions for accessing information about keeps and paying out rewards.\n/// For the purpose of rewards, Random Beacon signing groups count as \"keeps\"\n/// and the beacon operator contract acts as the \"factory\".\ncontract Rewards is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for KeepToken;\n\n    KeepToken public token;\n\n    // Array representing the percentage of unallocated rewards\n    // available for each reward interval.\n    uint256[] public intervalWeights; // percent array\n    // Length of one interval in seconds (timestamp diff).\n    uint256 public termLength;\n    // The number of keeps required in an interval\n    // for the full reward to be allocated to the interval.\n    uint256 public minimumKeepsPerInterval;\n\n    // Total number of KEEP tokens to distribute by this contract.\n    // Includes those already dispensed.\n    uint256 public totalRewards;\n    // Rewards that haven't been allocated to finished intervals.\n    uint256 public unallocatedRewards;\n    // Rewards that have been dispensed from this contract as signer rewards.\n    // `token.balanceOf(address(this))` should always equal\n    // `totalRewards.sub(dispensedRewards)`\n    uint256 public dispensedRewards;\n    // The following invariant should always hold:\n    // token.balanceOf(address(this)) >= totalRewards.sub(dispensedRewards)\n\n    // Timestamp of first interval beginning.\n    // Interval 0 covers everything before `firstIntervalStart`\n    // and the first `termLength` after `firstIntervalStart`.\n    uint256 public firstIntervalStart;\n    // Mapping of interval number to tokens allocated for the interval.\n    uint256[] internal intervalAllocations;\n\n    // mapping of keeps to booleans.\n    // True if the keep has been used to claim a reward.\n    mapping(bytes32 => bool) internal claimed;\n    // Mapping of interval to number of keeps created in/before the interval\n    mapping(uint256 => uint256) internal keepsByInterval;\n    // Mapping of interval to number of keeps whose rewards have been paid out,\n    // or reallocated because the keep closed unhappily\n    mapping(uint256 => uint256) public intervalKeepsProcessed;\n\n    // Indicates whether the contract has been properly funded. Rewards can not\n    // be allocated before the first funding and the owner of the\n    // contract is responsible for marking it as already funded. Further funding\n    // of the contract is possible with no owner's intervention.\n    bool public funded = false;\n\n    // Owner of the contract may initiate an upgrade to a new rewards contract\n    // but the pending and past intervals must have their rewards allocated\n    // before any KEEP tokens are transferred out from this contract.\n    uint256 public upgradeInitiatedTimestamp;\n    uint256 public upgradeFinalizedTimestamp;\n    address public newRewardsContract;\n\n    event RewardReceived(bytes32 keep, uint256 amount);\n    event UpgradeInitiated(address newRewardsContract);\n    event UpgradeFinalized(uint256 amountTransferred);\n\n    constructor (\n        address _token,\n        uint256 _firstIntervalStart,\n        uint256[] memory _intervalWeights,\n        uint256 _termLength,\n        uint256 _minimumKeepsPerInterval\n    ) public {\n        token = KeepToken(_token);\n        firstIntervalStart = _firstIntervalStart;\n        intervalWeights = _intervalWeights;\n        termLength = _termLength;\n        minimumKeepsPerInterval = _minimumKeepsPerInterval;\n    }\n\n    /// @notice Funds the rewards contract.\n    /// @dev Adds the received amount of tokens to `totalRewards` and\n    /// `unallocatedRewards`. May be called at any time, even after allocating\n    /// some intervals.\n    /// If the contract has been upgraded,\n    /// the funding will be transferred to the new contract instead.\n    /// Changes to `unallocatedRewards` will take effect on subsequent interval\n    /// allocations. Intended to be used with `approveAndCall`.\n    /// If the reward contract has received tokens outside `approveAndCall`,\n    /// this collects them as well.\n    /// The following invariant should hold right after calling this function:\n    /// token.balanceOf(address(this)) == totalRewards.sub(dispensedRewards).\n    /// @param _from The original sender of the tokens.\n    /// Must have approved at least `_value` tokens for the rewards contract.\n    /// @param _value The amount of tokens to fund.\n    /// @param _token The token to fund the rewards in.\n    /// Must match the one specified in the rewards contract.\n    function receiveApproval(\n        address _from,\n        uint256 _value,\n        address _token,\n        bytes memory\n    ) public {\n        require(IERC20(_token) == token, \"Unsupported token\");\n\n        token.safeTransferFrom(_from, address(this), _value);\n\n        uint256 currentBalance = token.balanceOf(address(this));\n        uint256 beforeBalance = totalRewards.sub(dispensedRewards);\n        require(\n            currentBalance >= beforeBalance,\n            \"Reward contract has lost tokens\"\n        );\n\n        uint256 addedBalance = currentBalance.sub(beforeBalance);\n\n        totalRewards = totalRewards.add(addedBalance);\n        deallocate(addedBalance);\n    }\n\n    function markAsFunded() public onlyOwner {\n        funded = true;\n    }\n\n    /// @notice Stakers can receive KEEP rewards from multiple keeps of their choice\n    /// in one transaction to reduce total cost comparing to single calls for rewards.\n    /// It is a caller responsibility to determine the cost and consumed gas when\n    /// receiving rewards from multiple keeps.\n    /// @param keepIdentifiers An array of keep identifiers.\n    function receiveRewards(bytes32[] memory keepIdentifiers) public {\n        for (uint256 i = 0; i < keepIdentifiers.length; i++) {\n            receiveReward(keepIdentifiers[i]);\n        }\n    }\n\n    /// @notice Sends the reward for a keep to the keep members.\n    /// @param keepIdentifier A unique identifier for the keep,\n    /// e.g. address or number converted to a `bytes32`.\n    function receiveReward(bytes32 keepIdentifier)\n        factoryMustRecognize(keepIdentifier)\n        rewardsNotClaimed(keepIdentifier)\n        mustBeClosed(keepIdentifier)\n        public\n    {\n        _processKeep(true, keepIdentifier);\n    }\n\n    /// @notice Report about the terminated keeps in batch. All the allocated\n    /// rewards in these keeps will be returned to the unallocated pool.\n    /// @param keepIdentifiers An array of keep identifiers.\n    function reportTerminations(bytes32[] memory keepIdentifiers) public {\n        for (uint256 i = 0; i < keepIdentifiers.length; i++) {\n            reportTermination(keepIdentifiers[i]);\n        }\n    }\n\n    /// @notice Report that the keep was terminated, and return its allocated\n    /// rewards to the unallocated pool.\n    /// @param keepIdentifier The terminated keep.\n    function reportTermination(bytes32 keepIdentifier)\n        factoryMustRecognize(keepIdentifier)\n        rewardsNotClaimed(keepIdentifier)\n        mustBeTerminated(keepIdentifier)\n        public\n    {\n        _processKeep(false, keepIdentifier);\n    }\n\n    /// @notice Checks if a keep is eligible to receive rewards.\n    /// @dev Keeps that close dishonorably or early are not eligible for rewards.\n    /// @param _keep The keep to check.\n    /// @return True if the keep is eligible, false otherwise\n    function eligibleForReward(bytes32 _keep) public view returns (bool){\n        return _recognizedByFactory(_keep) && _isClosed(_keep) && !rewardClaimed(_keep);\n    }\n\n    /// @notice Checks if a keep is terminated and thus its rewards can be\n    /// returned to the unallocated pool.\n    /// @param _keep The keep to check.\n    /// @return True if the keep is terminated, false otherwise\n    function eligibleButTerminated(bytes32 _keep) public view returns (bool) {\n        return _recognizedByFactory(_keep) && _isTerminated(_keep);\n    }\n\n    /// @notice Return the interval number the provided timestamp falls within.\n    /// @dev If the timestamp is before `firstIntervalStart`, the interval is 0.\n    /// @param timestamp The timestamp whose interval is queried.\n    /// @return The interval of the timestamp.\n    function intervalOf(uint256 timestamp) public view returns (uint256) {\n        uint256 _firstIntervalStart = firstIntervalStart;\n        uint256 _termLength = termLength;\n\n        if (timestamp < _firstIntervalStart) {\n            return 0;\n        }\n\n        uint256 difference = timestamp.sub(_firstIntervalStart);\n        uint256 interval = difference.div(_termLength);\n\n        return interval;\n    }\n\n    /// @notice Return the timestamp corresponding to the start of the interval.\n    /// @dev The start of an interval is inclusive;\n    /// a keep created at the timestamp `startOf(i)` is in interval `i`.\n    /// @param interval The interval whose start is queried.\n    /// @return The start timestamp of the interval.\n    function startOf(uint256 interval) public view returns (uint256) {\n        return firstIntervalStart.add(interval.mul(termLength));\n    }\n\n    /// @notice Return the timestamp corresponding to the end of the interval.\n    /// @dev The end of an interval is exclusive;\n    /// a keep created at the timestamp `endOf(i)` is in interval `i+1`.\n    /// @param interval The interval whose end is queried.\n    /// @return The end timestamp of the interval.\n    function endOf(uint256 interval) public view returns (uint256) {\n        return startOf(interval.add(1));\n    }\n\n    /// @notice Return whether the given interval is finished.\n    /// @param interval The interval.\n    /// @return Whether the interval is finished.\n    function isFinished(uint256 interval) public view returns (bool) {\n        return block.timestamp >= endOf(interval);\n    }\n\n    /// @notice Return whether the given keep has already claimed rewards\n    /// or had its rewards reallocated due to termination.\n    /// @param _keep The identifier of the keep.\n    /// @return True if rewards have been paid out for the keep,\n    /// or its termination has been reported.\n    /// False otherwise.\n    function rewardClaimed(bytes32 _keep) public view returns (bool) {\n        return claimed[_keep];\n    }\n\n    /// @notice Return the number of keeps created before `intervalEndpoint`\n    /// @dev Wraps the binary search of `_find`\n    /// with a number of checks for edge cases.\n    function _findEndpoint(uint256 intervalEndpoint) internal view returns (uint256) {\n        require(\n            intervalEndpoint <= block.timestamp,\n            \"interval hasn't ended yet\"\n        );\n        uint256 keepCount = _getKeepCount();\n        // no keeps created yet -> return 0\n        if (keepCount == 0) {\n            return 0;\n        }\n\n        uint256 lb = 0; // lower bound, inclusive\n        uint256 timestampLB = _getCreationTime(_getKeepAtIndex(lb));\n        // all keeps created after the interval -> return 0\n        if (timestampLB >= intervalEndpoint) {\n            return 0;\n        }\n\n        uint256 ub = keepCount.sub(1); // upper bound, inclusive\n        uint256 timestampUB = _getCreationTime(_getKeepAtIndex(ub));\n        // all keeps created in or before the interval -> return keep count\n        if (timestampUB < intervalEndpoint) {\n            return keepCount;\n        }\n\n        // The above cases also cover the case\n        // where only 1 keep has been created;\n        // lb == ub\n        // if it was created after the interval, return 0\n        // otherwise, return 1\n\n        return _find(lb, timestampLB, ub, timestampUB, intervalEndpoint);\n    }\n\n    /// @notice Return the number of keeps created before `targetTime`,\n    /// with specified upper and lower bounds.\n    /// @dev Binary search assumes the following invariants:\n    ///   lower bound >= 0, lbTime < targetTime\n    ///   upper bound < keepCount, ubTime >= targetTime\n    /// @param _lb The lower bound of the search (inclusive)\n    /// @param _lbTime The creation time of keep number `lb`\n    /// @param _ub The upper bound of the search (inclusive)\n    /// @param _ubTime The creation time of keep number `ub`\n    /// @param targetTime The target time\n    function _find(\n        uint256 _lb,\n        uint256 _lbTime,\n        uint256 _ub,\n        uint256 _ubTime,\n        uint256 targetTime\n    ) internal view returns (uint256) {\n        uint256 lb = _lb;\n        uint256 lbTime = _lbTime;\n        uint256 ub = _ub;\n        uint256 ubTime = _ubTime;\n        uint256 len = ub.sub(lb);\n        while (len > 1) {\n            // upper bound >= lower bound + 2\n            // mid > lower bound\n            uint256 mid = lb.add(len.div(2));\n            uint256 midTime = _getCreationTime(_getKeepAtIndex(mid));\n\n            if (midTime >= targetTime) {\n                ub = mid;\n                ubTime = midTime;\n            } else {\n                lb = mid;\n                lbTime = midTime;\n            }\n            len = ub.sub(lb);\n        }\n        return ub;\n    }\n\n    /// @notice Return the endpoint index of the interval,\n    /// i.e. the number of keeps created in and before the interval.\n    /// The interval must have ended; otherwise the endpoint might still change.\n    /// @dev Uses a locally cached result, and stores the result if it isn't\n    /// cached yet. All keeps created before the initiation fall in interval 0.\n    /// @param interval The number of the interval.\n    /// @return endpoint The number of keeps the factory had created\n    /// before the end of the interval.\n    function _getEndpoint(uint256 interval)\n        mustBeFinished(interval)\n        internal\n        returns (uint256 endpoint)\n    {\n        // Get the endpoint from local cache;\n        // might not be recorded yet\n        uint256 maybeEndpoint = keepsByInterval[interval];\n\n        // Either the endpoint is zero\n        // (no keeps created by the end of the interval)\n        // or the endpoint isn't cached yet\n        if (maybeEndpoint == 0) {\n            // Check what the real endpoint is\n            // if the actual value is 0, this call short-circuits\n            // so we don't need to special-case the zero\n            uint256 realEndpoint = _findEndpoint(endOf(interval));\n            // We didn't have the correct value cached,\n            // so store it\n            if (realEndpoint != 0) {\n                keepsByInterval[interval] = realEndpoint;\n            }\n            endpoint = realEndpoint;\n        } else {\n            endpoint = maybeEndpoint;\n        }\n        return endpoint;\n    }\n\n    /// @notice Get the endpoint of the previous interval.\n    /// @dev Like _getEndpoint, gracefully handles the beginning of interval 0.\n    /// @param interval The interval.\n    /// @return The number of keeps created by the end of the preceding interval.\n    function _getPreviousEndpoint(uint256 interval) internal returns (uint256) {\n        if (interval == 0) {\n            return 0;\n        } else {\n            return _getEndpoint(interval.sub(1));\n        }\n    }\n\n    /// @notice Return the number of keeps created in the specified interval.\n    /// @param interval The interval.\n    /// @return Number of keeps created in the interval.\n    function keepsInInterval(uint256 interval) public returns (uint256) {\n        return (_getEndpoint(interval).sub(_getPreviousEndpoint(interval)));\n    }\n\n    /// @notice Return the percentage of remaining unallocated rewards\n    /// that is to be allocated to the specified interval.\n    /// @param interval The interval.\n    /// @return The percentage weight of the interval.\n    function getIntervalWeight(uint256 interval) public view returns (uint256) {\n        if (interval < intervalWeights.length) {\n            return intervalWeights[interval];\n        } else {\n            return intervalWeights[intervalWeights.length - 1];\n        }\n    }\n\n    /// @notice Get the number of intervals with explicitly specified weights.\n    /// All subsequent intervals will have an implicit weight of 100.\n    /// @return The number of explicitly specified intervals.\n    function getIntervalCount() public view returns (uint256) {\n        return intervalWeights.length;\n    }\n\n    /// @notice Calculate the reward allocation for an interval\n    /// without adjusting for the number of keeps in the interval.\n    /// @param interval The next interval to be allocated.\n    /// Results for other intervals will not be accurate.\n    /// @return The base reward allocation for the interval.\n    function _baseAllocation(uint256 interval) internal view returns (uint256) {\n        uint256 _unallocatedRewards = unallocatedRewards;\n        uint256 weightPercentage = getIntervalWeight(interval);\n        return _unallocatedRewards.mul(weightPercentage).div(100);\n    }\n\n    /// @notice Calculate the reward allocation for an interval\n    /// after adjusting for the number of keeps in the interval.\n    /// @dev An interval with at least `minimumKeepsPerInterval` keeps\n    /// will have the full reward allocated to it.\n    /// An interval with fewer keeps will only be allocated a fraction of the\n    /// base reward equaling the fraction of the quota that was met.\n    /// The reward allocated for each keep in the interval is constant\n    /// regardless of the number of keeps in the interval until the quota is\n    /// met, and further increases in the number of keeps will lead to the same\n    /// allocation being shared among more of them. Each keep in an interval is\n    /// allocated the same reward. If the number of keeps in an interval meets\n    /// the quota, but the base allocation isn't divisible by the number of\n    /// keeps, the remainder will remain unallocated.\n    /// Allocations for an already allocated interval, or when all prior\n    /// intervals haven't been allocated yet, will produce incorrect results.\n    /// @param interval The next interval to be allocated.\n    /// @return The amount of tokens to allocate as rewards for the interval.\n    function _adjustedAllocation(uint256 interval) internal returns (uint256) {\n        uint256 __baseAllocation = _baseAllocation(interval);\n        if (__baseAllocation == 0) {\n            return 0;\n        }\n        uint256 keepCount = keepsInInterval(interval);\n        uint256 adjustmentCount = Math.max(keepCount, minimumKeepsPerInterval);\n        if (adjustmentCount == 0) {\n            return 0;\n        }\n        // Rewards divide equally among keeps\n        return __baseAllocation.mul(keepCount).div(adjustmentCount);\n    }\n\n    /// @notice Allocate rewards for unallocated intervals up to and including\n    /// the given interval.\n    /// @dev The given interval must be finished and unallocated.\n    /// To allocate rewards correctly, any earlier intervals that are still\n    /// unallocated will be allocated before the given interval.\n    /// With reasonable interval lengths this should not pose a problem,\n    /// and if allocating a later interval results in an out-of-gas issue,\n    /// forcing the allocation of an earlier interval should fix it.\n    /// @param interval The interval to allocate.\n    function allocateRewards(uint256 interval)\n        mustBeFinished(interval)\n        mustBeFunded\n        public\n    {\n        uint256 allocatedIntervals = intervalAllocations.length;\n        require(\n            !(interval < allocatedIntervals),\n            \"Interval already allocated\"\n        );\n        // Allocate previous intervals first\n        if (interval > allocatedIntervals) {\n            allocateRewards(interval.sub(1));\n        }\n        uint256 totalAllocation = _adjustedAllocation(interval);\n        unallocatedRewards = unallocatedRewards.sub(totalAllocation);\n        intervalAllocations.push(totalAllocation);\n    }\n\n    /// @notice Get the total amount of tokens\n    /// allocated for all keeps in the specified interval.\n    /// @dev This function returns correct results for any allocated interval.\n    /// Dividing the allocated rewards by the number of keeps in the interval\n    /// will give the correct reward for a keep in the interval.\n    /// However, if a keep in the interval is terminated\n    /// its reward will be returned to the pool of unallocated tokens.\n    /// This will not be reflected in the return value of this function.\n    /// @param interval A previously allocated interval.\n    /// @return The total number of tokens allocated for keeps in the interval.\n    function getAllocatedRewards(uint256 interval) public view returns (uint256) {\n        require(\n            interval < intervalAllocations.length,\n            \"Interval not allocated yet\"\n        );\n        return intervalAllocations[interval];\n    }\n\n    /// @notice Return whether the specified interval has been allocated.\n    /// @param interval The interval.\n    /// @return Whether the interval has been allocated yet.\n    function isAllocated(uint256 interval) public view returns (bool) {\n        uint256 allocatedIntervals = intervalAllocations.length;\n        return (interval < allocatedIntervals);\n    }\n\n    /// @notice Process the rewards for the given keep, allocating finished\n    /// intervals as necessary, and then either paying out the rewards to the\n    /// keep's members or returning them to the unallocated pool, depending on\n    /// the keep's eligibility.\n    /// @param eligible Whether the keep is eligible for rewards or not.\n    /// @param keepIdentifier The specified keep.\n    function _processKeep(\n        bool eligible,\n        bytes32 keepIdentifier\n    ) internal {\n        uint256 creationTime = _getCreationTime(keepIdentifier);\n        uint256 interval = intervalOf(creationTime);\n        if (!isAllocated(interval)) {\n            allocateRewards(interval);\n        }\n        uint256 allocation = intervalAllocations[interval];\n        uint256 _keepsInInterval = keepsInInterval(interval);\n        uint256 perKeepReward = allocation.div(_keepsInInterval);\n        claimed[keepIdentifier] = true;\n        intervalKeepsProcessed[interval] = intervalKeepsProcessed[interval].add(1);\n\n        if (eligible) {\n            dispensedRewards = dispensedRewards.add(perKeepReward);\n            _distributeReward(keepIdentifier, perKeepReward);\n            emit RewardReceived(keepIdentifier, perKeepReward);\n        } else {\n            // Return the reward to the unallocated pool\n            deallocate(perKeepReward);\n        }\n    }\n\n    /// @notice Initiates the process of upgrading to another rewards contract.\n    /// @param _newRewardsContract The address of a new rewards contract.\n    function initiateRewardsUpgrade(address _newRewardsContract) public onlyOwner {\n        upgradeInitiatedTimestamp = block.timestamp;\n        newRewardsContract = _newRewardsContract;\n        emit UpgradeInitiated(newRewardsContract);\n    }\n\n    /// @notice Finalizes the process of upgrading to another rewards contract\n    /// by allocating all past intervals and then, transferring the\n    /// not-yet-allocated tokens to a new rewards contract.\n    /// Can be called only when the interval during which the upgrade was\n    /// initiated ended.\n    /// Before finalizing the upgrade, make sure all terminated groups are\n    /// reported.\n    function finalizeRewardsUpgrade() public onlyOwner {\n        require(upgradeInitiatedTimestamp != 0, \"Upgrade not initiated\");\n        \n        uint256 currentInterval = intervalOf(block.timestamp);\n        uint256 upgradeInitiatedInterval = intervalOf(upgradeInitiatedTimestamp);\n\n        require(\n            currentInterval > upgradeInitiatedInterval,\n            \"Interval at which the upgrade was initiated hasn't ended yet\"\n        );\n\n        // ensure all past intervals are allocated\n        if (!isAllocated(currentInterval.sub(1))) {\n            allocateRewards(currentInterval.sub(1));\n        }\n\n        // transfer the unallocated KEEP to the new rewards contract and update\n        // this contract's balances\n        uint256 amountToTransfer = unallocatedRewards;\n\n        totalRewards = totalRewards.sub(amountToTransfer);\n        unallocatedRewards = 0;\n\n        emit UpgradeFinalized(amountToTransfer);\n\n        bool success = token.approveAndCall(\n            newRewardsContract,\n            amountToTransfer,\n            bytes(\"\")\n        );\n        require(success, \"Upgrade finalization failed\");\n        \n\n        upgradeInitiatedTimestamp = 0;\n        upgradeFinalizedTimestamp = block.timestamp;\n    }\n\n    /// @notice Return the given amount to the unallocated pool.\n    /// If the contract has been upgraded,\n    /// the deallocated amount will be sent to the new contract.\n    /// @param amount The amount to deallocate\n    function deallocate(uint256 amount) internal {\n        if (upgradeFinalizedTimestamp != 0) {\n            bool success = token.approveAndCall(\n                newRewardsContract,\n                amount,\n                bytes(\"\")\n            );\n            if (!success) {\n                unallocatedRewards = unallocatedRewards.add(amount);\n            }\n        } else {\n            unallocatedRewards = unallocatedRewards.add(amount);\n        }\n    }\n\n    /// @notice Get the total number of keeps ever created by the factory,\n    /// including closed and terminated keeps.\n    /// @return The number of keeps.\n    function _getKeepCount() internal view returns (uint256);\n\n    /// @notice Get the identifier of the keep at the given index,\n    /// when all keeps created by the factory are ordered by creation time.\n    /// @param index The index of the queried keep.\n    /// @return The `bytes32` identifier of the keep at the given index.\n    /// @dev Implementation is not required to check if a keep with the given\n    /// index exists.\n    function _getKeepAtIndex(uint256 index) internal view returns (bytes32);\n\n    /// @notice Get the creation time of the given keep.\n    /// @param _keep The identifier of the keep.\n    /// @return The creation timestamp of the keep.\n    /// @dev If the idenfifier is invalid or not recognized by factory, function\n    /// may revert or return 0.\n    function _getCreationTime(bytes32 _keep) internal view returns (uint256);\n\n    /// @notice Is the given keep closed.\n    /// @param _keep The identifier of the keep.\n    /// @return True if the keep is closed, false otherwise.\n    /// If the identifier is invalid, may return false or an error.\n    function _isClosed(bytes32 _keep) internal view returns (bool);\n\n    /// @notice Is the given keep terminated.\n    /// @param _keep The identifier of the keep.\n    /// @return True if the keep is terminated, false otherwise.\n    /// If the identifier is invalid, may return false or an error.\n    function _isTerminated(bytes32 _keep) internal view returns (bool);\n\n    /// @notice Does the given `bytes32` identifier match a valid keep.\n    /// @param _keep A possible keep identifier.\n    /// @return True if the identifier matches a keep created by the factory.\n    /// For any other identifier, must return false and not an error.\n    function _recognizedByFactory(bytes32 _keep) internal view returns (bool);\n\n    /// @notice Pay the given amount of tokens to members of the keep.\n    /// @param _keep The keep whose members to reward.\n    /// @param amount The total amount of tokens to distribute to the members.\n    function _distributeReward(bytes32 _keep, uint256 amount) internal;\n\n    modifier rewardsNotClaimed(bytes32 _keep) {\n        require(\n            !rewardClaimed(_keep),\n            \"Rewards already claimed\");\n        _;\n    }\n\n    modifier mustBeFinished(uint256 interval) {\n        require(\n            isFinished(interval),\n            \"Interval hasn't ended yet\");\n        _;\n    }\n\n    modifier mustBeClosed(bytes32 _keep) {\n        require(\n            _isClosed(_keep),\n            \"Keep is not closed\");\n        _;\n    }\n\n    modifier mustBeTerminated(bytes32 _keep) {\n        require(\n            _isTerminated(_keep),\n            \"Keep is not terminated\");\n        _;\n    }\n\n    modifier factoryMustRecognize(bytes32 _keep) {\n        require(\n            _recognizedByFactory(_keep),\n            \"Keep not recognized by factory\");\n        _;\n    }\n\n    modifier mustBeFunded() {\n        require(funded, \"Contract has not been funded yet\");\n        _;\n    }\n}\n"
    },
    "solidity/contracts/AbstractBondedECDSAKeep.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"./api/IBondedECDSAKeep.sol\";\nimport \"./api/IBondingManagement.sol\";\n\nimport \"@keep-network/keep-core/contracts/utils/AddressArrayUtils.sol\";\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract AbstractBondedECDSAKeep is IBondedECDSAKeep {\n    using AddressArrayUtils for address[];\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // Status of the keep.\n    // Active means the keep is active.\n    // Closed means the keep was closed happily.\n    // Terminated means the keep was closed due to misbehavior.\n    enum Status {Active, Closed, Terminated}\n\n    // Address of the keep's owner.\n    address public owner;\n\n    // List of keep members' addresses.\n    address[] public members;\n\n    // Minimum number of honest keep members required to produce a signature.\n    uint256 public honestThreshold;\n\n    // Keep's ECDSA public key serialized to 64-bytes, where X and Y coordinates\n    // are padded with zeros to 32-byte each.\n    bytes public publicKey;\n\n    // Latest digest requested to be signed. Used to validate submitted signature.\n    bytes32 public digest;\n\n    // Map of all digests requested to be signed. Used to validate submitted\n    // signature. Holds the block number at which the signature over the given\n    // digest was requested\n    mapping(bytes32 => uint256) public digests;\n\n    // The timestamp at which keep has been created and key generation process\n    // started.\n    uint256 internal keyGenerationStartTimestamp;\n\n    // The timestamp at which signing process started. Used also to track if\n    // signing is in progress. When set to `0` indicates there is no\n    // signing process in progress.\n    uint256 internal signingStartTimestamp;\n\n    // Map stores public key by member addresses. All members should submit the\n    // same public key.\n    mapping(address => bytes) internal submittedPublicKeys;\n\n    // Map stores amount of wei stored in the contract for each member address.\n    mapping(address => uint256) internal memberETHBalances;\n\n    // Map stores preimages that have been proven to be fraudulent. This is needed\n    // to prevent from slashing members multiple times for the same fraudulent\n    // preimage.\n    mapping(bytes => bool) internal fraudulentPreimages;\n\n    // The current status of the keep.\n    // If the keep is Active members monitor it and support requests from the\n    // keep owner.\n    // If the owner decides to close the keep the flag is set to Closed.\n    // If the owner seizes member bonds the flag is set to Terminated.\n    Status internal status;\n\n    IBondingManagement internal bonding;\n\n    // Flags execution of contract initialization.\n    bool internal isInitialized;\n\n    // Notification that the keep was requested to sign a digest.\n    event SignatureRequested(bytes32 indexed digest);\n\n    // Notification that the submitted public key does not match a key submitted\n    // by other member. The event contains address of the member who tried to\n    // submit a public key and a conflicting public key submitted already by other\n    // member.\n    event ConflictingPublicKeySubmitted(\n        address indexed submittingMember,\n        bytes conflictingPublicKey\n    );\n\n    // Notification that keep's ECDSA public key has been successfully established.\n    event PublicKeyPublished(bytes publicKey);\n\n    // Notification that ETH reward has been distributed to keep members.\n    event ETHRewardDistributed(uint256 amount);\n\n    // Notification that ERC20 reward has been distributed to keep members.\n    event ERC20RewardDistributed(address indexed token, uint256 amount);\n\n    // Notification that the keep was closed by the owner.\n    // Members no longer need to support this keep.\n    event KeepClosed();\n\n    // Notification that the keep has been terminated by the owner.\n    // Members no longer need to support this keep.\n    event KeepTerminated();\n\n    // Notification that the signature has been calculated. Contains a digest which\n    // was used for signature calculation and a signature in a form of r, s and\n    // recovery ID values.\n    // The signature is chain-agnostic. Some chains (e.g. Ethereum and BTC) requires\n    // `v` to be calculated by increasing recovery id by 27. Please consult the\n    // documentation about what the particular chain expects.\n    event SignatureSubmitted(\n        bytes32 indexed digest,\n        bytes32 r,\n        bytes32 s,\n        uint8 recoveryID\n    );\n\n    /// @notice Returns keep's ECDSA public key.\n    /// @return Keep's ECDSA public key.\n    function getPublicKey() external view returns (bytes memory) {\n        return publicKey;\n    }\n\n    /// @notice Submits a public key to the keep.\n    /// @dev Public key is published successfully if all members submit the same\n    /// value. In case of conflicts with others members submissions it will emit\n    /// `ConflictingPublicKeySubmitted` event. When all submitted keys match\n    /// it will store the key as keep's public key and emit a `PublicKeyPublished`\n    /// event.\n    /// @param _publicKey Signer's public key.\n    function submitPublicKey(bytes calldata _publicKey) external onlyMember {\n        require(\n            !hasMemberSubmittedPublicKey(msg.sender),\n            \"Member already submitted a public key\"\n        );\n\n        require(_publicKey.length == 64, \"Public key must be 64 bytes long\");\n\n        submittedPublicKeys[msg.sender] = _publicKey;\n\n        // Check if public keys submitted by all keep members are the same as\n        // the currently submitted one.\n        uint256 matchingPublicKeysCount = 0;\n        for (uint256 i = 0; i < members.length; i++) {\n            if (\n                keccak256(submittedPublicKeys[members[i]]) !=\n                keccak256(_publicKey)\n            ) {\n                // Emit an event only if compared member already submitted a value.\n                if (hasMemberSubmittedPublicKey(members[i])) {\n                    emit ConflictingPublicKeySubmitted(\n                        msg.sender,\n                        submittedPublicKeys[members[i]]\n                    );\n                }\n            } else {\n                matchingPublicKeysCount++;\n            }\n        }\n\n        if (matchingPublicKeysCount != members.length) {\n            return;\n        }\n\n        // All submitted signatures match.\n        publicKey = _publicKey;\n        emit PublicKeyPublished(_publicKey);\n    }\n\n    /// @notice Calculates a signature over provided digest by the keep.\n    /// @dev Only one signing process can be in progress at a time.\n    /// @param _digest Digest to be signed.\n    function sign(bytes32 _digest) external onlyOwner onlyWhenActive {\n        require(publicKey.length != 0, \"Public key was not set yet\");\n        require(!isSigningInProgress(), \"Signer is busy\");\n\n        /* solium-disable-next-line */\n        signingStartTimestamp = block.timestamp;\n\n        digests[_digest] = block.number;\n        digest = _digest;\n\n        emit SignatureRequested(_digest);\n    }\n\n    /// @notice Checks if keep is currently awaiting a signature for the given digest.\n    /// @dev Validates if the signing is currently in progress and compares provided\n    /// digest with the one for which the latest signature was requested.\n    /// @param _digest Digest for which to check if signature is being awaited.\n    /// @return True if the digest is currently expected to be signed, else false.\n    function isAwaitingSignature(bytes32 _digest) external view returns (bool) {\n        return isSigningInProgress() && digest == _digest;\n    }\n\n    /// @notice Submits a signature calculated for the given digest.\n    /// @dev Fails if signature has not been requested or a signature has already\n    /// been submitted.\n    /// Validates s value to ensure it's in the lower half of the secp256k1 curve's\n    /// order.\n    /// @param _r Calculated signature's R value.\n    /// @param _s Calculated signature's S value.\n    /// @param _recoveryID Calculated signature's recovery ID (one of {0, 1, 2, 3}).\n    function submitSignature(\n        bytes32 _r,\n        bytes32 _s,\n        uint8 _recoveryID\n    ) external onlyMember {\n        require(isSigningInProgress(), \"Not awaiting a signature\");\n        require(_recoveryID < 4, \"Recovery ID must be one of {0, 1, 2, 3}\");\n\n        // Validate `s` value for a malleability concern described in EIP-2.\n        // Only signatures with `s` value in the lower half of the secp256k1\n        // curve's order are considered valid.\n        require(\n            uint256(_s) <=\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"Malleable signature - s should be in the low half of secp256k1 curve's order\"\n        );\n\n        // We add 27 to the recovery ID to align it with ethereum and bitcoin\n        // protocols where 27 is added to recovery ID to indicate usage of\n        // uncompressed public keys.\n        uint8 _v = 27 + _recoveryID;\n\n        // Validate signature.\n        require(\n            publicKeyToAddress(publicKey) == ecrecover(digest, _v, _r, _s),\n            \"Invalid signature\"\n        );\n\n        signingStartTimestamp = 0;\n\n        emit SignatureSubmitted(digest, _r, _s, _recoveryID);\n    }\n\n    /// @notice Distributes ETH reward evenly across all keep signer beneficiaries.\n    /// If the value cannot be divided evenly across all signers, it sends the\n    /// remainder to the last keep signer.\n    /// @dev Only the value passed to this function is distributed. This\n    /// function does not transfer the value to beneficiaries accounts; instead\n    /// it holds the value in the contract until withdraw function is called for\n    /// the specific signer.\n    function distributeETHReward() external payable {\n        uint256 memberCount = members.length;\n        uint256 dividend = msg.value.div(memberCount);\n\n        require(dividend > 0, \"Dividend value must be non-zero\");\n\n        for (uint16 i = 0; i < memberCount - 1; i++) {\n            memberETHBalances[members[i]] += dividend;\n        }\n\n        // Give the dividend to the last signer. Remainder might be equal to\n        // zero in case of even distribution or some small number.\n        uint256 remainder = msg.value.mod(memberCount);\n        memberETHBalances[members[memberCount - 1]] += dividend.add(remainder);\n\n        emit ETHRewardDistributed(msg.value);\n    }\n\n    /// @notice Distributes ERC20 reward evenly across all keep signer beneficiaries.\n    /// @dev This works with any ERC20 token that implements a transferFrom\n    /// function similar to the interface imported here from\n    /// OpenZeppelin. This function only has authority over pre-approved\n    /// token amount. We don't explicitly check for allowance, SafeMath\n    /// subtraction overflow is enough protection. If the value cannot be\n    /// divided evenly across the signers, it submits the remainder to the last\n    /// keep signer.\n    /// @param _tokenAddress Address of the ERC20 token to distribute.\n    /// @param _value Amount of ERC20 token to distribute.\n    function distributeERC20Reward(address _tokenAddress, uint256 _value)\n        external\n    {\n        IERC20 token = IERC20(_tokenAddress);\n\n        uint256 memberCount = members.length;\n        uint256 dividend = _value.div(memberCount);\n\n        require(dividend > 0, \"Dividend value must be non-zero\");\n\n        for (uint16 i = 0; i < memberCount - 1; i++) {\n            token.safeTransferFrom(\n                msg.sender,\n                beneficiaryOf(members[i]),\n                dividend\n            );\n        }\n\n        // Transfer of dividend for the last member. Remainder might be equal to\n        // zero in case of even distribution or some small number.\n        uint256 remainder = _value.mod(memberCount);\n        token.safeTransferFrom(\n            msg.sender,\n            beneficiaryOf(members[memberCount - 1]),\n            dividend.add(remainder)\n        );\n\n        emit ERC20RewardDistributed(_tokenAddress, _value);\n    }\n\n    /// @notice Gets current amount of ETH hold in the keep for the member.\n    /// @param _member Keep member address.\n    /// @return Current balance in wei.\n    function getMemberETHBalance(address _member)\n        external\n        view\n        returns (uint256)\n    {\n        return memberETHBalances[_member];\n    }\n\n    /// @notice Withdraws amount of ether hold in the keep for the member.\n    /// The value is sent to the beneficiary of the specific member.\n    /// @param _member Keep member address.\n    function withdraw(address _member) external {\n        uint256 value = memberETHBalances[_member];\n\n        require(value > 0, \"No funds to withdraw\");\n\n        memberETHBalances[_member] = 0;\n\n        /* solium-disable-next-line security/no-call-value */\n        (bool success, ) = beneficiaryOf(_member).call.value(value)(\"\");\n\n        require(success, \"Transfer failed\");\n    }\n\n    /// @notice Submits a fraud proof for a valid signature from this keep that was\n    /// not first approved via a call to sign. If fraud is detected it tries to\n    /// slash members' KEEP tokens. For each keep member tries slashing amount\n    /// equal to the member stake set by the factory when keep was created.\n    /// @dev The function expects the signed digest to be calculated as a sha256\n    /// hash of the preimage: `sha256(_preimage))`. The function reverts if the\n    /// signature is not fraudulent. The function does not revert if KEEP slashing\n    /// failed but emits an event instead. In practice, KEEP slashing should\n    /// never fail.\n    /// @param _v Signature's header byte: `27 + recoveryID`.\n    /// @param _r R part of ECDSA signature.\n    /// @param _s S part of ECDSA signature.\n    /// @param _signedDigest Digest for the provided signature. Result of hashing\n    /// the preimage with sha256.\n    /// @param _preimage Preimage of the hashed message.\n    /// @return True if fraud, error otherwise.\n    function submitSignatureFraud(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) external onlyWhenActive returns (bool _isFraud) {\n        bool isFraud = checkSignatureFraud(\n            _v,\n            _r,\n            _s,\n            _signedDigest,\n            _preimage\n        );\n\n        require(isFraud, \"Signature is not fraudulent\");\n\n        if (!fraudulentPreimages[_preimage]) {\n            slashForSignatureFraud();\n\n            fraudulentPreimages[_preimage] = true;\n        }\n\n        return isFraud;\n    }\n\n    /// @notice Gets the owner of the keep.\n    /// @return Address of the keep owner.\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n\n    /// @notice Gets the timestamp the keep was opened at.\n    /// @return Timestamp the keep was opened at.\n    function getOpenedTimestamp() external view returns (uint256) {\n        return keyGenerationStartTimestamp;\n    }\n\n    /// @notice Returns the amount of the keep's ETH bond in wei.\n    /// @return The amount of the keep's ETH bond in wei.\n    function checkBondAmount() external view returns (uint256) {\n        uint256 sumBondAmount = 0;\n        for (uint256 i = 0; i < members.length; i++) {\n            sumBondAmount += bonding.bondAmount(\n                members[i],\n                address(this),\n                uint256(address(this))\n            );\n        }\n\n        return sumBondAmount;\n    }\n\n    /// @notice Seizes the signers' ETH bonds. After seizing bonds keep is\n    /// closed so it will no longer respond to signing requests. Bonds can be\n    /// seized only when there is no signing in progress or requested signing\n    /// process has timed out. This function seizes all of signers' bonds.\n    /// The application may decide to return part of bonds later after they are\n    /// processed using returnPartialSignerBonds function.\n    function seizeSignerBonds() external onlyOwner onlyWhenActive {\n        terminateKeep();\n\n        for (uint256 i = 0; i < members.length; i++) {\n            uint256 amount = bonding.bondAmount(\n                members[i],\n                address(this),\n                uint256(address(this))\n            );\n\n            bonding.seizeBond(\n                members[i],\n                uint256(address(this)),\n                amount,\n                address(uint160(owner))\n            );\n        }\n    }\n\n    /// @notice Returns partial signer's ETH bonds to the pool as an unbounded\n    /// value. This function is called after bonds have been seized and processed\n    /// by the privileged application after calling seizeSignerBonds function.\n    /// It is entirely up to the application if a part of signers' bonds is\n    /// returned. The application may decide for that but may also decide to\n    /// seize bonds and do not return anything.\n    function returnPartialSignerBonds() external payable {\n        uint256 memberCount = members.length;\n        uint256 bondPerMember = msg.value.div(memberCount);\n\n        require(bondPerMember > 0, \"Partial signer bond must be non-zero\");\n\n        for (uint16 i = 0; i < memberCount - 1; i++) {\n            bonding.deposit.value(bondPerMember)(members[i]);\n        }\n\n        // Transfer of dividend for the last member. Remainder might be equal to\n        // zero in case of even distribution or some small number.\n        uint256 remainder = msg.value.mod(memberCount);\n        bonding.deposit.value(bondPerMember.add(remainder))(\n            members[memberCount - 1]\n        );\n    }\n\n    /// @notice Closes keep when owner decides that they no longer need it.\n    /// Releases bonds to the keep members.\n    /// @dev The function can be called only by the owner of the keep and only\n    /// if the keep has not been already closed.\n    function closeKeep() public onlyOwner onlyWhenActive {\n        markAsClosed();\n        freeMembersBonds();\n    }\n\n    /// @notice Returns true if the keep is active.\n    /// @return true if the keep is active, false otherwise.\n    function isActive() public view returns (bool) {\n        return status == Status.Active;\n    }\n\n    /// @notice Returns true if the keep is closed and members no longer support\n    /// this keep.\n    /// @return true if the keep is closed, false otherwise.\n    function isClosed() public view returns (bool) {\n        return status == Status.Closed;\n    }\n\n    /// @notice Returns true if the keep has been terminated.\n    /// Keep is terminated when bonds are seized and members no longer support\n    /// this keep.\n    /// @return true if the keep has been terminated, false otherwise.\n    function isTerminated() public view returns (bool) {\n        return status == Status.Terminated;\n    }\n\n    /// @notice Returns members of the keep.\n    /// @return List of the keep members' addresses.\n    function getMembers() public view returns (address[] memory) {\n        return members;\n    }\n\n    /// @notice Checks a fraud proof for a valid signature from this keep that was\n    /// not first approved via a call to sign.\n    /// @dev The function expects the signed digest to be calculated as a sha256 hash\n    /// of the preimage: `sha256(_preimage))`. The digest is verified against the\n    /// preimage to ensure the security of the ECDSA protocol. Verifying just the\n    /// signature and the digest is not enough and leaves the possibility of the\n    /// the existential forgery. If digest and preimage verification fails the\n    /// function reverts.\n    /// Reverts if a public key has not been set for the keep yet.\n    /// @param _v Signature's header byte: `27 + recoveryID`.\n    /// @param _r R part of ECDSA signature.\n    /// @param _s S part of ECDSA signature.\n    /// @param _signedDigest Digest for the provided signature. Result of hashing\n    /// the preimage with sha256.\n    /// @param _preimage Preimage of the hashed message.\n    /// @return True if fraud, false otherwise.\n    function checkSignatureFraud(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public view returns (bool _isFraud) {\n        require(publicKey.length != 0, \"Public key was not set yet\");\n\n        bytes32 calculatedDigest = sha256(_preimage);\n        require(\n            _signedDigest == calculatedDigest,\n            \"Signed digest does not match sha256 hash of the preimage\"\n        );\n\n        bool isSignatureValid = publicKeyToAddress(publicKey) ==\n            ecrecover(_signedDigest, _v, _r, _s);\n\n        // Check if the signature is valid but was not requested.\n        return isSignatureValid && digests[_signedDigest] == 0;\n    }\n\n    /// @notice Initialization function.\n    /// @dev We use clone factory to create new keep. That is why this contract\n    /// doesn't have a constructor. We provide keep parameters for each instance\n    /// function after cloning instances from the master contract.\n    /// Initialization must happen in the same transaction in which the clone is\n    /// created.\n    /// @param _owner Address of the keep owner.\n    /// @param _members Addresses of the keep members.\n    /// @param _honestThreshold Minimum number of honest keep members.\n    function initialize(\n        address _owner,\n        address[] memory _members,\n        uint256 _honestThreshold,\n        address _bonding\n    ) internal {\n        require(!isInitialized, \"Contract already initialized\");\n\n        owner = _owner;\n        members = _members;\n        honestThreshold = _honestThreshold;\n\n        status = Status.Active;\n        isInitialized = true;\n\n        /* solium-disable-next-line security/no-block-members*/\n        keyGenerationStartTimestamp = block.timestamp;\n\n        bonding = IBondingManagement(_bonding);\n    }\n\n    /// @notice Checks if the member already submitted a public key.\n    /// @param _member Address of the member.\n    /// @return True if member already submitted a public key, else false.\n    function hasMemberSubmittedPublicKey(address _member)\n        internal\n        view\n        returns (bool)\n    {\n        return submittedPublicKeys[_member].length != 0;\n    }\n\n    /// @notice Returns true if signing of a digest is currently in progress.\n    function isSigningInProgress() internal view returns (bool) {\n        return signingStartTimestamp != 0;\n    }\n\n    /// @notice Marks the keep as closed.\n    /// Keep can be marked as closed only when there is no signing in progress\n    /// or the requested signing process has timed out.\n    function markAsClosed() internal {\n        status = Status.Closed;\n        emit KeepClosed();\n    }\n\n    /// @notice Marks the keep as terminated.\n    /// Keep can be marked as terminated only when there is no signing in progress\n    /// or the requested signing process has timed out.\n    function markAsTerminated() internal {\n        status = Status.Terminated;\n        emit KeepTerminated();\n    }\n\n    /// @notice Coverts a public key to an ethereum address.\n    /// @param _publicKey Public key provided as 64-bytes concatenation of\n    /// X and Y coordinates (32-bytes each).\n    /// @return Ethereum address.\n    function publicKeyToAddress(bytes memory _publicKey)\n        internal\n        pure\n        returns (address)\n    {\n        // We hash the public key and then truncate last 20 bytes of the digest\n        // which is the ethereum address.\n        return address(uint160(uint256(keccak256(_publicKey))));\n    }\n\n    /// @notice Returns bonds to the keep members.\n    function freeMembersBonds() internal {\n        for (uint256 i = 0; i < members.length; i++) {\n            bonding.freeBond(members[i], uint256(address(this)));\n        }\n    }\n\n    /// @notice Terminates the keep.\n    function terminateKeep() internal {\n        markAsTerminated();\n    }\n\n    /// @notice Punishes keep members after proving a signature fraud.\n    function slashForSignatureFraud() internal;\n\n    /// @notice Gets the beneficiary for the specified member address.\n    /// @param _member Member address.\n    /// @return Beneficiary address.\n    function beneficiaryOf(address _member)\n        internal\n        view\n        returns (address payable);\n\n    /// @notice Checks if the caller is the keep's owner.\n    /// @dev Throws an error if called by any account other than owner.\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Caller is not the keep owner\");\n        _;\n    }\n\n    /// @notice Checks if the caller is a keep member.\n    /// @dev Throws an error if called by any account other than one of the members.\n    modifier onlyMember() {\n        require(members.contains(msg.sender), \"Caller is not the keep member\");\n        _;\n    }\n\n    /// @notice Checks if the keep is currently active.\n    /// @dev Throws an error if called when the keep has been already closed.\n    modifier onlyWhenActive() {\n        require(isActive(), \"Keep is not active\");\n        _;\n    }\n}\n"
    },
    "solidity/contracts/api/IBondedECDSAKeep.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\n/// @title ECDSA Keep\n/// @notice Contract reflecting an ECDSA keep.\ncontract IBondedECDSAKeep {\n    /// @notice Returns public key of this keep.\n    /// @return Keeps's public key.\n    function getPublicKey() external view returns (bytes memory);\n\n    /// @notice Returns the amount of the keep's ETH bond in wei.\n    /// @return The amount of the keep's ETH bond in wei.\n    function checkBondAmount() external view returns (uint256);\n\n    /// @notice Calculates a signature over provided digest by the keep. Note that\n    /// signatures from the keep not explicitly requested by calling `sign`\n    /// will be provable as fraud via `submitSignatureFraud`.\n    /// @param _digest Digest to be signed.\n    function sign(bytes32 _digest) external;\n\n    /// @notice Distributes ETH reward evenly across keep signer beneficiaries.\n    /// @dev Only the value passed to this function is distributed.\n    function distributeETHReward() external payable;\n\n    /// @notice Distributes ERC20 reward evenly across keep signer beneficiaries.\n    /// @dev This works with any ERC20 token that implements a transferFrom\n    /// function.\n    /// This function only has authority over pre-approved\n    /// token amount. We don't explicitly check for allowance, SafeMath\n    /// subtraction overflow is enough protection.\n    /// @param _tokenAddress Address of the ERC20 token to distribute.\n    /// @param _value Amount of ERC20 token to distribute.\n    function distributeERC20Reward(address _tokenAddress, uint256 _value)\n        external;\n\n    /// @notice Seizes the signers' ETH bonds. After seizing bonds keep is\n    /// terminated so it will no longer respond to signing requests. Bonds can\n    /// be seized only when there is no signing in progress or requested signing\n    /// process has timed out. This function seizes all of signers' bonds.\n    /// The application may decide to return part of bonds later after they are\n    /// processed using returnPartialSignerBonds function.\n    function seizeSignerBonds() external;\n\n    /// @notice Returns partial signer's ETH bonds to the pool as an unbounded\n    /// value. This function is called after bonds have been seized and processed\n    /// by the privileged application after calling seizeSignerBonds function.\n    /// It is entirely up to the application if a part of signers' bonds is\n    /// returned. The application may decide for that but may also decide to\n    /// seize bonds and do not return anything.\n    function returnPartialSignerBonds() external payable;\n\n    /// @notice Submits a fraud proof for a valid signature from this keep that was\n    /// not first approved via a call to sign.\n    /// @dev The function expects the signed digest to be calculated as a sha256\n    /// hash of the preimage: `sha256(_preimage)`.\n    /// @param _v Signature's header byte: `27 + recoveryID`.\n    /// @param _r R part of ECDSA signature.\n    /// @param _s S part of ECDSA signature.\n    /// @param _signedDigest Digest for the provided signature. Result of hashing\n    /// the preimage.\n    /// @param _preimage Preimage of the hashed message.\n    /// @return True if fraud, error otherwise.\n    function submitSignatureFraud(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    )\n        external returns (bool _isFraud);\n\n    /// @notice Closes keep when no longer needed. Releases bonds to the keep\n    /// members. Keep can be closed only when there is no signing in progress or\n    /// requested signing process has timed out.\n    /// @dev The function can be called only by the owner of the keep and only\n    /// if the keep has not been already closed.\n    function closeKeep() external;\n}\n"
    },
    "solidity/contracts/api/IBondingManagement.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"@keep-network/sortition-pools/contracts/api/IBonding.sol\";\n\ncontract IBondingManagement is IBonding {\n    /// @notice Add the provided value to operator's pool available for bonding.\n    /// @param operator Address of the operator.\n    function deposit(address operator) public payable;\n\n    /// @notice Withdraws amount from operator's value available for bonding.\n    /// @param amount Value to withdraw in wei.\n    /// @param operator Address of the operator.\n    function withdraw(uint256 amount, address operator) public;\n\n    /// @notice Create bond for the given operator, holder, reference and amount.\n    /// @param operator Address of the operator to bond.\n    /// @param holder Address of the holder of the bond.\n    /// @param referenceID Reference ID used to track the bond by holder.\n    /// @param amount Value to bond in wei.\n    /// @param authorizedSortitionPool Address of authorized sortition pool.\n    function createBond(\n        address operator,\n        address holder,\n        uint256 referenceID,\n        uint256 amount,\n        address authorizedSortitionPool\n    ) public;\n\n    /// @notice Returns value of wei bonded for the operator.\n    /// @param operator Address of the operator.\n    /// @param holder Address of the holder of the bond.\n    /// @param referenceID Reference ID of the bond.\n    /// @return Amount of wei in the selected bond.\n    function bondAmount(\n        address operator,\n        address holder,\n        uint256 referenceID\n    ) public view returns (uint256);\n\n    /// @notice Reassigns a bond to a new holder under a new reference.\n    /// @param operator Address of the bonded operator.\n    /// @param referenceID Reference ID of the bond.\n    /// @param newHolder Address of the new holder of the bond.\n    /// @param newReferenceID New reference ID to register the bond.\n    function reassignBond(\n        address operator,\n        uint256 referenceID,\n        address newHolder,\n        uint256 newReferenceID\n    ) public;\n\n    /// @notice Releases the bond and moves the bond value to the operator's\n    /// unbounded value pool.\n    /// @param operator Address of the bonded operator.\n    /// @param referenceID Reference ID of the bond.\n    function freeBond(address operator, uint256 referenceID) public;\n\n    /// @notice Seizes the bond by moving some or all of the locked bond to the\n    /// provided destination address.\n    /// @param operator Address of the bonded operator.\n    /// @param referenceID Reference ID of the bond.\n    /// @param amount Amount to be seized.\n    /// @param destination Address to send the amount to.\n    function seizeBond(\n        address operator,\n        uint256 referenceID,\n        uint256 amount,\n        address payable destination\n    ) public;\n}\n"
    },
    "@keep-network/sortition-pools/contracts/api/IBonding.sol": {
      "content": "pragma solidity 0.5.17;\n\ninterface IBonding {\n    // Gives the amount of ETH\n    // the `operator` has made available for bonding by the `bondCreator`.\n    // If the operator doesn't exist,\n    // or the bond creator isn't authorized,\n    // returns 0.\n    function availableUnbondedValue(\n        address operator,\n        address bondCreator,\n        address authorizedSortitionPool\n    ) external view returns (uint256);\n}\n"
    },
    "@keep-network/keep-core/contracts/utils/AddressArrayUtils.sol": {
      "content": "pragma solidity 0.5.17;\n\n\nlibrary AddressArrayUtils {\n\n    function contains(address[] memory self, address _address)\n        internal\n        pure\n        returns (bool)\n    {\n        for (uint i = 0; i < self.length; i++) {\n            if (_address == self[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function removeAddress(address[] storage self, address _addressToRemove)\n        internal\n        returns (address[] storage)\n    {\n        for (uint i = 0; i < self.length; i++) {\n            // If address is found in array.\n            if (_addressToRemove == self[i]) {\n                // Delete element at index and shift array.\n                for (uint j = i; j < self.length-1; j++) {\n                    self[j] = self[j+1];\n                }\n                self.length--;\n                i--;\n            }\n        }\n        return self;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Collection of functions related to the address type,\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * > It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n"
    },
    "solidity/contracts/AbstractBonding.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"./api/IBondingManagement.sol\";\n\nimport \"@keep-network/keep-core/contracts/KeepRegistry.sol\";\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/// @title Abstract Bonding\n/// @notice Contract holding deposits from keeps' operators.\ncontract AbstractBonding is IBondingManagement {\n    using SafeMath for uint256;\n\n    // Registry contract with a list of approved factories (operator contracts).\n    KeepRegistry internal registry;\n\n    // Unassigned value in wei deposited by operators.\n    mapping(address => uint256) public unbondedValue;\n\n    // References to created bonds. Bond identifier is built from operator's\n    // address, holder's address and reference ID assigned on bond creation.\n    mapping(bytes32 => uint256) internal lockedBonds;\n\n    // Sortition pools authorized by operator's authorizer.\n    // operator -> pool -> boolean\n    mapping(address => mapping(address => bool)) internal authorizedPools;\n\n    event UnbondedValueDeposited(\n        address indexed operator,\n        address indexed beneficiary,\n        uint256 amount\n    );\n    event UnbondedValueWithdrawn(\n        address indexed operator,\n        address indexed beneficiary,\n        uint256 amount\n    );\n    event BondCreated(\n        address indexed operator,\n        address indexed holder,\n        address indexed sortitionPool,\n        uint256 referenceID,\n        uint256 amount\n    );\n    event BondReassigned(\n        address indexed operator,\n        uint256 indexed referenceID,\n        address newHolder,\n        uint256 newReferenceID\n    );\n    event BondReleased(address indexed operator, uint256 indexed referenceID);\n    event BondSeized(\n        address indexed operator,\n        uint256 indexed referenceID,\n        address destination,\n        uint256 amount\n    );\n\n    /// @notice Initializes Keep Bonding contract.\n    /// @param registryAddress Keep registry contract address.\n    constructor(address registryAddress) public {\n        registry = KeepRegistry(registryAddress);\n    }\n\n    /// @notice Add the provided value to operator's pool available for bonding.\n    /// @param operator Address of the operator.\n    function deposit(address operator) public payable {\n        address beneficiary = beneficiaryOf(operator);\n        // Beneficiary has to be set (delegation exist) before an operator can\n        // deposit wei. It protects from a situation when an operator wants\n        // to withdraw funds which are transfered to beneficiary with zero\n        // address.\n        require(\n            beneficiary != address(0),\n            \"Beneficiary not defined for the operator\"\n        );\n        unbondedValue[operator] = unbondedValue[operator].add(msg.value);\n        emit UnbondedValueDeposited(operator, beneficiary, msg.value);\n    }\n\n    /// @notice Withdraws amount from operator's value available for bonding.\n    /// @param amount Value to withdraw in wei.\n    /// @param operator Address of the operator.\n    function withdraw(uint256 amount, address operator) public;\n\n    /// @notice Returns the amount of wei the operator has made available for\n    /// bonding and that is still unbounded. If the operator doesn't exist or\n    /// bond creator is not authorized as an operator contract or it is not\n    /// authorized by the operator or there is no secondary authorization for\n    /// the provided sortition pool, function returns 0.\n    /// @dev Implements function expected by sortition pools' IBonding interface.\n    /// @param operator Address of the operator.\n    /// @param bondCreator Address authorized to create a bond.\n    /// @param authorizedSortitionPool Address of authorized sortition pool.\n    /// @return Amount of authorized wei deposit available for bonding.\n    function availableUnbondedValue(\n        address operator,\n        address bondCreator,\n        address authorizedSortitionPool\n    ) public view returns (uint256) {\n        // Sortition pools check this condition and skips operators that\n        // are no longer eligible. We cannot revert here.\n        if (\n            registry.isApprovedOperatorContract(bondCreator) &&\n            isAuthorizedForOperator(operator, bondCreator) &&\n            hasSecondaryAuthorization(operator, authorizedSortitionPool)\n        ) {\n            return unbondedValue[operator];\n        }\n\n        return 0;\n    }\n\n    /// @notice Create bond for the given operator, holder, reference and amount.\n    /// @dev Function can be executed only by authorized contract. Reference ID\n    /// should be unique for holder and operator.\n    /// @param operator Address of the operator to bond.\n    /// @param holder Address of the holder of the bond.\n    /// @param referenceID Reference ID used to track the bond by holder.\n    /// @param amount Value to bond in wei.\n    /// @param authorizedSortitionPool Address of authorized sortition pool.\n    function createBond(\n        address operator,\n        address holder,\n        uint256 referenceID,\n        uint256 amount,\n        address authorizedSortitionPool\n    ) public {\n        require(\n            availableUnbondedValue(\n                operator,\n                msg.sender,\n                authorizedSortitionPool\n            ) >= amount,\n            \"Insufficient unbonded value\"\n        );\n\n        bytes32 bondID = keccak256(\n            abi.encodePacked(operator, holder, referenceID)\n        );\n\n        require(\n            lockedBonds[bondID] == 0,\n            \"Reference ID not unique for holder and operator\"\n        );\n\n        unbondedValue[operator] = unbondedValue[operator].sub(amount);\n        lockedBonds[bondID] = lockedBonds[bondID].add(amount);\n\n        emit BondCreated(\n            operator,\n            holder,\n            authorizedSortitionPool,\n            referenceID,\n            amount\n        );\n    }\n\n    /// @notice Returns value of wei bonded for the operator.\n    /// @param operator Address of the operator.\n    /// @param holder Address of the holder of the bond.\n    /// @param referenceID Reference ID of the bond.\n    /// @return Amount of wei in the selected bond.\n    function bondAmount(\n        address operator,\n        address holder,\n        uint256 referenceID\n    ) public view returns (uint256) {\n        bytes32 bondID = keccak256(\n            abi.encodePacked(operator, holder, referenceID)\n        );\n\n        return lockedBonds[bondID];\n    }\n\n    /// @notice Reassigns a bond to a new holder under a new reference.\n    /// @dev Function requires that a caller is the current holder of the bond\n    /// which is being reassigned.\n    /// @param operator Address of the bonded operator.\n    /// @param referenceID Reference ID of the bond.\n    /// @param newHolder Address of the new holder of the bond.\n    /// @param newReferenceID New reference ID to register the bond.\n    function reassignBond(\n        address operator,\n        uint256 referenceID,\n        address newHolder,\n        uint256 newReferenceID\n    ) public {\n        address holder = msg.sender;\n        bytes32 bondID = keccak256(\n            abi.encodePacked(operator, holder, referenceID)\n        );\n\n        require(lockedBonds[bondID] > 0, \"Bond not found\");\n\n        bytes32 newBondID = keccak256(\n            abi.encodePacked(operator, newHolder, newReferenceID)\n        );\n\n        require(\n            lockedBonds[newBondID] == 0,\n            \"Reference ID not unique for holder and operator\"\n        );\n\n        lockedBonds[newBondID] = lockedBonds[bondID];\n        lockedBonds[bondID] = 0;\n\n        emit BondReassigned(operator, referenceID, newHolder, newReferenceID);\n    }\n\n    /// @notice Releases the bond and moves the bond value to the operator's\n    /// unbounded value pool.\n    /// @dev Function requires that caller is the holder of the bond which is\n    /// being released.\n    /// @param operator Address of the bonded operator.\n    /// @param referenceID Reference ID of the bond.\n    function freeBond(address operator, uint256 referenceID) public {\n        address holder = msg.sender;\n        bytes32 bondID = keccak256(\n            abi.encodePacked(operator, holder, referenceID)\n        );\n\n        require(lockedBonds[bondID] > 0, \"Bond not found\");\n\n        uint256 amount = lockedBonds[bondID];\n        lockedBonds[bondID] = 0;\n        unbondedValue[operator] = unbondedValue[operator].add(amount);\n\n        emit BondReleased(operator, referenceID);\n    }\n\n    /// @notice Seizes the bond by moving some or all of the locked bond to the\n    /// provided destination address.\n    /// @dev Function requires that a caller is the holder of the bond which is\n    /// being seized.\n    /// @param operator Address of the bonded operator.\n    /// @param referenceID Reference ID of the bond.\n    /// @param amount Amount to be seized.\n    /// @param destination Address to send the amount to.\n    function seizeBond(\n        address operator,\n        uint256 referenceID,\n        uint256 amount,\n        address payable destination\n    ) public {\n        require(amount > 0, \"Requested amount should be greater than zero\");\n\n        address payable holder = msg.sender;\n        bytes32 bondID = keccak256(\n            abi.encodePacked(operator, holder, referenceID)\n        );\n\n        require(\n            lockedBonds[bondID] >= amount,\n            \"Requested amount is greater than the bond\"\n        );\n\n        lockedBonds[bondID] = lockedBonds[bondID].sub(amount);\n\n        (bool success, ) = destination.call.value(amount)(\"\");\n        require(success, \"Transfer failed\");\n\n        emit BondSeized(operator, referenceID, destination, amount);\n    }\n\n    /// @notice Authorizes sortition pool for the provided operator.\n    /// Operator's authorizers need to authorize individual sortition pools\n    /// per application since they may be interested in participating only in\n    /// a subset of keep types used by the given application.\n    /// @dev Only operator's authorizer can call this function.\n    function authorizeSortitionPoolContract(\n        address _operator,\n        address _poolAddress\n    ) public {\n        require(authorizerOf(_operator) == msg.sender, \"Not authorized\");\n        authorizedPools[_operator][_poolAddress] = true;\n    }\n\n    /// @notice Deauthorizes sortition pool for the provided operator.\n    /// Authorizer may deauthorize individual sortition pool in case the\n    /// operator should no longer be eligible for work selection and the\n    /// application represented by the sortition pool should no longer be\n    /// eligible to create bonds for the operator.\n    /// @dev Only operator's authorizer can call this function.\n    function deauthorizeSortitionPoolContract(\n        address _operator,\n        address _poolAddress\n    ) public {\n        require(authorizerOf(_operator) == msg.sender, \"Not authorized\");\n        authorizedPools[_operator][_poolAddress] = false;\n    }\n\n    /// @notice Checks if the sortition pool has been authorized for the\n    /// provided operator by its authorizer.\n    /// @dev See authorizeSortitionPoolContract.\n    function hasSecondaryAuthorization(address _operator, address _poolAddress)\n        public\n        view\n        returns (bool)\n    {\n        return authorizedPools[_operator][_poolAddress];\n    }\n\n    /// @notice Checks if operator contract has been authorized for the provided\n    /// operator.\n    /// @param _operator Operator address.\n    /// @param _operatorContract Address of the operator contract.\n    function isAuthorizedForOperator(\n        address _operator,\n        address _operatorContract\n    ) public view returns (bool);\n\n    /// @notice Gets the authorizer for the specified operator address.\n    /// @param _operator Operator address.\n    /// @return Authorizer address.\n    function authorizerOf(address _operator) public view returns (address);\n\n    /// @notice Gets the beneficiary for the specified operator address.\n    /// @param _operator Operator address.\n    /// @return Beneficiary address.\n    function beneficiaryOf(address _operator)\n        public\n        view\n        returns (address payable);\n\n    /// @notice Withdraws the provided amount from unbonded value of the\n    /// provided operator to operator's beneficiary. If there is no enough\n    /// unbonded value or the transfer failed, function fails.\n    function withdrawBond(uint256 amount, address operator) internal {\n        require(\n            unbondedValue[operator] >= amount,\n            \"Insufficient unbonded value\"\n        );\n\n        unbondedValue[operator] = unbondedValue[operator].sub(amount);\n\n        address beneficiary = beneficiaryOf(operator);\n\n        (bool success, ) = beneficiary.call.value(amount)(\"\");\n        require(success, \"Transfer failed\");\n\n        emit UnbondedValueWithdrawn(operator, beneficiary, amount);\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/KeepRegistry.sol": {
      "content": "pragma solidity 0.5.17;\n\n\n/// @title KeepRegistry\n/// @notice Governance owned registry of approved contracts and roles.\ncontract KeepRegistry {\n    enum ContractStatus {New, Approved, Disabled}\n\n    // Governance role is to enable recovery from key compromise by rekeying\n    // other roles. Also, it can disable operator contract panic buttons\n    // permanently.\n    address public governance;\n\n    // Registry Keeper maintains approved operator contracts. Each operator\n    // contract must be approved before it can be authorized by a staker or\n    // used by a service contract.\n    address public registryKeeper;\n\n    // Each operator contract has a Panic Button which can disable malicious\n    // or malfunctioning contract that have been previously approved by the\n    // Registry Keeper.\n    //\n    // New operator contract added to the registry has a default panic button\n    // value assigned (defaultPanicButton). Panic button for each operator\n    // contract can be later updated by Governance to individual value.\n    //\n    // It is possible to disable panic button for individual contract by\n    // setting the panic button to zero address. In such case, operator contract\n    // can not be disabled and is permanently approved in the registry.\n    mapping(address => address) public panicButtons;\n\n    // Default panic button for each new operator contract added to the\n    // registry. Can be later updated for each contract.\n    address public defaultPanicButton;\n\n    // Each service contract has a Operator Contract Upgrader whose purpose\n    // is to manage operator contracts for that specific service contract.\n    // The Operator Contract Upgrader can add new operator contracts to the\n    // service contract’s operator contract list, and deprecate old ones.\n    mapping(address => address) public operatorContractUpgraders;\n\n    // Operator contract may have a Service Contract Upgrader whose purpose is\n    // to manage service contracts for that specific operator contract.\n    // Service Contract Upgrader can add and remove service contracts\n    // from the list of service contracts approved to work with the operator\n    // contract. List of service contracts is maintained in the operator\n    // contract and is optional - not every operator contract needs to have\n    // a list of service contracts it wants to cooperate with.\n    mapping(address => address) public serviceContractUpgraders;\n\n    // The registry of operator contracts\n    mapping(address => ContractStatus) public operatorContracts;\n\n    event OperatorContractApproved(address operatorContract);\n    event OperatorContractDisabled(address operatorContract);\n\n    event GovernanceUpdated(address governance);\n    event RegistryKeeperUpdated(address registryKeeper);\n    event DefaultPanicButtonUpdated(address defaultPanicButton);\n    event OperatorContractPanicButtonDisabled(address operatorContract);\n    event OperatorContractPanicButtonUpdated(\n        address operatorContract,\n        address panicButton\n    );\n    event OperatorContractUpgraderUpdated(\n        address serviceContract,\n        address upgrader\n    );\n    event ServiceContractUpgraderUpdated(\n        address operatorContract,\n        address keeper\n    );\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, \"Not authorized\");\n        _;\n    }\n\n    modifier onlyRegistryKeeper() {\n        require(registryKeeper == msg.sender, \"Not authorized\");\n        _;\n    }\n\n    modifier onlyPanicButton(address _operatorContract) {\n        address panicButton = panicButtons[_operatorContract];\n        require(panicButton != address(0), \"Panic button disabled\");\n        require(panicButton == msg.sender, \"Not authorized\");\n        _;\n    }\n\n    modifier onlyForNewContract(address _operatorContract) {\n        require(\n            isNewOperatorContract(_operatorContract),\n            \"Not a new operator contract\"\n        );\n        _;\n    }\n\n    modifier onlyForApprovedContract(address _operatorContract) {\n        require(\n            isApprovedOperatorContract(_operatorContract),\n            \"Not an approved operator contract\"\n        );\n        _;\n    }\n\n    constructor() public {\n        governance = msg.sender;\n        registryKeeper = msg.sender;\n        defaultPanicButton = msg.sender;\n    }\n\n    function setGovernance(address _governance) public onlyGovernance {\n        governance = _governance;\n        emit GovernanceUpdated(governance);\n    }\n\n    function setRegistryKeeper(address _registryKeeper) public onlyGovernance {\n        registryKeeper = _registryKeeper;\n        emit RegistryKeeperUpdated(registryKeeper);\n    }\n\n    function setDefaultPanicButton(address _panicButton) public onlyGovernance {\n        defaultPanicButton = _panicButton;\n        emit DefaultPanicButtonUpdated(defaultPanicButton);\n    }\n\n    function setOperatorContractPanicButton(\n        address _operatorContract,\n        address _panicButton\n    ) public onlyForApprovedContract(_operatorContract) onlyGovernance {\n        require(\n            panicButtons[_operatorContract] != address(0),\n            \"Disabled panic button cannot be updated\"\n        );\n        require(\n            _panicButton != address(0),\n            \"Panic button must be non-zero address\"\n        );\n\n        panicButtons[_operatorContract] = _panicButton;\n\n        emit OperatorContractPanicButtonUpdated(\n            _operatorContract,\n            _panicButton\n        );\n    }\n\n    function disableOperatorContractPanicButton(address _operatorContract)\n        public\n        onlyForApprovedContract(_operatorContract)\n        onlyGovernance\n    {\n        require(\n            panicButtons[_operatorContract] != address(0),\n            \"Panic button already disabled\"\n        );\n\n        panicButtons[_operatorContract] = address(0);\n\n        emit OperatorContractPanicButtonDisabled(_operatorContract);\n    }\n\n    function setOperatorContractUpgrader(\n        address _serviceContract,\n        address _operatorContractUpgrader\n    ) public onlyGovernance {\n        operatorContractUpgraders[_serviceContract] = _operatorContractUpgrader;\n        emit OperatorContractUpgraderUpdated(\n            _serviceContract,\n            _operatorContractUpgrader\n        );\n    }\n\n    function setServiceContractUpgrader(\n        address _operatorContract,\n        address _serviceContractUpgrader\n    ) public onlyGovernance {\n        serviceContractUpgraders[_operatorContract] = _serviceContractUpgrader;\n        emit ServiceContractUpgraderUpdated(\n            _operatorContract,\n            _serviceContractUpgrader\n        );\n    }\n\n    function approveOperatorContract(address operatorContract)\n        public\n        onlyForNewContract(operatorContract)\n        onlyRegistryKeeper\n    {\n        operatorContracts[operatorContract] = ContractStatus.Approved;\n        panicButtons[operatorContract] = defaultPanicButton;\n        emit OperatorContractApproved(operatorContract);\n    }\n\n    function disableOperatorContract(address operatorContract)\n        public\n        onlyForApprovedContract(operatorContract)\n        onlyPanicButton(operatorContract)\n    {\n        operatorContracts[operatorContract] = ContractStatus.Disabled;\n        emit OperatorContractDisabled(operatorContract);\n    }\n\n    function isNewOperatorContract(address operatorContract)\n        public\n        view\n        returns (bool)\n    {\n        return operatorContracts[operatorContract] == ContractStatus.New;\n    }\n\n    function isApprovedOperatorContract(address operatorContract)\n        public\n        view\n        returns (bool)\n    {\n        return operatorContracts[operatorContract] == ContractStatus.Approved;\n    }\n\n    function operatorContractUpgraderFor(address _serviceContract)\n        public\n        view\n        returns (address)\n    {\n        return operatorContractUpgraders[_serviceContract];\n    }\n\n    function serviceContractUpgraderFor(address _operatorContract)\n        public\n        view\n        returns (address)\n    {\n        return serviceContractUpgraders[_operatorContract];\n    }\n}\n"
    },
    "solidity/contracts/api/IBondedECDSAKeepFactory.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\n/// @title Bonded ECDSA Keep Factory\n/// @notice Factory for Bonded ECDSA Keeps.\ninterface IBondedECDSAKeepFactory {\n    /// @notice Open a new ECDSA Keep.\n    /// @param _groupSize Number of members in the keep.\n    /// @param _honestThreshold Minimum number of honest keep members.\n    /// @param _owner Address of the keep owner.\n    /// @param _bond Value of ETH bond required from the keep.\n    /// @param _stakeLockDuration Stake lock duration in seconds.\n    /// @return Address of the opened keep.\n    function openKeep(\n        uint256 _groupSize,\n        uint256 _honestThreshold,\n        address _owner,\n        uint256 _bond,\n        uint256 _stakeLockDuration\n    ) external payable returns (address keepAddress);\n\n    /// @notice Gets a fee estimate for opening a new keep.\n    /// @return Uint256 estimate.\n    function openKeepFeeEstimate() external view returns (uint256);\n\n    /// @notice Gets the total weight of operators\n    /// in the sortition pool for the given application.\n    /// @param _application Address of the application.\n    /// @return The sum of all registered operators' weights in the pool.\n    /// Reverts if sortition pool for the application does not exist.\n    function getSortitionPoolWeight(\n        address _application\n    ) external view returns (uint256);\n\n    /// @notice Sets the minimum bondable value required from the operator to\n    /// join the sortition pool of the given application. It is up to the\n    /// application to specify a reasonable minimum bond for operators trying to\n    /// join the pool to prevent griefing by operators joining without enough\n    /// bondable value.\n    /// @dev The default minimum bond value for each sortition pool created\n    /// is 20 ETH.\n    /// @param _minimumBondableValue The minimum unbonded value the application\n    /// requires from a single keep.\n    /// @param _groupSize Number of signers in the keep.\n    /// @param _honestThreshold Minimum number of honest keep signers.\n    function setMinimumBondableValue(\n        uint256 _minimumBondableValue,\n        uint256 _groupSize,\n        uint256 _honestThreshold\n    ) external;\n}\n"
    },
    "solidity/contracts/BondedECDSAKeep.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"./AbstractBondedECDSAKeep.sol\";\nimport \"./BondedECDSAKeepFactory.sol\";\n\nimport \"@keep-network/keep-core/contracts/TokenStaking.sol\";\n\n/// @title Bonded ECDSA Keep\n/// @notice ECDSA keep with additional signer bond requirement.\n/// @dev This contract is used as a master contract for clone factory in\n/// BondedECDSAKeepFactory as per EIP-1167.\ncontract BondedECDSAKeep is AbstractBondedECDSAKeep {\n    // Stake that was required from each keep member on keep creation.\n    // The value is used for keep members slashing.\n    uint256 public memberStake;\n\n    // Emitted when KEEP token slashing failed when submitting signature\n    // fraud proof. In practice, this situation should never happen but we want\n    // to be very explicit in this contract and protect the owner that even if\n    // it happens, the transaction submitting fraud proof is not going to fail\n    // and keep owner can seize and liquidate bonds in the same transaction.\n    event SlashingFailed();\n\n    TokenStaking tokenStaking;\n\n    /// @notice Initialization function.\n    /// @dev We use clone factory to create new keep. That is why this contract\n    /// doesn't have a constructor. We provide keep parameters for each instance\n    /// function after cloning instances from the master contract.\n    /// @param _owner Address of the keep owner.\n    /// @param _members Addresses of the keep members.\n    /// @param _honestThreshold Minimum number of honest keep members.\n    /// @param _memberStake Stake required from each keep member.\n    /// @param _stakeLockDuration Stake lock duration in seconds.\n    /// @param _tokenStaking Address of the TokenStaking contract.\n    /// @param _keepBonding Address of the KeepBonding contract.\n    /// @param _keepFactory Address of the BondedECDSAKeepFactory that created\n    /// this keep.\n    function initialize(\n        address _owner,\n        address[] memory _members,\n        uint256 _honestThreshold,\n        uint256 _memberStake,\n        uint256 _stakeLockDuration,\n        address _tokenStaking,\n        address _keepBonding,\n        address payable _keepFactory\n    ) public {\n        super.initialize(_owner, _members, _honestThreshold, _keepBonding);\n\n        memberStake = _memberStake;\n        tokenStaking = TokenStaking(_tokenStaking);\n\n        tokenStaking.claimDelegatedAuthority(_keepFactory);\n\n        lockMemberStakes(_stakeLockDuration);\n    }\n\n    /// @notice Closes keep when owner decides that they no longer need it.\n    /// Releases bonds to the keep members. Keep can be closed only when\n    /// there is no signing in progress or requested signing process has timed out.\n    /// @dev The function can be called only by the owner of the keep and only\n    /// if the keep has not been already closed.\n    function closeKeep() public onlyOwner onlyWhenActive {\n        super.closeKeep();\n        unlockMemberStakes();\n    }\n\n    /// @notice Terminates the keep.\n    function terminateKeep() internal {\n        super.terminateKeep();\n        unlockMemberStakes();\n    }\n\n    function slashForSignatureFraud() internal {\n        /* solium-disable-next-line */\n        (bool success, ) = address(tokenStaking).call(\n            abi.encodeWithSignature(\n                \"slash(uint256,address[])\",\n                memberStake,\n                members\n            )\n        );\n\n        // Should never happen but we want to protect the owner and make sure the\n        // fraud submission transaction does not fail so that the owner can\n        // seize and liquidate bonds in the same transaction.\n        if (!success) {\n            emit SlashingFailed();\n        }\n    }\n\n    /// @notice Creates locks on members' token stakes.\n    /// @param _stakeLockDuration Stake lock duration in seconds.\n    function lockMemberStakes(uint256 _stakeLockDuration) internal {\n        for (uint256 i = 0; i < members.length; i++) {\n            tokenStaking.lockStake(members[i], _stakeLockDuration);\n        }\n    }\n\n    /// @notice Releases locks the keep had previously placed on the members'\n    /// token stakes.\n    function unlockMemberStakes() internal {\n        for (uint256 i = 0; i < members.length; i++) {\n            tokenStaking.unlockStake(members[i]);\n        }\n    }\n\n    /// @notice Gets the beneficiary for the specified member address.\n    /// @param _member Member address.\n    /// @return Beneficiary address.\n    function beneficiaryOf(address _member)\n        internal\n        view\n        returns (address payable)\n    {\n        return tokenStaking.beneficiaryOf(_member);\n    }\n}\n"
    },
    "solidity/contracts/BondedECDSAKeepFactory.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"./BondedECDSAKeep.sol\";\nimport \"./KeepBonding.sol\";\nimport \"./api/IBondedECDSAKeepFactory.sol\";\nimport \"./KeepCreator.sol\";\nimport \"./GroupSelectionSeed.sol\";\nimport \"./CandidatesPools.sol\";\n\nimport \"@keep-network/sortition-pools/contracts/api/IStaking.sol\";\nimport \"@keep-network/sortition-pools/contracts/api/IBonding.sol\";\nimport \"@keep-network/sortition-pools/contracts/BondedSortitionPool.sol\";\nimport \"@keep-network/sortition-pools/contracts/BondedSortitionPoolFactory.sol\";\n\nimport {\n    AuthorityDelegator,\n    TokenStaking\n} from \"@keep-network/keep-core/contracts/TokenStaking.sol\";\nimport \"@keep-network/keep-core/contracts/utils/AddressArrayUtils.sol\";\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/// @title Bonded ECDSA Keep Factory\n/// @notice Contract creating bonded ECDSA keeps.\n/// @dev We avoid redeployment of bonded ECDSA keep contract by using the clone factory.\n/// Proxy delegates calls to sortition pool and therefore does not affect contract's\n/// state. This means that we only need to deploy the bonded ECDSA keep contract\n/// once. The factory provides clean state for every new bonded ECDSA keep clone.\ncontract BondedECDSAKeepFactory is\n    IBondedECDSAKeepFactory,\n    KeepCreator,\n    AuthorityDelegator,\n    GroupSelectionSeed,\n    CandidatesPools\n{\n    using AddressArrayUtils for address[];\n    using SafeMath for uint256;\n\n    // Notification that a new keep has been created.\n    event BondedECDSAKeepCreated(\n        address indexed keepAddress,\n        address[] members,\n        address indexed owner,\n        address indexed application,\n        uint256 honestThreshold\n    );\n\n    BondedSortitionPoolFactory sortitionPoolFactory;\n    TokenStaking tokenStaking;\n    KeepBonding keepBonding;\n\n    // Sortition pool is created with a minimum bond of 20 ETH to avoid\n    // small operators joining and griefing future selections before the\n    // minimum bond is set to the right value by the application.\n    //\n    // Anyone can create a sortition pool for an application with the default\n    // minimum bond value but the application can change this value later, at\n    // any point.\n    uint256 public constant minimumBond = 20e18; // 20 ETH\n\n    // Signer candidates in bonded sortition pool are weighted by their eligible\n    // stake divided by a constant divisor. The divisor is set to 1 KEEP so that\n    // all KEEPs in eligible stake matter when calculating operator's eligible\n    // weight for signer selection.\n    uint256 public constant poolStakeWeightDivisor = 1e18;\n\n    constructor(\n        address _masterBondedECDSAKeepAddress,\n        address _sortitionPoolFactory,\n        address _tokenStaking,\n        address _keepBonding,\n        address _randomBeacon\n    )\n        public\n        KeepCreator(_masterBondedECDSAKeepAddress)\n        GroupSelectionSeed(_randomBeacon)\n    {\n        sortitionPoolFactory = BondedSortitionPoolFactory(\n            _sortitionPoolFactory\n        );\n        tokenStaking = TokenStaking(_tokenStaking);\n        keepBonding = KeepBonding(_keepBonding);\n    }\n\n    /// @notice Sets the minimum bondable value required from the operator to\n    /// join the sortition pool of the given application. It is up to the\n    /// application to specify a reasonable minimum bond for operators trying to\n    /// join the pool to prevent griefing by operators joining without enough\n    /// bondable value.\n    /// @param _minimumBondableValue The minimum bond value the application\n    /// requires from a single keep.\n    /// @param _groupSize Number of signers in the keep.\n    /// @param _honestThreshold Minimum number of honest keep signers.\n    function setMinimumBondableValue(\n        uint256 _minimumBondableValue,\n        uint256 _groupSize,\n        uint256 _honestThreshold\n    ) external {\n        uint256 memberBond = bondPerMember(_minimumBondableValue, _groupSize);\n        BondedSortitionPool(getSortitionPool(msg.sender))\n            .setMinimumBondableValue(memberBond);\n    }\n\n    /// @notice Opens a new ECDSA keep.\n    /// @dev Selects a list of signers for the keep based on provided parameters.\n    /// A caller of this function is expected to be an application for which\n    /// member candidates were registered in a pool.\n    /// @param _groupSize Number of signers in the keep.\n    /// @param _honestThreshold Minimum number of honest keep signers.\n    /// @param _owner Address of the keep owner.\n    /// @param _bond Value of ETH bond required from the keep in wei.\n    /// @param _stakeLockDuration Stake lock duration in seconds.\n    /// @return Created keep address.\n    function openKeep(\n        uint256 _groupSize,\n        uint256 _honestThreshold,\n        address _owner,\n        uint256 _bond,\n        uint256 _stakeLockDuration\n    ) external payable nonReentrant returns (address keepAddress) {\n        require(_groupSize > 0, \"Minimum signing group size is 1\");\n        require(_groupSize <= 16, \"Maximum signing group size is 16\");\n        require(\n            _honestThreshold > 0,\n            \"Honest threshold must be greater than 0\"\n        );\n        require(\n            _honestThreshold <= _groupSize,\n            \"Honest threshold must be less or equal the group size\"\n        );\n\n        address application = msg.sender;\n        address pool = getSortitionPool(application);\n\n        uint256 memberBond = bondPerMember(_bond, _groupSize);\n        require(memberBond > 0, \"Bond per member must be greater than zero\");\n\n        require(\n            msg.value >= openKeepFeeEstimate(),\n            \"Insufficient payment for opening a new keep\"\n        );\n\n        uint256 minimumStake = tokenStaking.minimumStake();\n\n        address[] memory members = BondedSortitionPool(pool).selectSetGroup(\n            _groupSize,\n            bytes32(groupSelectionSeed),\n            minimumStake,\n            memberBond\n        );\n\n        newGroupSelectionSeed();\n\n        // createKeep sets keepOpenedTimestamp value for newly created keep which\n        // is required to be set before calling `keep.initialize` function as it\n        // is used to determine token staking delegation authority recognition\n        // in `__isRecognized` function.\n        keepAddress = createKeep();\n\n        BondedECDSAKeep(keepAddress).initialize(\n            _owner,\n            members,\n            _honestThreshold,\n            minimumStake,\n            _stakeLockDuration,\n            address(tokenStaking),\n            address(keepBonding),\n            address(this)\n        );\n\n        for (uint256 i = 0; i < _groupSize; i++) {\n            keepBonding.createBond(\n                members[i],\n                keepAddress,\n                uint256(keepAddress),\n                memberBond,\n                pool\n            );\n        }\n\n        emit BondedECDSAKeepCreated(\n            keepAddress,\n            members,\n            _owner,\n            application,\n            _honestThreshold\n        );\n    }\n\n    /// @notice Verifies if delegates authority recipient is valid address recognized\n    /// by the factory for token staking authority delegation.\n    /// @param _delegatedAuthorityRecipient Address of the delegated authority\n    /// recipient.\n    /// @return True if provided address is recognized delegated token staking\n    /// authority for this factory contract.\n    function __isRecognized(address _delegatedAuthorityRecipient)\n        external\n        returns (bool)\n    {\n        return keepOpenedTimestamp[_delegatedAuthorityRecipient] > 0;\n    }\n\n    /// @notice Gets a fee estimate for opening a new keep.\n    /// @return Uint256 estimate.\n    function openKeepFeeEstimate() public view returns (uint256) {\n        return newEntryFeeEstimate();\n    }\n\n    /// @notice Checks if the specified account has enough active stake to become\n    /// network operator and that this contract has been authorized for potential\n    /// slashing.\n    ///\n    /// Having the required minimum of active stake makes the operator eligible\n    /// to join the network. If the active stake is not currently undelegating,\n    /// operator is also eligible for work selection.\n    ///\n    /// @param _operator operator's address\n    /// @return True if has enough active stake to participate in the network,\n    /// false otherwise.\n    function hasMinimumStake(address _operator) public view returns (bool) {\n        return tokenStaking.hasMinimumStake(_operator, address(this));\n    }\n\n    /// @notice Checks if the factory has the authorization to operate on stake\n    /// represented by the provided operator.\n    ///\n    /// @param _operator operator's address\n    /// @return True if the factory has access to the staked token balance of\n    /// the provided operator and can slash that stake. False otherwise.\n    function isOperatorAuthorized(address _operator)\n        public\n        view\n        returns (bool)\n    {\n        return tokenStaking.isAuthorizedForOperator(_operator, address(this));\n    }\n\n    /// @notice Gets the stake balance of the specified operator.\n    /// @param _operator The operator to query the balance of.\n    /// @return An uint256 representing the amount staked by the passed operator.\n    function balanceOf(address _operator) public view returns (uint256) {\n        return tokenStaking.balanceOf(_operator);\n    }\n\n    function newSortitionPool(address _application) internal returns (address) {\n        return\n            sortitionPoolFactory.createSortitionPool(\n                IStaking(address(tokenStaking)),\n                IBonding(address(keepBonding)),\n                tokenStaking.minimumStake(),\n                minimumBond,\n                poolStakeWeightDivisor\n            );\n    }\n\n    /// @notice Calculates bond requirement per member performing the necessary\n    /// rounding.\n    /// @param _keepBond The bond required from a keep.\n    /// @param _groupSize Number of signers in the keep.\n    /// @return Bond value required from each keep member.\n    function bondPerMember(uint256 _keepBond, uint256 _groupSize)\n        internal\n        pure\n        returns (uint256)\n    {\n        // In Solidity, division rounds towards zero (down) and dividing\n        // '_bond' by '_groupSize' can leave a remainder. Even though, a remainder\n        // is very small, we want to avoid this from happening and memberBond is\n        // rounded up by: `(bond + groupSize - 1 ) / groupSize`\n        // Ex. (100 + 3 - 1) / 3 = 34\n        return (_keepBond.add(_groupSize).sub(1)).div(_groupSize);\n    }\n}\n"
    },
    "solidity/contracts/KeepBonding.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"./AbstractBonding.sol\";\n\nimport \"@keep-network/keep-core/contracts/TokenGrant.sol\";\nimport \"@keep-network/keep-core/contracts/libraries/RolesLookup.sol\";\n\n/// @title Keep Bonding\n/// @notice Contract holding deposits from keeps' operators.\ncontract KeepBonding is AbstractBonding {\n    using RolesLookup for address payable;\n\n    // KEEP Token Staking contract.\n    TokenStaking internal tokenStaking;\n\n    // KEEP token grant contract.\n    TokenGrant internal tokenGrant;\n\n    /// @notice Initializes Keep Bonding contract.\n    /// @param registryAddress Keep registry contract address.\n    /// @param tokenStakingAddress KEEP token staking contract address.\n    /// @param tokenGrantAddress KEEP token grant contract address.\n    constructor(\n        address registryAddress,\n        address tokenStakingAddress,\n        address tokenGrantAddress\n    ) public AbstractBonding(registryAddress) {\n        tokenStaking = TokenStaking(tokenStakingAddress);\n        tokenGrant = TokenGrant(tokenGrantAddress);\n    }\n\n    /// @notice Withdraws amount from operator's value available for bonding.\n    /// Should not be used by grantee of managed grants. For this case,\n    /// please use `withdrawAsManagedGrantee`.\n    ///\n    /// This function can be called only by:\n    /// - operator,\n    /// - liquid, staked tokens owner (not a grant),\n    /// - direct staked tokens grantee (not a managed grant).\n    ///\n    /// @param amount Value to withdraw in wei.\n    /// @param operator Address of the operator.\n    function withdraw(uint256 amount, address operator) public {\n        require(\n            msg.sender == operator ||\n                msg.sender.isTokenOwnerForOperator(operator, tokenStaking) ||\n                msg.sender.isGranteeForOperator(operator, tokenGrant),\n            \"Only operator or the owner is allowed to withdraw bond\"\n        );\n\n        withdrawBond(amount, operator);\n    }\n\n    /// @notice Withdraws amount from operator's value available for bonding.\n    /// Can be called only by staked tokens managed grantee.\n    /// @param amount Value to withdraw in wei.\n    /// @param operator Address of the operator.\n    /// @param managedGrant Address of the managed grant contract.\n    function withdrawAsManagedGrantee(\n        uint256 amount,\n        address operator,\n        address managedGrant\n    ) public {\n        require(\n            msg.sender.isManagedGranteeForOperator(\n                operator,\n                managedGrant,\n                tokenGrant\n            ),\n            \"Only grantee is allowed to withdraw bond\"\n        );\n\n        withdrawBond(amount, operator);\n    }\n\n    function isAuthorizedForOperator(\n        address _operator,\n        address _operatorContract\n    ) public view returns (bool) {\n        return\n            tokenStaking.isAuthorizedForOperator(_operator, _operatorContract);\n    }\n\n    function authorizerOf(address _operator) public view returns (address) {\n        return tokenStaking.authorizerOf(_operator);\n    }\n\n    function beneficiaryOf(address _operator)\n        public\n        view\n        returns (address payable)\n    {\n        return tokenStaking.beneficiaryOf(_operator);\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/TokenGrant.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./libraries/grant/UnlockingSchedule.sol\";\nimport \"./utils/BytesLib.sol\";\nimport \"./utils/AddressArrayUtils.sol\";\nimport \"./TokenStaking.sol\";\nimport \"./TokenGrantStake.sol\";\nimport \"./GrantStakingPolicy.sol\";\n\n\n/// @title TokenGrant\n/// @notice A token grant contract for a specified standard ERC20Burnable token.\n/// Has additional functionality to stake delegate/undelegate token grants.\n/// Tokens are granted to the grantee via unlocking scheme and can be\n/// withdrawn gradually based on the unlocking schedule cliff and unlocking duration.\n/// Optionally grant can be revoked by the token grant manager.\ncontract TokenGrant {\n    using SafeMath for uint256;\n    using UnlockingSchedule for uint256;\n    using SafeERC20 for ERC20Burnable;\n    using BytesLib for bytes;\n    using AddressArrayUtils for address[];\n\n    event TokenGrantCreated(uint256 id);\n    event TokenGrantWithdrawn(uint256 indexed grantId, uint256 amount);\n    event TokenGrantStaked(uint256 indexed grantId, uint256 amount, address operator);\n    event TokenGrantRevoked(uint256 id);\n\n    event StakingContractAuthorized(address indexed grantManager, address stakingContract);\n\n    struct Grant {\n        address grantManager; // Token grant manager.\n        address grantee; // Address to which granted tokens are going to be withdrawn.\n        uint256 revokedAt; // Timestamp at which grant was revoked by the grant manager.\n        uint256 revokedAmount; // The number of tokens revoked from the grantee.\n        uint256 revokedWithdrawn; // The number of tokens returned to the grant creator.\n        bool revocable; // Whether grant manager can revoke the grant.\n        uint256 amount; // Amount of tokens to be granted.\n        uint256 duration; // Duration in seconds of the period in which the granted tokens will unlock.\n        uint256 start; // Timestamp at which the linear unlocking schedule will start.\n        uint256 cliff; // Timestamp before which no tokens will be unlocked.\n        uint256 withdrawn; // Amount that was withdrawn to the grantee.\n        uint256 staked; // Amount that was staked by the grantee.\n        GrantStakingPolicy stakingPolicy;\n    }\n\n    uint256 public numGrants;\n\n    ERC20Burnable public token;\n\n    // Staking contracts authorized by the given grant manager.\n    // grant manager -> staking contract -> authorized?\n    mapping(address => mapping (address => bool)) internal stakingContracts;\n\n    // Token grants.\n    mapping(uint256 => Grant) public grants;\n\n    // Token grants stakes.\n    mapping(address => TokenGrantStake) public grantStakes;\n\n    // Mapping of token grant IDs per particular address\n    // involved in a grant as a grantee or as a grant manager.\n    mapping(address => uint256[]) public grantIndices;\n\n    // Token grants balances. Sum of all granted tokens to a grantee.\n    // This includes granted tokens that are already unlocked and\n    // available to be withdrawn to the grantee\n    mapping(address => uint256) public balances;\n\n    // Mapping of operator addresses per particular grantee address.\n    mapping(address => address[]) public granteesToOperators;\n\n    /// @notice Creates a token grant contract for a provided Standard ERC20Burnable token.\n    /// @param _tokenAddress address of a token that will be linked to this contract.\n    constructor(address _tokenAddress) public {\n        require(_tokenAddress != address(0x0), \"Token address can't be zero.\");\n        token = ERC20Burnable(_tokenAddress);\n    }\n\n    /// @notice Used by grant manager to authorize staking contract with the given\n    /// address.\n    function authorizeStakingContract(address _stakingContract) public {\n        require(\n            _stakingContract != address(0x0),\n            \"Staking contract address can't be zero\"\n        );\n        stakingContracts[msg.sender][_stakingContract] = true;\n        emit StakingContractAuthorized(msg.sender, _stakingContract);\n    }\n\n    /// @notice Gets the amount of granted tokens to the specified address.\n    /// @param _owner The address to query the grants balance of.\n    /// @return An uint256 representing the grants balance owned by the passed address.\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    /// @notice Gets the stake balance of the specified address.\n    /// @param _address The address to query the balance of.\n    /// @return An uint256 representing the amount staked by the passed address.\n    function stakeBalanceOf(address _address) public view returns (uint256 balance) {\n        for (uint i = 0; i < grantIndices[_address].length; i++) {\n            uint256 id = grantIndices[_address][i];\n            balance += grants[id].staked;\n        }\n        return balance;\n    }\n\n    /// @notice Gets grant by ID. Returns only basic grant data.\n    /// If you need unlocking schedule for the grant you must call `getGrantUnlockingSchedule()`\n    /// This is to avoid Ethereum `Stack too deep` issue described here:\n    /// https://forum.ethereum.org/discussion/2400/error-stack-too-deep-try-removing-local-variables\n    /// @param _id ID of the token grant.\n    /// @return amount The amount of tokens the grant provides.\n    /// @return withdrawn The amount of tokens that have already been withdrawn\n    ///                   from the grant.\n    /// @return staked The amount of tokens that have been staked from the grant.\n    /// @return revoked A boolean indicating whether the grant has been revoked,\n    ///                 which is to say that it is no longer unlocking.\n    /// @return grantee The grantee of grant.\n    function getGrant(uint256 _id) public view returns (\n        uint256 amount,\n        uint256 withdrawn,\n        uint256 staked,\n        uint256 revokedAmount,\n        uint256 revokedAt,\n        address grantee\n    ) {\n        return (\n            grants[_id].amount,\n            grants[_id].withdrawn,\n            grants[_id].staked,\n            grants[_id].revokedAmount,\n            grants[_id].revokedAt,\n            grants[_id].grantee\n        );\n    }\n\n    /// @notice Gets grant unlocking schedule by grant ID.\n    /// @param _id ID of the token grant.\n    /// @return grantManager The address designated as the manager of the grant,\n    ///                      which is the only address that can revoke this grant.\n    /// @return duration The duration, in seconds, during which the tokens will\n    ///                  unlocking linearly.\n    /// @return start The start time, as a timestamp comparing to `now`.\n    /// @return cliff The timestamp, before which none of the tokens in the grant\n    ///               will be unlocked, and after which a linear amount based on\n    ///               the time elapsed since the start will be unlocked.\n    /// @return policy The address of the grant's staking policy.\n    function getGrantUnlockingSchedule(\n        uint256 _id\n    ) public view returns (\n        address grantManager,\n        uint256 duration,\n        uint256 start,\n        uint256 cliff,\n        address policy\n    ) {\n        return (\n            grants[_id].grantManager,\n            grants[_id].duration,\n            grants[_id].start,\n            grants[_id].cliff,\n            address(grants[_id].stakingPolicy)\n        );\n    }\n\n    /// @notice Gets grant ids of the specified address.\n    /// @param _granteeOrGrantManager The address to query.\n    /// @return An uint256 array of grant IDs.\n    function getGrants(address _granteeOrGrantManager) public view returns (uint256[] memory) {\n        return grantIndices[_granteeOrGrantManager];\n    }\n\n    /// @notice Gets operator addresses of the specified grantee address.\n    /// @param grantee The grantee address.\n    /// @return An array of all operators for a given grantee.\n    function getGranteeOperators(address grantee) public view returns (address[] memory) {\n        return granteesToOperators[grantee];\n    }\n\n    /// @notice Gets grant stake details of the given operator.\n    /// @param operator The operator address.\n    /// @return grantId ID of the token grant.\n    /// @return amount The amount of tokens the given operator delegated.\n    /// @return stakingContract The address of staking contract.\n    function getGrantStakeDetails(address operator) public view returns (uint256 grantId, uint256 amount, address stakingContract) {\n        return grantStakes[operator].getDetails();\n    }\n\n\n    /// @notice Receives approval of token transfer and creates a token grant with a unlocking\n    /// schedule where balance withdrawn to the grantee gradually in a linear fashion until\n    /// start + duration. By then all of the balance will have unlocked.\n    /// @param _from The owner of the tokens who approved them to transfer.\n    /// @param _amount Approved amount for the transfer to create token grant.\n    /// @param _token Token contract address.\n    /// @param _extraData This byte array must have the following values ABI encoded:\n    /// grantManager (address) Address of the grant manager.\n    /// grantee (address) Address of the grantee.\n    /// duration (uint256) Duration in seconds of the unlocking period.\n    /// start (uint256) Timestamp at which unlocking will start.\n    /// cliffDuration (uint256) Duration in seconds of the cliff;\n    ///               no tokens will be unlocked until the time `start + cliff`.\n    /// revocable (bool) Whether the token grant is revocable or not (1 or 0).\n    /// stakingPolicy (address) Address of the staking policy for the grant.\n    function receiveApproval(address _from, uint256 _amount, address _token, bytes memory _extraData) public {\n        require(ERC20Burnable(_token) == token, \"Token contract must be the same one linked to this contract.\");\n        require(_amount <= token.balanceOf(_from), \"Sender must have enough amount.\");\n        (address _grantManager,\n         address _grantee,\n         uint256 _duration,\n         uint256 _start,\n         uint256 _cliffDuration,\n         bool _revocable,\n         address _stakingPolicy) = abi.decode(\n             _extraData,\n             (address, address, uint256, uint256, uint256, bool, address)\n        );\n\n        require(_grantee != address(0), \"Grantee address can't be zero.\");\n        require(\n            _cliffDuration <= _duration,\n            \"Unlocking cliff duration must be less or equal total unlocking duration.\"\n        );\n\n        require(_stakingPolicy != address(0), \"Staking policy can't be zero.\");\n\n        uint256 id = numGrants++;\n        grants[id] = Grant(\n            _grantManager,\n            _grantee,\n            0, 0, 0,\n            _revocable,\n            _amount,\n            _duration,\n            _start,\n            _start.add(_cliffDuration),\n            0, 0,\n            GrantStakingPolicy(_stakingPolicy)\n        );\n\n        // Maintain a record to make it easier to query grants by grant manager.\n        grantIndices[_from].push(id);\n\n        // Maintain a record to make it easier to query grants by grantee.\n        grantIndices[_grantee].push(id);\n\n        token.safeTransferFrom(_from, address(this), _amount);\n\n        // Maintain a record of the unlocked amount\n        balances[_grantee] = balances[_grantee].add(_amount);\n        emit TokenGrantCreated(id);\n    }\n\n    /// @notice Withdraws Token grant amount to grantee.\n    /// @dev Transfers unlocked tokens of the token grant to grantee.\n    /// @param _id Grant ID.\n    function withdraw(uint256 _id) public {\n        uint256 amount = withdrawable(_id);\n        require(amount > 0, \"Grant available to withdraw amount should be greater than zero.\");\n\n        // Update withdrawn amount.\n        grants[_id].withdrawn = grants[_id].withdrawn.add(amount);\n\n        // Update grantee grants balance.\n        balances[grants[_id].grantee] = balances[grants[_id].grantee].sub(amount);\n\n        // Transfer tokens from this contract balance to the grantee token balance.\n        token.safeTransfer(grants[_id].grantee, amount);\n\n        emit TokenGrantWithdrawn(_id, amount);\n    }\n\n    /// @notice Calculates and returns unlocked grant amount.\n    /// @dev Calculates token grant amount that has already unlocked,\n    /// including any tokens that have already been withdrawn by the grantee as well\n    /// as any tokens that are available to withdraw but have not yet been withdrawn.\n    /// @param _id Grant ID.\n    function unlockedAmount(uint256 _id) public view returns (uint256) {\n        Grant storage grant = grants[_id];\n        return (grant.revokedAt != 0)\n            // Grant revoked -> return what is remaining\n            ? grant.amount.sub(grant.revokedAmount)\n            // Not revoked -> calculate the unlocked amount normally\n            : now.getUnlockedAmount(\n                grant.amount,\n                grant.duration,\n                grant.start,\n                grant.cliff\n            );\n    }\n\n    /// @notice Calculates withdrawable granted amount.\n    /// @dev Calculates the amount that has already unlocked but hasn't been withdrawn yet.\n    /// @param _id Grant ID.\n    function withdrawable(uint256 _id) public view returns (uint256) {\n        uint256 unlocked = unlockedAmount(_id);\n        uint256 withdrawn = grants[_id].withdrawn;\n        uint256 staked = grants[_id].staked;\n\n        if (withdrawn.add(staked) >= unlocked) {\n            return 0;\n        } else {\n            return unlocked.sub(withdrawn).sub(staked);\n        }\n    }\n\n    /// @notice Allows the grant manager to revoke the grant.\n    /// @dev Granted tokens that are already unlocked (releasable amount)\n    /// remain in the grant so grantee can still withdraw them\n    /// the rest are revoked and withdrawable by token grant manager.\n    /// @param _id Grant ID.\n    function revoke(uint256 _id) public {\n        require(grants[_id].grantManager == msg.sender, \"Only grant manager can revoke.\");\n        require(grants[_id].revocable, \"Grant must be revocable in the first place.\");\n        require(grants[_id].revokedAt == 0, \"Grant must not be already revoked.\");\n\n        uint256 unlockedAmount = unlockedAmount(_id);\n        uint256 revokedAmount = grants[_id].amount.sub(unlockedAmount);\n        grants[_id].revokedAt = now;\n        grants[_id].revokedAmount = revokedAmount;\n\n        // Update grantee's grants balance.\n        balances[grants[_id].grantee] = balances[grants[_id].grantee].sub(revokedAmount);\n        emit TokenGrantRevoked(_id);\n    }\n\n    /// @notice Allows the grant manager to withdraw revoked tokens.\n    /// @dev Will withdraw as many of the revoked tokens as possible\n    /// without pushing the grant contract into a token deficit.\n    /// If the grantee has staked more tokens than the unlocked amount,\n    /// those tokens will remain in the grant until undelegated and returned,\n    /// after which they can be withdrawn by calling `withdrawRevoked` again.\n    /// @param _id Grant ID.\n    function withdrawRevoked(uint256 _id) public {\n        Grant storage grant = grants[_id];\n        require(\n            grant.grantManager == msg.sender,\n            \"Only grant manager can withdraw revoked tokens.\"\n        );\n        uint256 revoked = grant.revokedAmount;\n        uint256 revokedWithdrawn = grant.revokedWithdrawn;\n        require(revokedWithdrawn < revoked, \"All revoked tokens withdrawn.\");\n\n        uint256 revokedRemaining = revoked.sub(revokedWithdrawn);\n\n        uint256 totalAmount = grant.amount;\n        uint256 staked = grant.staked;\n        uint256 granteeWithdrawn = grant.withdrawn;\n        uint256 remainingPresentInGrant =\n            totalAmount.sub(staked).sub(revokedWithdrawn).sub(granteeWithdrawn);\n\n        require(remainingPresentInGrant > 0, \"No revoked tokens withdrawable.\");\n\n        uint256 amountToWithdraw = remainingPresentInGrant < revokedRemaining\n            ? remainingPresentInGrant\n            : revokedRemaining;\n        token.safeTransfer(msg.sender, amountToWithdraw);\n        grant.revokedWithdrawn += amountToWithdraw;\n    }\n\n    /// @notice Stake token grant.\n    /// @dev Stakable token grant amount is determined\n    /// by the grant's staking policy.\n    /// @param _id Grant Id.\n    /// @param _stakingContract Address of the staking contract.\n    /// @param _amount Amount to stake.\n    /// @param _extraData Data for stake delegation. This byte array must have\n    /// the following values concatenated:\n    /// - Beneficiary address (20 bytes)\n    /// - Operator address (20 bytes)\n    /// - Authorizer address (20 bytes)\n    function stake(uint256 _id, address _stakingContract, uint256 _amount, bytes memory _extraData) public {\n        require(grants[_id].grantee == msg.sender, \"Only grantee of the grant can stake it.\");\n        require(grants[_id].revokedAt == 0, \"Revoked grant can not be staked\");\n        require(\n            stakingContracts[grants[_id].grantManager][_stakingContract],\n            \"Provided staking contract is not authorized.\"\n        );\n\n        // Expecting 60 bytes _extraData for stake delegation.\n        require(_extraData.length == 60, \"Stake delegation data must be provided.\");\n        address operator = _extraData.toAddress(20);\n\n        // Calculate available amount. Amount of unlocked tokens minus what user already withdrawn and staked.\n        require(_amount <= availableToStake(_id), \"Must have available granted amount to stake.\");\n\n        // Keep staking record.\n        TokenGrantStake grantStake = new TokenGrantStake(\n            address(token),\n            _id,\n            _stakingContract\n        );\n        grantStakes[operator] = grantStake;\n        granteesToOperators[grants[_id].grantee].push(operator);\n        grants[_id].staked += _amount;\n\n        token.transfer(address(grantStake), _amount);\n\n        // Staking contract expects 40 bytes _extraData for stake delegation.\n        // 20 bytes beneficiary's address + 20 bytes operator's address.\n        grantStake.stake(_amount, _extraData);\n        emit TokenGrantStaked(_id, _amount, operator);\n    }\n\n    ///  @notice Returns the amount of tokens available for staking from the grant.\n    /// The stakeable amount is determined by the staking policy of the grant.\n    /// If the grantee has withdrawn some tokens\n    /// or the policy returns an erroneously high value,\n    /// the stakeable amount is limited to the number of tokens remaining.\n    /// @param _grantId Identifier of the grant\n    function availableToStake(uint256 _grantId) public view returns (uint256) {\n        Grant storage grant = grants[_grantId];\n        // Revoked grants cannot be staked.\n        // If the grant isn't revoked, the number of revoked tokens is 0.\n        if (grant.revokedAt != 0) { return 0; }\n        uint256 amount = grant.amount;\n        uint256 withdrawn = grant.withdrawn;\n        uint256 remaining = amount.sub(withdrawn);\n        uint256 stakeable = grant.stakingPolicy.getStakeableAmount(\n            now,\n            amount,\n            grant.duration,\n            grant.start,\n            grant.cliff,\n            withdrawn\n        );\n        // Clamp the stakeable amount to what is left in the grant\n        // in the case of a malfunctioning staking policy.\n        if (stakeable > remaining) {\n            stakeable = remaining;\n        }\n\n        return stakeable.sub(grant.staked);\n    }\n\n    /// @notice Cancels delegation within the operator initialization period\n    /// without being subjected to the stake lockup for the undelegation period.\n    /// This can be used to undo mistaken delegation to the wrong operator address.\n    /// @param _operator Address of the stake operator.\n    function cancelStake(address _operator) public {\n        TokenGrantStake grantStake = grantStakes[_operator];\n        uint256 grantId = grantStake.getGrantId();\n        require(\n            msg.sender == _operator || msg.sender == grants[grantId].grantee,\n            \"Only operator or grantee can cancel the delegation.\"\n        );\n\n        uint256 returned = grantStake.cancelStake();\n        grants[grantId].staked = grants[grantId].staked.sub(returned);\n    }\n\n    /// @notice Undelegate the token grant.\n    /// @param _operator Operator of the stake.\n    function undelegate(address _operator) public {\n        TokenGrantStake grantStake = grantStakes[_operator];\n        uint256 grantId = grantStake.getGrantId();\n        require(\n            msg.sender == _operator || msg.sender == grants[grantId].grantee,\n            \"Only operator or grantee can undelegate.\"\n        );\n\n        grantStake.undelegate();\n    }\n\n    /// @notice Force cancellation of a revoked grant's stake.\n    /// Can be used by the grant manager\n    /// to immediately withdraw tokens back into the grant,\n    /// from an operator still within the initialization period.\n    /// These tokens can then be withdrawn\n    /// if some revoked tokens haven't been withdrawn yet.\n    function cancelRevokedStake(address _operator) public {\n        TokenGrantStake grantStake = grantStakes[_operator];\n        uint256 grantId = grantStake.getGrantId();\n        require(\n            grants[grantId].revokedAt != 0,\n            \"Grant must be revoked\"\n        );\n        require(\n            msg.sender == grants[grantId].grantManager,\n            \"Only grant manager can force cancellation of revoked grant stake.\"\n        );\n\n        uint256 returned = grantStake.cancelStake();\n        grants[grantId].staked = grants[grantId].staked.sub(returned);\n    }\n\n    /// @notice Force undelegation of a revoked grant's stake.\n    /// @dev Can be called by the grant manager once the grant is revoked.\n    /// Has to be done this way, instead of undelegating all operators when the\n    /// grant is revoked, because the latter method is vulnerable to DoS via\n    /// out-of-gas.\n    function undelegateRevoked(address _operator) public {\n        TokenGrantStake grantStake = grantStakes[_operator];\n        uint256 grantId = grantStake.getGrantId();\n        require(\n            grants[grantId].revokedAt != 0,\n            \"Grant must be revoked\"\n        );\n        require(\n            msg.sender == grants[grantId].grantManager,\n            \"Only grant manager can force undelegation of revoked grant stake\"\n        );\n\n        grantStake.undelegate();\n    }\n\n    /// @notice Recover stake of the token grant.\n    /// Recovers the tokens correctly\n    /// even if they were earlier recovered directly in the staking contract.\n    /// @param _operator Operator of the stake.\n    function recoverStake(address _operator) public {\n        TokenGrantStake grantStake = grantStakes[_operator];\n        uint256 returned = grantStake.recoverStake();\n        uint256 grantId = grantStake.getGrantId();\n        grants[grantId].staked = grants[grantId].staked.sub(returned);\n\n        delete grantStakes[_operator];\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of `ERC20` that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\ncontract ERC20Burnable is ERC20 {\n    /**\n     * @dev Destoys `amount` tokens from the caller.\n     *\n     * See `ERC20._burn`.\n     */\n    function burn(uint256 amount) public {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @dev See `ERC20._burnFrom`.\n     */\n    function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/libraries/grant/UnlockingSchedule.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nlibrary UnlockingSchedule {\n    using SafeMath for uint256;\n\n    function getUnlockedAmount(\n        uint256 _now,\n        uint256 grantedAmount,\n        uint256 duration,\n        uint256 start,\n        uint256 cliff\n    ) internal pure returns (uint256) {\n        bool cliffNotReached = _now < cliff;\n        if (cliffNotReached) { return 0; }\n\n        uint256 timeElapsed = _now.sub(start);\n\n        bool unlockingPeriodFinished = timeElapsed >= duration;\n        if (unlockingPeriodFinished) { return grantedAmount; }\n\n        return grantedAmount.mul(timeElapsed).div(duration);\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/utils/BytesLib.sol": {
      "content": "pragma solidity 0.5.17;\n\n/*\nVerison pulled from https://github.com/summa-tx/bitcoin-spv/blob/2535e4edaeaac4b2b095903fce684ae1c05761bc/solidity/contracts/BytesLib.sol\n*/\n\n/*\nhttps://github.com/GNSPS/solidity-bytes-utils/\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\nFor more information, please refer to <https://unlicense.org>\n*/\n\n\n/** @title BytesLib **/\n/** @author https://github.com/GNSPS **/\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n                add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes_slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                        ),\n                        // and now shift left the number of bytes to\n                        // leave space for the length in the slot\n                        exp(0x100, sub(32, newlength))\n                        ),\n                        // increase length by the double of the memory\n                        // bytes length\n                        mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                    ),\n                    and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(bytes memory _bytes, uint _start, uint _length) internal  pure returns (bytes memory res) {\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            // Alloc bytes array with additional 32 bytes afterspace and assign it's size\n            res := mload(0x40)\n            mstore(0x40, add(add(res, 64), _length))\n            mstore(res, _length)\n\n            // Compute distance between source and destination pointers\n            let diff := sub(res, add(_bytes, _start))\n\n            for {\n                let src := add(add(_bytes, 32), _start)\n                let end := add(src, _length)\n            } lt(src, end) {\n                src := add(src, 32)\n            } {\n                mstore(add(src, diff), mload(src))\n            }\n        }\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n        uint _totalLen = _start + 20;\n        require(_totalLen > _start && _bytes.length >= _totalLen, \"Address conversion out of bounds.\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\n        require(_bytes.length >= (_start + 1), \"Uint8 conversion out of bounds.\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n        uint _totalLen = _start + 32;\n        require(_totalLen > _start && _bytes.length >= _totalLen, \"Uint conversion out of bounds.\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function toBytes32(bytes memory _source) pure internal returns (bytes32 result) {\n        if (_source.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(_source, 32))\n        }\n    }\n\n    function keccak256Slice(bytes memory _bytes, uint _start, uint _length) pure internal returns (bytes32 result) {\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            result := keccak256(add(add(_bytes, 32), _start), _length)\n        }\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/TokenStaking.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./StakeDelegatable.sol\";\nimport \"./libraries/staking/MinimumStakeSchedule.sol\";\nimport \"./libraries/staking/GrantStaking.sol\";\nimport \"./libraries/staking/Locks.sol\";\nimport \"./libraries/staking/TopUps.sol\";\nimport \"./utils/PercentUtils.sol\";\nimport \"./utils/BytesLib.sol\";\nimport \"./Authorizations.sol\";\nimport \"./TokenStakingEscrow.sol\";\nimport \"./TokenSender.sol\";\n\n\n/// @title TokenStaking\n/// @notice A token staking contract for a specified standard ERC20Burnable token.\n/// A holder of the specified token can stake delegate its tokens to this contract\n/// and recover the stake after undelegation period is over.\ncontract TokenStaking is Authorizations, StakeDelegatable {\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n    using PercentUtils for uint256;\n    using SafeERC20 for ERC20Burnable;\n    using GrantStaking for GrantStaking.Storage;\n    using Locks for Locks.Storage;\n    using TopUps for TopUps.Storage;\n\n    event StakeDelegated(\n        address indexed owner,\n        address indexed operator\n    );\n    event OperatorStaked(\n        address indexed operator,\n        address indexed beneficiary,\n        address indexed authorizer,\n        uint256 value\n    );\n    event StakeOwnershipTransferred(\n        address indexed operator,\n        address indexed newOwner\n    );\n    event TopUpInitiated(address indexed operator, uint256 topUp);\n    event TopUpCompleted(address indexed operator, uint256 newAmount);\n    event Undelegated(address indexed operator, uint256 undelegatedAt);\n    event RecoveredStake(address operator);\n    event TokensSlashed(address indexed operator, uint256 amount);\n    event TokensSeized(address indexed operator, uint256 amount);\n    event StakeLocked(address indexed operator, address lockCreator, uint256 until);\n    event LockReleased(address indexed operator, address lockCreator);\n    event ExpiredLockReleased(address indexed operator, address lockCreator);\n\n    uint256 public deployedAt;\n    uint256 public initializationPeriod; // varies between mainnet and testnet\n\n    ERC20Burnable internal token;\n    TokenGrant internal tokenGrant;\n    TokenStakingEscrow internal escrow;\n\n    GrantStaking.Storage internal grantStaking;\n    Locks.Storage internal locks;\n    TopUps.Storage internal topUps;\n\n    uint256 internal constant twoWeeks = 1209600; // [sec]\n    uint256 internal constant twoMonths = 5184000; // [sec]\n\n    // 2020-04-28; the date of deploying KEEP token.\n    // TX:  0xea22d72bc7de4c82798df7194734024a1f2fd57b173d0e065864ff4e9d3dc014\n    uint256 internal constant minimumStakeScheduleStart = 1588042366;\n\n    /// @notice Creates a token staking contract for a provided Standard ERC20Burnable token.\n    /// @param _token KEEP token contract.\n    /// @param _tokenGrant KEEP token grant contract.\n    /// @param _escrow Escrow dedicated for this staking contract.\n    /// @param _registry Keep contract registry contract.\n    /// @param _initializationPeriod To avoid certain attacks on work selection, recently created\n    /// operators must wait for a specific period of time before being eligible for work selection.\n    constructor(\n        ERC20Burnable _token,\n        TokenGrant _tokenGrant,\n        TokenStakingEscrow _escrow,\n        KeepRegistry _registry,\n        uint256 _initializationPeriod\n    ) Authorizations(_registry) public {\n        token = _token;\n        tokenGrant = _tokenGrant;\n        escrow = _escrow;\n        registry = _registry;\n        initializationPeriod = _initializationPeriod;\n        deployedAt = block.timestamp;\n    }\n\n    /// @notice Returns minimum amount of KEEP that allows sMPC cluster client to\n    /// participate in the Keep network. Expressed as number with 18-decimal places.\n    /// Initial minimum stake is higher than the final and lowered periodically based\n    /// on the amount of steps and the length of the minimum stake schedule in seconds.\n    function minimumStake() public view returns (uint256) {\n        return MinimumStakeSchedule.current(minimumStakeScheduleStart);\n    }\n\n    /// @notice Returns the current value of the undelegation period.\n    /// The staking contract guarantees that an undelegated operator’s stakes\n    /// will stay locked for a period of time after undelegation, and thus\n    /// available as collateral for any work the operator is engaged in.\n    /// The undelegation period is two weeks for the first two months and\n    /// two months after that.\n    function undelegationPeriod() public view returns(uint256) {\n        return block.timestamp < deployedAt.add(twoMonths) ? twoWeeks : twoMonths;\n    }\n\n    /// @notice Receives approval of token transfer and stakes the approved\n    /// amount or adds the approved amount to an existing delegation (a “top-up”).\n    /// In case of a top-up, it is expected that the operator stake is not\n    /// undelegated and that the top-up is performed from the same source of\n    /// tokens as the initial delegation. That is, if the tokens were delegated\n    /// from a grant, top-up has to be performed from the same grant. If the\n    /// delegation was done using liquid tokens, only liquid tokens from the\n    /// same owner can be used to top-up the stake.\n    /// Top-up can not be cancelled so it is important to be careful with the\n    /// amount of KEEP added to the stake.\n    /// @dev Requires that the provided token contract be the same one linked to\n    /// this contract.\n    /// @param _from The owner of the tokens who approved them to transfer.\n    /// @param _value Approved amount for the transfer and stake.\n    /// @param _token Token contract address.\n    /// @param _extraData Data for stake delegation. This byte array must have\n    /// the following values concatenated:\n    /// - Beneficiary address (20 bytes), ignored for a top-up\n    /// - Operator address (20 bytes)\n    /// - Authorizer address (20 bytes), ignored for a top-up\n    /// - Grant ID (32 bytes) - required only when called by TokenStakingEscrow\n    function receiveApproval(\n        address _from,\n        uint256 _value,\n        address _token,\n        bytes memory _extraData\n    ) public {\n        require(ERC20Burnable(_token) == token, \"Unrecognized token\");\n        require(_extraData.length >= 60, \"Corrupted delegation data\");\n\n        // Transfer tokens to this contract.\n        token.safeTransferFrom(_from, address(this), _value);\n\n        address operator = _extraData.toAddress(20);\n        // See if there is an existing delegation for this operator...\n        if (operators[operator].packedParams.getCreationTimestamp() == 0) {\n            // If there is no existing delegation, delegate tokens using\n            // beneficiary and authorizer passed in _extraData.\n            delegate(_from, _value, operator, _extraData);\n        } else {\n            // If there is an existing delegation, top-up the stake.\n            topUp(_from, _value, operator, _extraData);\n        }\n    }\n\n    /// @notice Delegates tokens to a new operator using beneficiary and\n    /// authorizer passed in _extraData parameter.\n    /// @param _from The owner of the tokens who approved them to transfer.\n    /// @param _value Approved amount for the transfer and stake.\n    /// @param _operator The new operator address.\n    /// @param _extraData Data for stake delegation as passed to receiveApproval.\n    function delegate(\n        address _from,\n        uint256 _value,\n        address _operator,\n        bytes memory _extraData\n    ) internal {\n        require(_value >= minimumStake(), \"Less than the minimum stake\");\n        \n        address payable beneficiary = address(uint160(_extraData.toAddress(0)));\n        address authorizer = _extraData.toAddress(40);\n\n        operators[_operator] = Operator(\n            OperatorParams.pack(_value, block.timestamp, 0),\n            _from,\n            beneficiary,\n            authorizer\n        );\n\n        grantStaking.tryCapturingDelegationData(\n            tokenGrant,\n            address(escrow),\n            _from,\n            _operator,\n            _extraData\n        );\n\n        emit StakeDelegated(_from, _operator);\n        emit OperatorStaked(_operator, beneficiary, authorizer, _value);\n    }\n\n    /// @notice Performs top-up to an existing operator. Tokens added during\n    /// stake initialization period are immediatelly added to the stake and\n    /// stake initialization timer is reset to the current block. Tokens added\n    /// in a top-up after the stake initialization period is over are not\n    /// included in the operator stake until the initialization period for\n    /// a top-up passes and top-up is committed. Operator must not have the stake\n    /// undelegated. It is expected that the top-up is done from the same source\n    /// of tokens as the initial delegation. That is, if the tokens were\n    /// delegated from a grant, top-up has to be performed from the same grant.\n    /// If the delegation was done using liquid tokens, only liquid tokens from\n    /// the same owner can be used to top-up the stake.\n    /// Top-up can not be cancelled so it is important to be careful with the\n    /// amount of KEEP added to the stake.\n    /// @param _from The owner of the tokens who approved them to transfer.\n    /// @param _value Approved amount for the transfer and top-up to\n    /// an existing stake.\n    /// @param _operator The new operator address.\n    /// @param _extraData Data for stake delegation as passed to receiveApproval\n    function topUp(\n        address _from,\n        uint256 _value,\n        address _operator,\n        bytes memory _extraData\n    ) internal {\n        // Top-up comes from a grant if it's been initiated from TokenGrantStake\n        // contract or if it's been initiated from TokenStakingEscrow by\n        // redelegation.\n        bool isFromGrant = address(tokenGrant.grantStakes(_operator)) == _from ||\n            address(escrow) == _from;\n\n        if (grantStaking.hasGrantDelegated(_operator)) {\n            // Operator has grant delegated. We need to see if the top-up\n            // is performed also from a grant.\n            require(isFromGrant, \"Must be from a grant\");\n            // If it is from a grant, we need to make sure it's from the same\n            // grant as the original delegation. We do not want to mix unlocking\n            // schedules.\n            uint256 previousGrantId = grantStaking.getGrantForOperator(_operator);\n            (, uint256 grantId) = grantStaking.tryCapturingDelegationData(\n                tokenGrant, address(escrow), _from, _operator, _extraData\n            );\n            require(grantId == previousGrantId, \"Not the same grant\");\n        } else {\n            // Operator has no grant delegated. We need to see if the top-up\n            // is performed from liquid tokens of the same owner.\n            require(!isFromGrant, \"Must not be from a grant\");\n            require(operators[_operator].owner == _from, \"Not the same owner\");\n        }\n\n        uint256 operatorParams = operators[_operator].packedParams;\n        if (!_isInitialized(operatorParams)) {\n            // If the stake is not yet initialized, we add tokens immediately\n            // but we also reset stake initialization time counter.\n            operators[_operator].packedParams = topUps.instantComplete(\n                _value, _operator, operatorParams, escrow\n            );\n        } else {\n            // If the stake is initialized, we do NOT add tokens immediately.\n            // We initiate the top-up and will add tokens to the stake only\n            // after the initialization period for a top-up passes.\n            topUps.initiate(_value, _operator, operatorParams, escrow);\n        }\n    }\n\n    /// @notice Commits pending top-up for the provided operator. If the top-up\n    /// did not pass the initialization period, the function fails.\n    /// @param _operator The operator with a pending top-up that is getting\n    /// committed.\n    function commitTopUp(address _operator) public {\n        operators[_operator].packedParams = topUps.commit(\n            _operator,\n            operators[_operator].packedParams,\n            initializationPeriod\n        );\n    }\n\n    /// @notice Cancels stake of tokens within the operator initialization period\n    /// without being subjected to the token lockup for the undelegation period.\n    /// This can be used to undo mistaken delegation to the wrong operator address.\n    /// @param _operator Address of the stake operator.\n    function cancelStake(address _operator) public {\n        address owner = operators[_operator].owner;\n        require(\n            msg.sender == owner ||\n            msg.sender == _operator ||\n            grantStaking.canUndelegate(_operator, tokenGrant),\n            \"Not authorized\"\n        );\n        uint256 operatorParams = operators[_operator].packedParams;\n\n        require(\n            !_isInitialized(operatorParams),\n            \"Initialized stake\"\n        );\n\n        uint256 amount = operatorParams.getAmount();\n        operators[_operator].packedParams = operatorParams.setAmount(0);\n\n        transferOrDeposit(owner, _operator, amount);\n    }\n\n    /// @notice Undelegates staked tokens. You will be able to recover your stake by calling\n    /// `recoverStake()` with operator address once undelegation period is over.\n    /// @param _operator Address of the stake operator.\n    function undelegate(address _operator) public {\n        undelegateAt(_operator, block.timestamp);\n    }\n\n    /// @notice Set an undelegation time for staked tokens.\n    /// Undelegation will begin at the specified timestamp.\n    /// You will be able to recover your stake by calling\n    /// `recoverStake()` with operator address once undelegation period is over.\n    /// @param _operator Address of the stake operator.\n    /// @param _undelegationTimestamp The timestamp undelegation is to start at.\n    function undelegateAt(\n        address _operator,\n        uint256 _undelegationTimestamp\n    ) public {\n        require(\n            msg.sender == _operator ||\n            msg.sender == operators[_operator].owner ||\n            grantStaking.canUndelegate(_operator, tokenGrant),\n            \"Not authorized\"\n        );\n        uint256 oldParams = operators[_operator].packedParams;\n        require(\n            _undelegationTimestamp >= block.timestamp &&\n            _undelegationTimestamp > oldParams.getCreationTimestamp().add(initializationPeriod),\n            \"Invalid timestamp\"\n        );\n        uint256 existingUndelegationTimestamp = oldParams.getUndelegationTimestamp();\n        require(\n            // Undelegation not in progress OR\n            existingUndelegationTimestamp == 0 ||\n            // Undelegating sooner than previously set time OR\n            existingUndelegationTimestamp > _undelegationTimestamp ||\n            // We have already checked above that msg.sender is owner, grantee,\n            // or operator. Only owner and grantee are eligible to postpone the\n            // delegation so it is enough if we exclude operator here.\n            msg.sender != _operator,\n            \"Operator may not postpone\"\n        );\n        operators[_operator].packedParams = oldParams.setUndelegationTimestamp(\n            _undelegationTimestamp\n        );\n        emit Undelegated(_operator, _undelegationTimestamp);\n    }\n\n    /// @notice Recovers staked tokens and transfers them back to the owner.\n    /// Recovering tokens can only be performed when the operator finished\n    /// undelegating.\n    /// @param _operator Operator address.\n    function recoverStake(address _operator) public {\n        uint256 operatorParams = operators[_operator].packedParams;\n        require(\n            operatorParams.getUndelegationTimestamp() != 0,\n            \"Not undelegated\"\n        );\n        require(\n            _isUndelegatingFinished(operatorParams),\n            \"Still undelegating\"\n        );\n        require(\n            !isStakeLocked(_operator),\n            \"Locked stake\"\n        );\n\n        uint256 amount = operatorParams.getAmount();\n\n        // If there is a pending top-up, force-commit it before returning tokens.\n        amount = amount.add(topUps.cancel(_operator));\n\n        operators[_operator].packedParams = operatorParams.setAmount(0);\n        transferOrDeposit(operators[_operator].owner, _operator, amount);\n\n        emit RecoveredStake(_operator);\n    }\n\n    /// @notice Gets stake delegation info for the given operator.\n    /// @param _operator Operator address.\n    /// @return amount The amount of tokens the given operator delegated.\n    /// @return createdAt The time when the stake has been delegated.\n    /// @return undelegatedAt The time when undelegation has been requested.\n    /// If undelegation has not been requested, 0 is returned.\n    function getDelegationInfo(address _operator)\n    public view returns (uint256 amount, uint256 createdAt, uint256 undelegatedAt) {\n        return operators[_operator].packedParams.unpack();\n    }\n\n    /// @notice Locks given operator stake for the specified duration.\n    /// Locked stake may not be recovered until the lock expires or is released,\n    /// even if the normal undelegation period has passed.\n    /// Only previously authorized operator contract can lock the stake.\n    /// @param operator Operator address.\n    /// @param duration Lock duration in seconds.\n    function lockStake(\n        address operator,\n        uint256 duration\n    ) public onlyApprovedOperatorContract(msg.sender) {\n        require(\n            isAuthorizedForOperator(operator, msg.sender),\n            \"Not authorized\"\n        );\n\n        uint256 operatorParams = operators[operator].packedParams;\n\n        require(\n            _isInitialized(operatorParams),\n            \"Inactive stake\"\n        );\n        require(\n            !_isUndelegating(operatorParams),\n            \"Undelegating stake\"\n        );\n\n        locks.lockStake(operator, duration);\n    }\n\n    /// @notice Removes a lock the caller had previously placed on the operator.\n    /// @dev Only for operator contracts.\n    /// To remove expired or disabled locks, use `releaseExpiredLocks`.\n    /// The authorization check ensures that the caller must have been able\n    /// to place a lock on the operator sometime in the past.\n    /// We don't need to check for current approval status of the caller\n    /// because unlocking stake cannot harm the operator\n    /// nor interfere with other operator contracts.\n    /// Therefore even disabled operator contracts may freely unlock stake.\n    /// @param operator Operator address.\n    function unlockStake(\n        address operator\n    ) public {\n        require(\n            isAuthorizedForOperator(operator, msg.sender),\n            \"Not authorized\"\n        );\n        locks.releaseLock(operator);\n    }\n\n    /// @notice Removes the lock of the specified operator contract\n    /// if the lock has expired or the contract has been disabled.\n    /// @dev Necessary for removing locks placed by contracts\n    /// that have been disabled by the panic button.\n    /// Also applicable to prevent inadvertent DoS of `recoverStake`\n    /// if too many operator contracts have failed to clean up their locks.\n    function releaseExpiredLock(\n        address operator,\n        address operatorContract\n    ) public {\n        locks.releaseExpiredLock(operator, operatorContract, address(this));\n    }\n\n    /// @notice Check whether the operator has any active locks\n    /// that haven't expired yet\n    /// and whose creators aren't disabled by the panic button.\n    function isStakeLocked(address operator) public view returns (bool) {\n        return locks.isStakeLocked(operator, address(this));\n    }\n\n    /// @notice Get the locks placed on the operator.\n    /// @return creators The addresses of operator contracts\n    /// that have placed a lock on the operator.\n    /// @return expirations The expiration times\n    /// of the locks placed on the operator.\n    function getLocks(address operator)\n        public\n        view\n        returns (address[] memory creators, uint256[] memory expirations) {\n        return locks.getLocks(operator);\n    }\n\n    /// @notice Slash provided token amount from every member in the misbehaved\n    /// operators array and burn 100% of all the tokens.\n    /// @param amountToSlash Token amount to slash from every misbehaved operator.\n    /// @param misbehavedOperators Array of addresses to seize the tokens from.\n    function slash(uint256 amountToSlash, address[] memory misbehavedOperators)\n        public\n        onlyApprovedOperatorContract(msg.sender) {\n\n        uint256 totalAmountToBurn;\n        address authoritySource = getAuthoritySource(msg.sender);\n        for (uint i = 0; i < misbehavedOperators.length; i++) {\n            address operator = misbehavedOperators[i];\n            require(authorizations[authoritySource][operator], \"Not authorized\");\n\n            uint256 operatorParams = operators[operator].packedParams;\n            require(\n                _isInitialized(operatorParams),\n                \"Inactive stake\"\n            );\n\n            require(\n                !_isStakeReleased(operator, operatorParams, msg.sender),\n                \"Stake is released\"\n            );\n\n            uint256 currentAmount = operatorParams.getAmount();\n\n            if (currentAmount < amountToSlash) {\n                totalAmountToBurn = totalAmountToBurn.add(currentAmount);\n                operators[operator].packedParams = operatorParams.setAmount(0);\n                emit TokensSlashed(operator, currentAmount);\n            } else {\n                totalAmountToBurn = totalAmountToBurn.add(amountToSlash);\n                operators[operator].packedParams = operatorParams.setAmount(\n                    currentAmount.sub(amountToSlash)\n                );\n                emit TokensSlashed(operator, amountToSlash);\n            }\n        }\n\n        token.burn(totalAmountToBurn);\n    }\n\n    /// @notice Seize provided token amount from every member in the misbehaved\n    /// operators array. The tattletale is rewarded with 5% of the total seized\n    /// amount scaled by the reward adjustment parameter and the rest 95% is burned.\n    /// @param amountToSeize Token amount to seize from every misbehaved operator.\n    /// @param rewardMultiplier Reward adjustment in percentage. Min 1% and 100% max.\n    /// @param tattletale Address to receive the 5% reward.\n    /// @param misbehavedOperators Array of addresses to seize the tokens from.\n    function seize(\n        uint256 amountToSeize,\n        uint256 rewardMultiplier,\n        address tattletale,\n        address[] memory misbehavedOperators\n    ) public onlyApprovedOperatorContract(msg.sender) {\n        uint256 totalAmountToBurn;\n        address authoritySource = getAuthoritySource(msg.sender);\n        for (uint i = 0; i < misbehavedOperators.length; i++) {\n            address operator = misbehavedOperators[i];\n            require(authorizations[authoritySource][operator], \"Not authorized\");\n\n            uint256 operatorParams = operators[operator].packedParams;\n            require(\n                _isInitialized(operatorParams),\n                \"Inactive stake\"\n            );\n\n            require(\n                !_isStakeReleased(operator, operatorParams, msg.sender),\n                \"Stake is released\"\n            );\n\n            uint256 currentAmount = operatorParams.getAmount();\n\n            if (currentAmount < amountToSeize) {\n                totalAmountToBurn = totalAmountToBurn.add(currentAmount);\n                operators[operator].packedParams = operatorParams.setAmount(0);\n                emit TokensSeized(operator, currentAmount);\n            } else {\n                totalAmountToBurn = totalAmountToBurn.add(amountToSeize);\n                operators[operator].packedParams = operatorParams.setAmount(\n                    currentAmount.sub(amountToSeize)\n                );\n                emit TokensSeized(operator, amountToSeize);\n            }\n        }\n\n        uint256 tattletaleReward = (totalAmountToBurn.percent(5)).percent(rewardMultiplier);\n\n        token.safeTransfer(tattletale, tattletaleReward);\n        token.burn(totalAmountToBurn.sub(tattletaleReward));\n    }\n\n    /// @notice Allows the current staking relationship owner to transfer the\n    /// ownership to someone else.\n    /// @param operator Address of the stake operator.\n    /// @param newOwner Address of the new staking relationship owner.\n    function transferStakeOwnership(address operator, address newOwner) public {\n        require(msg.sender == operators[operator].owner, \"Not authorized\");\n        operators[operator].owner = newOwner;\n        emit StakeOwnershipTransferred(operator, newOwner);\n    }\n\n    /// @notice Gets the eligible stake balance of the specified address.\n    /// An eligible stake is a stake that passed the initialization period\n    /// and is not currently undelegating. Also, the operator had to approve\n    /// the specified operator contract.\n    ///\n    /// Operator with a minimum required amount of eligible stake can join the\n    /// network and participate in new work selection.\n    ///\n    /// @param _operator address of stake operator.\n    /// @param _operatorContract address of operator contract.\n    /// @return an uint256 representing the eligible stake balance.\n    function eligibleStake(\n        address _operator,\n        address _operatorContract\n    ) public view returns (uint256 balance) {\n        uint256 operatorParams = operators[_operator].packedParams;\n        // To be eligible for work selection, the operator must:\n        // - have the operator contract authorized\n        // - have the stake initialized\n        // - must not be undelegating; keep in mind the `undelegatedAt` may be\n        // set to a time in the future, to schedule undelegation in advance.\n        // In this case the operator is still eligible until the timestamp\n        // `undelegatedAt`.\n        if (\n            isAuthorizedForOperator(_operator, _operatorContract) &&\n            _isInitialized(operatorParams) &&\n            !_isUndelegating(operatorParams)\n        ) {\n            balance = operatorParams.getAmount();\n        }\n    }\n\n    /// @notice Gets the active stake balance of the specified address.\n    /// An active stake is a stake that passed the initialization period,\n    /// and may be in the process of undelegation\n    /// but has not been released yet,\n    /// either because the undelegation period is not over,\n    /// or because the operator contract has an active lock on the operator.\n    /// Also, the operator had to approve the specified operator contract.\n    ///\n    /// The difference between eligible stake is that active stake does not make\n    /// the operator eligible for work selection but it may be still finishing\n    /// earlier work until the stake is released.\n    /// Operator with a minimum required\n    /// amount of active stake can join the network but cannot be selected to any\n    /// new work.\n    ///\n    /// @param _operator address of stake operator.\n    /// @param _operatorContract address of operator contract.\n    /// @return an uint256 representing the eligible stake balance.\n    function activeStake(\n        address _operator,\n        address _operatorContract\n    ) public view returns (uint256 balance) {\n        uint256 operatorParams = operators[_operator].packedParams;\n        if (\n            isAuthorizedForOperator(_operator, _operatorContract) &&\n            _isInitialized(operatorParams) &&\n            !_isStakeReleased(\n                _operator,\n                operatorParams,\n                _operatorContract\n            )\n        ) {\n            balance = operatorParams.getAmount();\n        }\n    }\n\n    /// @notice Checks if the specified account has enough active stake to become\n    /// network operator and that the specified operator contract has been\n    /// authorized for potential slashing.\n    ///\n    /// Having the required minimum of active stake makes the operator eligible\n    /// to join the network. If the active stake is not currently undelegating,\n    /// operator is also eligible for work selection.\n    ///\n    /// @param staker Staker's address\n    /// @param operatorContract Operator contract's address\n    /// @return True if has enough active stake to participate in the network,\n    /// false otherwise.\n    function hasMinimumStake(\n        address staker,\n        address operatorContract\n    ) public view returns(bool) {\n        return activeStake(staker, operatorContract) >= minimumStake();\n    }\n\n    /// @notice Is the operator with the given params initialized\n    function _isInitialized(uint256 _operatorParams)\n        internal view returns (bool) {\n        return block.timestamp > _operatorParams.getCreationTimestamp().add(initializationPeriod);\n    }\n\n    /// @notice Is the operator with the given params undelegating\n    function _isUndelegating(uint256 _operatorParams)\n        internal view returns (bool) {\n        uint256 undelegatedAt = _operatorParams.getUndelegationTimestamp();\n        return (undelegatedAt != 0) && (block.timestamp > undelegatedAt);\n    }\n\n    /// @notice Has the operator with the given params finished undelegating\n    function _isUndelegatingFinished(uint256 _operatorParams)\n        internal view returns (bool) {\n        uint256 undelegatedAt = _operatorParams.getUndelegationTimestamp();\n        return (undelegatedAt != 0) && (block.timestamp > undelegatedAt.add(undelegationPeriod()));\n    }\n\n    /// @notice Get whether the operator's stake is released\n    /// as far as the operator contract is concerned.\n    /// If the operator contract has a lock on the operator,\n    /// the operator's stake is be released when the lock expires.\n    /// Otherwise the stake is released when the operator finishes undelegating.\n    function _isStakeReleased(\n        address _operator,\n        uint256 _operatorParams,\n        address _operatorContract\n    ) internal view returns (bool) {\n        return _isUndelegatingFinished(_operatorParams) &&\n            locks.isStakeReleased(_operator, _operatorContract);\n    }\n\n    function transferOrDeposit(\n        address _owner,\n        address _operator,\n        uint256 _amount\n    ) internal {\n        if (grantStaking.hasGrantDelegated(_operator)) {\n            // For tokens staked from a grant, transfer them to the escrow.\n            TokenSender(address(token)).approveAndCall(\n                address(escrow),\n                _amount,\n                abi.encode(_operator, grantStaking.getGrantForOperator(_operator))\n            );\n        } else {\n            // For liquid tokens staked, transfer them straight to the owner.\n            token.safeTransfer(_owner, _amount);\n        }\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/StakeDelegatable.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"./utils/OperatorParams.sol\";\n\n/// @title Stake Delegatable\n/// @notice A base contract to allow stake delegation for staking contracts.\ncontract StakeDelegatable {\n    using OperatorParams for uint256;\n\n    mapping(address => Operator) internal operators;\n\n    struct Operator {\n        uint256 packedParams;\n        address owner;\n        address payable beneficiary;\n        address authorizer;\n    }\n\n    /// @notice Gets the stake balance of the specified address.\n    /// @param _address The address to query the balance of.\n    /// @return An uint256 representing the amount staked by the passed address.\n    function balanceOf(address _address) public view returns (uint256 balance) {\n        return operators[_address].packedParams.getAmount();\n    }\n\n    /// @notice Gets the stake owner for the specified operator address.\n    /// @return Stake owner address.\n    function ownerOf(address _operator) public view returns (address) {\n        return operators[_operator].owner;\n    }\n\n    /// @notice Gets the beneficiary for the specified operator address.\n    /// @return Beneficiary address.\n    function beneficiaryOf(address _operator) public view returns (address payable) {\n        return operators[_operator].beneficiary;\n    }\n\n    /// @notice Gets the authorizer for the specified operator address.\n    /// @return Authorizer address.\n    function authorizerOf(address _operator) public view returns (address) {\n        return operators[_operator].authorizer;\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/utils/OperatorParams.sol": {
      "content": "pragma solidity 0.5.17;\n\nlibrary OperatorParams {\n    // OperatorParams packs values that are commonly used together\n    // into a single uint256 to reduce the cost functions\n    // like querying eligibility.\n    //\n    // An OperatorParams uint256 contains:\n    // - the operator's staked token amount (uint128)\n    // - the operator's creation timestamp (uint64)\n    // - the operator's undelegation timestamp (uint64)\n    //\n    // These are packed as [amount | createdAt | undelegatedAt]\n    //\n    // Staked KEEP is stored in an uint128,\n    // which is sufficient because KEEP tokens have 18 decimals (2^60)\n    // and there will be at most 10^9 KEEP in existence (2^30).\n    //\n    // Creation and undelegation times are stored in an uint64 each.\n    // Thus uint64s would be sufficient for around 3*10^11 years.\n    uint256 constant TIMESTAMP_WIDTH = 64;\n    uint256 constant AMOUNT_WIDTH = 128;\n\n    uint256 constant TIMESTAMP_MAX = (2**TIMESTAMP_WIDTH) - 1;\n    uint256 constant AMOUNT_MAX = (2**AMOUNT_WIDTH) - 1;\n\n    uint256 constant CREATION_SHIFT = TIMESTAMP_WIDTH;\n    uint256 constant AMOUNT_SHIFT = 2 * TIMESTAMP_WIDTH;\n\n    function pack(\n        uint256 amount,\n        uint256 createdAt,\n        uint256 undelegatedAt\n    ) internal pure returns (uint256) {\n        // Check for staked amount overflow.\n        // We shouldn't actually ever need this.\n        require(\n            amount <= AMOUNT_MAX,\n            \"uint128 overflow\"\n        );\n        // Bitwise OR the timestamps together.\n        // The resulting number is equal or greater than either,\n        // and tells if we have a bit set outside the 64 available bits.\n        require(\n            (createdAt | undelegatedAt) <= TIMESTAMP_MAX,\n            \"uint64 overflow\"\n        );\n\n        return (amount << AMOUNT_SHIFT | createdAt << CREATION_SHIFT | undelegatedAt);\n    }\n\n    function unpack(uint256 packedParams) internal pure returns (\n        uint256 amount,\n        uint256 createdAt,\n        uint256 undelegatedAt\n    ) {\n        amount = getAmount(packedParams);\n        createdAt = getCreationTimestamp(packedParams);\n        undelegatedAt = getUndelegationTimestamp(packedParams);\n    }\n\n    function getAmount(uint256 packedParams)\n        internal pure returns (uint256) {\n        return (packedParams >> AMOUNT_SHIFT) & AMOUNT_MAX;\n    }\n\n    function setAmount(\n        uint256 packedParams,\n        uint256 amount\n    ) internal pure returns (uint256) {\n        return pack(\n            amount,\n            getCreationTimestamp(packedParams),\n            getUndelegationTimestamp(packedParams)\n        );\n    }\n\n    function getCreationTimestamp(uint256 packedParams)\n        internal pure returns (uint256) {\n        return (packedParams >> CREATION_SHIFT) & TIMESTAMP_MAX;\n    }\n\n    function setCreationTimestamp(\n        uint256 packedParams,\n        uint256 creationTimestamp\n    ) internal pure returns (uint256) {\n        return pack(\n            getAmount(packedParams),\n            creationTimestamp,\n            getUndelegationTimestamp(packedParams)\n        );\n    }\n\n    function getUndelegationTimestamp(uint256 packedParams)\n        internal pure returns (uint256) {\n        return packedParams & TIMESTAMP_MAX;\n    }\n\n    function setUndelegationTimestamp(\n        uint256 packedParams,\n        uint256 undelegationTimestamp\n    ) internal pure returns (uint256) {\n        return pack(\n            getAmount(packedParams),\n            getCreationTimestamp(packedParams),\n            undelegationTimestamp\n        );\n    }\n\n    function setAmountAndCreationTimestamp(\n        uint256 packedParams,\n        uint256 amount,\n        uint256 creationTimestamp\n    ) internal pure returns (uint256) {\n        return pack(\n            amount,\n            creationTimestamp,\n            getUndelegationTimestamp(packedParams)\n        );\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/libraries/staking/MinimumStakeSchedule.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/// @notice MinimumStakeSchedule defines the minimum stake parametrization and\n/// schedule. It starts with a minimum stake of 100k KEEP. Over the following\n/// 2 years, the minimum stake is lowered periodically using a uniform stepwise\n/// function, eventually ending at 10k.\nlibrary MinimumStakeSchedule {\n    using SafeMath for uint256;\n\n    // 2 years in seconds (seconds per day * days in a year * years)\n    uint256 public constant schedule = 86400 * 365 * 2;\n    uint256 public constant steps = 10;\n    uint256 public constant base = 10000 * 1e18;\n\n    /// @notice Returns the current value of the minimum stake. The minimum\n    /// stake is lowered periodically over the course of 2 years since the time\n    /// of the shedule start and eventually ends at 10k KEEP.\n    function current(uint256 scheduleStart) internal view returns (uint256) {\n        if (now < scheduleStart.add(schedule)) {\n            uint256 currentStep = steps.mul(now.sub(scheduleStart)).div(schedule);\n            return base.mul(steps.sub(currentStep));\n        }\n        return base;\n    }\n}"
    },
    "@keep-network/keep-core/contracts/libraries/staking/GrantStaking.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"../../TokenGrant.sol\";\nimport \"../../TokenStakingEscrow.sol\";\nimport \"../..//utils/BytesLib.sol\";\nimport \"../RolesLookup.sol\";\n\n/// @notice TokenStaking contract library allowing to capture the details of\n/// delegated grants and offering functions allowing to check grantee\n/// authentication for stake delegation management.\nlibrary GrantStaking {\n    using BytesLib for bytes;\n    using RolesLookup for address payable;\n\n    /// @dev Grant ID is flagged with the most significant bit set, to\n    /// distinguish the grant ID `0` from default (null) value. The flag is\n    /// toggled with bitwise XOR (`^`) which keeps all other bits intact but\n    /// flips the flag bit. The flag should be set before writing to\n    /// `operatorToGrant`, and unset after reading from `operatorToGrant`\n    /// before using the value.\n    uint256 constant GRANT_ID_FLAG = 1 << 255;\n\n    struct Storage {\n        /// @dev Do not read or write this mapping directly; please use\n        /// `hasGrantDelegated`, `setGrantForOperator`, and `getGrantForOperator`\n        /// instead.\n        mapping (address => uint256) _operatorToGrant;\n    }\n\n    /// @notice Tries to capture delegation data if the pending delegation has\n    /// been created from a grant. There are only two possibilities and they\n    /// need to be handled differently: delegation comes from the TokenGrant\n    /// contract or delegation comes from TokenStakingEscrow. In those two cases\n    /// grant ID has to be captured in a different way.\n    /// @dev In case of a delegation from the escrow, it is expected that grant\n    /// ID is passed in extraData bytes array. When the delegation comes from\n    /// the TokenGrant contract, delegation data are obtained directly from that\n    /// contract using `tryCapturingGrantId` function.\n    /// @param tokenGrant KEEP token grant contract reference.\n    /// @param escrow TokenStakingEscrow contract address.\n    /// @param from The owner of the tokens who approved them to transfer.\n    /// @param operator The operator tokens are delegated to.\n    /// @param extraData Data for stake delegation, as passed to\n    /// `receiveApproval` of `TokenStaking`.\n    function tryCapturingDelegationData(\n        Storage storage self,\n        TokenGrant tokenGrant,\n        address escrow,\n        address from,\n        address operator,\n        bytes memory extraData\n    ) public returns (bool, uint256) {\n        if (from == escrow) {\n            require(extraData.length == 92, \"Corrupted delegation data from escrow\");\n            uint256 grantId = extraData.toUint(60);\n            setGrantForOperator(self, operator, grantId);\n            return (true, grantId);\n        } else {\n            return tryCapturingGrantId(self, tokenGrant, operator);\n        }\n    }\n\n    /// @notice Checks if the delegation for the given operator has been created\n    /// from a grant defined in the passed token grant contract and if so,\n    /// captures the grant ID for that delegation.\n    /// Grant ID can be later retrieved based on the operator address and used\n    /// to authenticate grantee or to fetch the information about grant\n    /// unlocking schedule for escrow.\n    /// @param tokenGrant KEEP token grant contract reference.\n    /// @param operator The operator tokens are delegated to.\n    function tryCapturingGrantId(\n        Storage storage self,\n        TokenGrant tokenGrant,\n        address operator\n    ) internal returns (bool, uint256) {\n        (bool success, bytes memory data) = address(tokenGrant).call(\n            abi.encodeWithSignature(\"getGrantStakeDetails(address)\", operator)\n        );\n        if (success) {\n            (uint256 grantId,,address grantStakingContract) = abi.decode(\n                data, (uint256, uint256, address)\n            );\n            // Double-check if the delegation in TokenGrant has been defined\n            // for this staking contract. If not, it means it's an old\n            // delegation and the current one does not come from a grant.\n            // The scenario covered here is:\n            // - grantee delegated to operator A from a TokenGrant using another\n            //   staking contract,\n            // - someone delegates to operator A using liquid tokens and this\n            //   staking contract.\n            // Without this check, we'd consider the second delegation as coming\n            // from a grant.\n            if (address(this) != grantStakingContract) {\n                return (false, 0);\n            }\n\n            setGrantForOperator(self, operator, grantId);\n            return (true, grantId);\n        }\n\n        return (false, 0);\n    }\n\n    /// @notice Returns true if the given operator operates on stake delegated\n    /// from a grant. false is returned otherwise.\n    /// @param operator The operator to which tokens from a grant are\n    /// potentially delegated to.\n    function hasGrantDelegated(\n        Storage storage self,\n        address operator\n    ) public view returns (bool) {\n        return self._operatorToGrant[operator] != 0;\n    }\n\n    /// @notice Associates operator with the provided grant ID. It means that\n    /// the given operator delegates on stake from the grant with this ID.\n    /// @param operator The operator tokens are delegate to.\n    /// @param grantId Identifier of a grant from which the tokens are delegated\n    /// to.\n    function setGrantForOperator(\n        Storage storage self,\n        address operator,\n        uint256 grantId\n    ) public {\n        self._operatorToGrant[operator] = grantId ^ GRANT_ID_FLAG;\n    }\n\n    /// @notice Returns grant ID for the provided operator. If the operator\n    /// does not operate on stake delegated from a grant, function reverts.\n    /// @dev To avoid reverting in case the grant ID for the operator does not\n    /// exist, consider calling hasGrantDelegated before.\n    /// @param operator The operator tokens are delegate to.\n    function getGrantForOperator(\n        Storage storage self,\n        address operator\n    ) public view returns (uint256) {\n        uint256 grantId = self._operatorToGrant[operator];\n        require (grantId != 0, \"No grant for the operator\");\n        return grantId ^ GRANT_ID_FLAG;\n    }\n\n    /// @notice Returns true if msg.sender is grantee eligible to trigger stake\n    /// undelegation for this operator. Function checks both standard grantee\n    /// and managed grantee case.\n    /// @param operator The operator tokens are delegated to.\n    /// @param tokenGrant KEEP token grant contract reference.\n    function canUndelegate(\n        Storage storage self,\n        address operator,\n        TokenGrant tokenGrant\n    ) public returns (bool) {\n        // First of all, we need to see if the operator has grant delegated.\n        // If not, we don't need to bother about checking grantee or\n        // managed grantee and we just return false.\n        if (!hasGrantDelegated(self, operator)) {\n            return false;\n        }\n\n        uint256 grantId = getGrantForOperator(self, operator);\n        (,,,,uint256 revokedAt, address grantee) = tokenGrant.getGrant(grantId);\n\n        // Is msg.sender grantee of a standard grant?\n        if (msg.sender == grantee) {\n            return true;\n        }\n\n        // If not, we need to dig deeper and see if we are dealing with\n        // a grantee from a managed grant.\n        if ((msg.sender).isManagedGranteeForGrant(grantId, tokenGrant)) {\n            return true;\n        }\n\n        // There is only one possibility left - grant has been revoked and\n        // grant manager wants to take back delegated tokens.\n        if (revokedAt == 0) {\n            return false;\n        }\n        (address grantManager,,,,) = tokenGrant.getGrantUnlockingSchedule(grantId);\n        return msg.sender == grantManager;\n    }\n}"
    },
    "@keep-network/keep-core/contracts/TokenStakingEscrow.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"./libraries/grant/UnlockingSchedule.sol\";\nimport \"./utils/BytesLib.sol\";\nimport \"./KeepToken.sol\";\nimport \"./utils/BytesLib.sol\";\nimport \"./TokenGrant.sol\";\nimport \"./ManagedGrant.sol\";\nimport \"./TokenSender.sol\";\n\n/// @title TokenStakingEscrow\n/// @notice Escrow lets the staking contract to deposit undelegated, granted\n/// tokens and either withdraw them based on the grant unlocking schedule or\n/// re-delegate them to another operator.\n/// @dev The owner of TokenStakingEscrow is TokenStaking contract and only owner\n/// can deposit. This contract works with an assumption that operator is unique\n/// in the scope of `TokenStaking`, that is, no more than one delegation in the\n/// `TokenStaking` can be done do the given operator ever. Even if the previous\n/// delegation ended, operator address cannot be reused.\ncontract TokenStakingEscrow is Ownable {\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using BytesLib for bytes;\n    using UnlockingSchedule for uint256;\n\n    event Deposited(\n        address indexed operator,\n        uint256 indexed grantId,\n        uint256 amount\n    );\n    event DepositRedelegated(\n        address indexed previousOperator,\n        address indexed newOperator,\n        uint256 indexed grantId,\n        uint256 amount\n    );\n    event DepositWithdrawn(\n        address indexed operator,\n        address indexed grantee,\n        uint256 amount\n    );\n    event RevokedDepositWithdrawn(\n        address indexed operator,\n        address indexed grantManager,\n        uint256 amount\n    );\n    event EscrowAuthorized(\n        address indexed grantManager,\n        address escrow\n    );\n\n    IERC20 public keepToken;\n    TokenGrant public tokenGrant;\n\n    struct Deposit {\n        uint256 grantId;\n        uint256 amount;\n        uint256 withdrawn;\n        uint256 redelegated;\n    }\n\n    // operator address -> KEEP deposit\n    mapping(address => Deposit) internal deposits;\n\n    // Other escrows authorized by grant manager. Grantee may request to migrate\n    // tokens to another authorized escrow.\n    // grant manager -> escrow -> authorized?\n    mapping(address => mapping (address => bool)) internal authorizedEscrows;\n\n    constructor(\n        KeepToken _keepToken,\n        TokenGrant _tokenGrant\n    ) public {\n        keepToken = _keepToken;\n        tokenGrant = _tokenGrant;\n    }\n\n    /// @notice receiveApproval accepts deposits from staking contract and\n    /// stores them in the escrow by the operator address from which they were\n    /// undelegated. Function expects operator address and grant identifier to\n    /// be passed as ABI-encoded information in extraData. Grant with the given\n    /// identifier has to exist.\n    /// @param from Address depositing tokens - it has to be the address of\n    /// TokenStaking contract owning TokenStakingEscrow.\n    /// @param value The amount of KEEP tokens deposited.\n    /// @param token The address of KEEP token contract.\n    /// @param extraData ABI-encoded data containing operator address (32 bytes)\n    /// and grant ID (32 bytes).\n    function receiveApproval(\n        address from,\n        uint256 value,\n        address token,\n        bytes memory extraData\n    ) public {\n        require(IERC20(token) == keepToken, \"Not a KEEP token\");\n        require(msg.sender == token, \"KEEP token is not the sender\");\n        require(extraData.length == 64, \"Unexpected data length\");\n\n        (address operator, uint256 grantId) = abi.decode(\n            extraData, (address, uint256)\n        );\n        receiveDeposit(from, value, operator, grantId);\n    }\n\n    /// @notice Redelegates deposit or part of the deposit to another operator.\n    /// Uses the same staking contract as the original delegation.\n    /// @param previousOperator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    /// @dev Only grantee is allowed to call this function. For managed grant,\n    /// caller has to be the managed grantee.\n    /// @param amount Amount of tokens to delegate.\n    /// @param extraData Data for stake delegation. This byte array must have\n    /// the following values concatenated:\n    /// - Beneficiary address (20 bytes)\n    /// - Operator address (20 bytes)\n    /// - Authorizer address (20 bytes)\n    function redelegate(\n        address previousOperator,\n        uint256 amount,\n        bytes memory extraData\n    ) public {\n        require(extraData.length == 60, \"Corrupted delegation data\");\n\n        Deposit memory deposit = deposits[previousOperator];\n\n        uint256 grantId = deposit.grantId;\n        address newOperator = extraData.toAddress(20);\n        require(isGrantee(msg.sender, grantId), \"Not authorized\");\n        require(getAmountRevoked(grantId) == 0, \"Grant revoked\");\n        require(\n            availableAmount(previousOperator) >= amount,\n            \"Insufficient balance\"\n        );\n        require(\n            !hasDeposit(newOperator),\n            \"Redelegating to previously used operator is not allowed\"\n        );\n\n        deposits[previousOperator].redelegated = deposit.redelegated.add(amount);\n\n        TokenSender(address(keepToken)).approveAndCall(\n            owner(), // TokenStaking contract associated with the escrow\n            amount,\n            abi.encodePacked(extraData, grantId)\n        );\n\n        emit DepositRedelegated(\n            previousOperator,\n            newOperator,\n            grantId,\n            amount\n        );\n    }\n\n    /// @notice Returns true if there is a deposit for the given operator in\n    /// the escrow. Otherwise, returns false.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    function hasDeposit(address operator) public view returns (bool) {\n        return depositedAmount(operator) > 0;\n    }\n\n    /// @notice Returns the currently available amount deposited in the escrow\n    /// that may or may not be currently withdrawable. The available amount\n    /// is the amount initially deposited minus the amount withdrawn and\n    /// redelegated so far from that deposit.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    function availableAmount(address operator) public view returns (uint256) {\n        Deposit memory deposit = deposits[operator];\n        return deposit.amount.sub(deposit.withdrawn).sub(deposit.redelegated);\n    }\n\n    /// @notice Returns the total amount deposited in the escrow after\n    /// undelegating it from the provided operator.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    function depositedAmount(address operator) public view returns (uint256) {\n        return deposits[operator].amount;\n    }\n\n    /// @notice Returns grant ID for the amount deposited in the escrow after\n    /// undelegating it from the provided operator.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    function depositGrantId(address operator) public view returns (uint256) {\n        return deposits[operator].grantId;\n    }\n\n    /// @notice Returns the amount withdrawn so far from the value deposited\n    /// in the escrow contract after undelegating it from the provided operator.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    function depositWithdrawnAmount(address operator) public view returns (uint256) {\n        return deposits[operator].withdrawn;\n    }\n\n    /// @notice Returns the total amount redelegated so far from the value\n    /// deposited in the escrow contract after undelegating it from the provided\n    /// operator.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    function depositRedelegatedAmount(address operator) public view returns (uint256) {\n        return deposits[operator].redelegated;\n    }\n\n    /// @notice Returns the currently withdrawable amount that was previously\n    /// deposited in the escrow after undelegating it from the provided operator.\n    /// Tokens are unlocked based on their grant unlocking schedule.\n    /// Function returns 0 for non-existing deposits and revoked grants if they\n    /// have been revoked before they fully unlocked.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    function withdrawable(address operator) public view returns (uint256) {\n        Deposit memory deposit = deposits[operator];\n\n        // Staked tokens can be only withdrawn by grantee for non-revoked grant\n        // assuming that grant has not fully unlocked before it's been\n        // revoked.\n        //\n        // It is not possible for the escrow to determine the number of tokens\n        // it should return to the grantee of a revoked grant given different\n        // possible staking contracts and staking policies.\n        //\n        // If the entire grant unlocked before it's been reverted, escrow\n        // lets to withdraw the entire deposited amount.\n        if (getAmountRevoked(deposit.grantId) == 0) {\n            (\n                uint256 duration,\n                uint256 start,\n                uint256 cliff\n            ) = getUnlockingSchedule(deposit.grantId);\n\n            uint256 unlocked = now.getUnlockedAmount(\n                deposit.amount,\n                duration,\n                start,\n                cliff\n            );\n\n            if (deposit.withdrawn.add(deposit.redelegated) < unlocked) {\n                return unlocked.sub(deposit.withdrawn).sub(deposit.redelegated);\n            }\n        }\n\n        return 0;\n    }\n\n    /// @notice Withdraws currently unlocked tokens deposited in the escrow\n    /// after undelegating them from the provided operator. Only grantee or\n    /// operator can call this function. Important: this function can not be\n    /// called for a `ManagedGrant` grantee. This may lead to locking tokens.\n    /// For `ManagedGrant`, please use `withdrawToManagedGrantee` instead.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    function withdraw(address operator) public {\n        Deposit memory deposit = deposits[operator];\n        address grantee = getGrantee(deposit.grantId);\n\n        // Make sure this function is not called for a managed grant.\n        // If called for a managed grant, tokens could be locked there.\n        // Better be safe than sorry.\n        (bool success, ) = address(this).call(\n            abi.encodeWithSignature(\"getManagedGrantee(address)\", grantee)\n        );\n        require(!success, \"Can not be called for managed grant\");\n\n        require(\n            msg.sender == grantee || msg.sender == operator,\n            \"Only grantee or operator can withdraw\"\n        );\n\n        withdraw(deposit, operator, grantee);\n    }\n\n    /// @notice Withdraws currently unlocked tokens deposited in the escrow\n    /// after undelegating them from the provided operator. Only grantee or\n    /// operator can call this function. This function works only for\n    /// `ManagedGrant` grantees. For a standard grant, please use `withdraw`\n    /// instead.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    function withdrawToManagedGrantee(address operator) public {\n        Deposit memory deposit = deposits[operator];\n        address managedGrant = getGrantee(deposit.grantId);\n        address grantee = getManagedGrantee(managedGrant);\n\n        require(\n            msg.sender == grantee || msg.sender == operator,\n            \"Only grantee or operator can withdraw\"\n        );\n\n        withdraw(deposit, operator, grantee);\n    }\n\n    /// @notice Migrates all available tokens to another authorized escrow.\n    /// Can be requested only by grantee.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    /// @param receivingEscrow Escrow to which tokens should be migrated.\n    /// @dev The receiving escrow needs to accept deposits from this escrow, at\n    /// least for the period of migration.\n    function migrate(\n        address operator,\n        address receivingEscrow\n    ) public {\n        Deposit memory deposit = deposits[operator];\n        require(isGrantee(msg.sender, deposit.grantId), \"Not authorized\");\n\n        address grantManager = getGrantManager(deposit.grantId);\n        require(\n            authorizedEscrows[grantManager][receivingEscrow],\n            \"Escrow not authorized\"\n        );\n\n        uint256 amountLeft = availableAmount(operator);\n        deposits[operator].withdrawn = deposit.withdrawn.add(amountLeft);\n        TokenSender(address(keepToken)).approveAndCall(\n            receivingEscrow,\n            amountLeft,\n            abi.encode(operator, deposit.grantId)\n        );\n    }\n\n    /// @notice Withdraws the entire amount that is still deposited in the\n    /// escrow in case the grant has been revoked. Anyone can call this function\n    /// and the entire amount is transferred back to the grant manager.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    function withdrawRevoked(address operator) public {\n        Deposit memory deposit = deposits[operator];\n\n        require(\n            getAmountRevoked(deposit.grantId) > 0,\n            \"No revoked tokens to withdraw\"\n        );\n\n        address grantManager = getGrantManager(deposit.grantId);\n        withdrawRevoked(deposit, operator, grantManager);\n    }\n\n    /// @notice Used by grant manager to authorize another escrows for\n    // funds migration.\n    function authorizeEscrow(address anotherEscrow) public {\n        require(\n            anotherEscrow != address(0x0),\n            \"Escrow address can't be zero\"\n        );\n        authorizedEscrows[msg.sender][anotherEscrow] = true;\n        emit EscrowAuthorized(msg.sender, anotherEscrow);\n    }\n\n    /// @notice Resolves the final grantee of ManagedGrant contract. If the\n    /// provided address is not a ManagedGrant contract, function reverts.\n    /// @param managedGrant Address of the managed grant contract.\n    function getManagedGrantee(\n        address managedGrant\n    ) public view returns(address) {\n        ManagedGrant grant = ManagedGrant(managedGrant);\n        return grant.grantee();\n    }\n\n    function receiveDeposit(\n        address from,\n        uint256 value,\n        address operator,\n        uint256 grantId\n    ) internal {\n        // This contract works with an assumption that operator is unique.\n        // This is fine as long as the staking contract works with the same\n        // assumption so we are limiting deposits to the staking contract only.\n        require(from == owner(), \"Only owner can deposit\");\n        require(\n            getAmountGranted(grantId) > 0,\n            \"Grant with this ID does not exist\"\n        );\n\n        require(\n            !hasDeposit(operator),\n            \"Stake for the operator already deposited in the escrow\"\n        );\n\n        keepToken.safeTransferFrom(from, address(this), value);\n        deposits[operator] = Deposit(grantId, value, 0, 0);\n\n        emit Deposited(operator, grantId, value);\n    }\n\n    function isGrantee(\n        address maybeGrantee,\n        uint256 grantId\n    ) internal returns (bool) {\n        // Let's check the simplest case first - standard grantee.\n        // If the given address is set as a grantee for grant with the given ID,\n        // we return true.\n        address grantee = getGrantee(grantId);\n        if (maybeGrantee == grantee) {\n            return true;\n        }\n\n        // If the given address is not a standard grantee, there is still\n        // a chance that address is a managed grantee. We are calling\n        // getManagedGrantee that will cast the grantee to ManagedGrant and try\n        // to call getGrantee() function. If this call returns non-zero address,\n        // it means we are dealing with a ManagedGrant.\n        (, bytes memory result) = address(this).call(\n            abi.encodeWithSignature(\"getManagedGrantee(address)\", grantee)\n        );\n        if (result.length == 0) {\n            return false;\n        }\n        // At this point we know we are dealing with a ManagedGrant, so the last\n        // thing we need to check is whether the managed grantee of that grant\n        // is the grantee address passed as a parameter.\n        address managedGrantee = abi.decode(result, (address));\n        return maybeGrantee == managedGrantee;\n    }\n\n    function withdraw(\n        Deposit memory deposit,\n        address operator,\n        address grantee\n    ) internal {\n        uint256 amount = withdrawable(operator);\n\n        deposits[operator].withdrawn = deposit.withdrawn.add(amount);\n        keepToken.safeTransfer(grantee, amount);\n\n        emit DepositWithdrawn(operator, grantee, amount);\n    }\n\n    function withdrawRevoked(\n        Deposit memory deposit,\n        address operator,\n        address grantManager\n    ) internal {\n        uint256 amount = availableAmount(operator);\n        deposits[operator].withdrawn = amount;\n        keepToken.safeTransfer(grantManager, amount);\n\n        emit RevokedDepositWithdrawn(operator, grantManager, amount);\n    }\n\n    function getAmountGranted(uint256 grantId) internal view returns (\n        uint256 amountGranted\n    ) {\n        (amountGranted,,,,,) = tokenGrant.getGrant(grantId);\n    }\n\n    function getAmountRevoked(uint256 grantId) internal view returns (\n        uint256 amountRevoked\n    ) {\n        (,,,amountRevoked,,) = tokenGrant.getGrant(grantId);\n    }\n\n    function getUnlockingSchedule(uint256 grantId) internal view returns (\n        uint256 duration,\n        uint256 start,\n        uint256 cliff\n    ) {\n        (,duration,start,cliff,) = tokenGrant.getGrantUnlockingSchedule(grantId);\n    }\n\n    function getGrantee(uint256 grantId) internal view returns (\n        address grantee\n    ) {\n        (,,,,,grantee) = tokenGrant.getGrant(grantId);\n    }\n\n    function getGrantManager(uint256 grantId) internal view returns (\n        address grantManager\n    ) {\n        (grantManager,,,,) = tokenGrant.getGrantUnlockingSchedule(grantId);\n    }\n}"
    },
    "openzeppelin-solidity/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/KeepToken.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\";\n\n\n/// @dev Interface of recipient contract for approveAndCall pattern.\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; }\n\n/// @title KEEP Token\n/// @dev Standard ERC20Burnable token\ncontract KeepToken is ERC20Burnable, ERC20Detailed {\n    string public constant NAME = \"KEEP Token\";\n    string public constant SYMBOL = \"KEEP\";\n    uint8 public constant DECIMALS = 18; // The number of digits after the decimal place when displaying token values on-screen.\n    uint256 public constant INITIAL_SUPPLY = 10**27; // 1 billion tokens, 18 decimal places.\n\n    /// @dev Gives msg.sender all of existing tokens.\n    constructor() public ERC20Detailed(NAME, SYMBOL, DECIMALS) {\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\n\n    /// @notice Set allowance for other address and notify.\n    /// Allows `_spender` to spend no more than `_value` tokens\n    /// on your behalf and then ping the contract about it.\n    /// @param _spender The address authorized to spend.\n    /// @param _value The max amount they can spend.\n    /// @param _extraData Extra information to send to the approved contract.\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * > Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/ManagedGrant.sol": {
      "content": "pragma solidity ^0.5.4;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./TokenGrant.sol\";\n\n/// @title ManagedGrant\n/// @notice A managed grant acts as the grantee towards the token grant contract,\n/// proxying instructions from the actual grantee.\n/// The address used by the actual grantee\n/// to issue instructions and withdraw tokens\n/// can be reassigned with the consent of the grant manager.\ncontract ManagedGrant {\n    using SafeERC20 for ERC20Burnable;\n\n    ERC20Burnable public token;\n    TokenGrant public tokenGrant;\n    address public grantManager;\n    uint256 public grantId;\n    address public grantee;\n    address public requestedNewGrantee;\n\n    event GranteeReassignmentRequested(\n        address newGrantee\n    );\n    event GranteeReassignmentConfirmed(\n        address oldGrantee,\n        address newGrantee\n    );\n    event GranteeReassignmentCancelled(\n        address cancelledRequestedGrantee\n    );\n    event GranteeReassignmentChanged(\n        address previouslyRequestedGrantee,\n        address newRequestedGrantee\n    );\n    event TokensWithdrawn(\n        address destination,\n        uint256 amount\n    );\n\n    constructor(\n        address _tokenAddress,\n        address _tokenGrant,\n        address _grantManager,\n        uint256 _grantId,\n        address _grantee\n    ) public {\n        token = ERC20Burnable(_tokenAddress);\n        tokenGrant = TokenGrant(_tokenGrant);\n        grantManager = _grantManager;\n        grantId = _grantId;\n        grantee = _grantee;\n    }\n\n    /// @notice Request a reassignment of the grantee address.\n    /// Can only be called by the grantee.\n    /// @param _newGrantee The requested new grantee.\n    function requestGranteeReassignment(address _newGrantee)\n        public\n        onlyGrantee\n        noRequestedReassignment\n    {\n        _setRequestedNewGrantee(_newGrantee);\n        emit GranteeReassignmentRequested(_newGrantee);\n    }\n\n    /// @notice Cancel a pending grantee reassignment request.\n    /// Can only be called by the grantee.\n    function cancelReassignmentRequest()\n        public\n        onlyGrantee\n        withRequestedReassignment\n    {\n        address cancelledGrantee = requestedNewGrantee;\n        requestedNewGrantee = address(0);\n        emit GranteeReassignmentCancelled(cancelledGrantee);\n    }\n\n    /// @notice Change a pending reassignment request to a different grantee.\n    /// Can only be called by the grantee.\n    /// @param _newGrantee The address of the new requested grantee.\n    function changeReassignmentRequest(address _newGrantee)\n        public\n        onlyGrantee\n        withRequestedReassignment\n    {\n        address previouslyRequestedGrantee = requestedNewGrantee;\n        require(\n            previouslyRequestedGrantee != _newGrantee,\n            \"Unchanged reassignment request\"\n        );\n        _setRequestedNewGrantee(_newGrantee);\n        emit GranteeReassignmentChanged(previouslyRequestedGrantee, _newGrantee);\n    }\n\n    /// @notice Confirm a grantee reassignment request and set the new grantee as the grantee.\n    /// Can only be called by the grant manager.\n    /// @param _newGrantee The address of the new grantee.\n    /// Must match the currently requested new grantee.\n    function confirmGranteeReassignment(address _newGrantee)\n        public\n        onlyManager\n        withRequestedReassignment\n    {\n        address oldGrantee = grantee;\n        require(\n            requestedNewGrantee == _newGrantee,\n            \"Reassignment address mismatch\"\n        );\n        grantee = requestedNewGrantee;\n        requestedNewGrantee = address(0);\n        emit GranteeReassignmentConfirmed(oldGrantee, _newGrantee);\n    }\n\n    /// @notice Withdraw all unlocked tokens from the grant.\n    function withdraw() public onlyGrantee {\n        require(\n            requestedNewGrantee == address(0),\n            \"Can not withdraw with pending reassignment\"\n        );\n        tokenGrant.withdraw(grantId);\n        uint256 amount = token.balanceOf(address(this));\n        token.safeTransfer(grantee, amount);\n        emit TokensWithdrawn(grantee, amount);\n    }\n\n    /// @notice Stake tokens from the grant.\n    /// @param _stakingContract The contract to stake the tokens on.\n    /// @param _amount The amount of tokens to stake.\n    /// @param _extraData Data for the stake delegation.\n    /// This byte array must have the following values concatenated:\n    /// beneficiary address (20 bytes)\n    /// operator address (20 bytes)\n    /// authorizer address (20 bytes)\n    function stake(\n        address _stakingContract,\n        uint256 _amount,\n        bytes memory _extraData\n    ) public onlyGrantee {\n        tokenGrant.stake(grantId, _stakingContract, _amount, _extraData);\n    }\n\n    /// @notice Cancel delegating tokens to the given operator.\n    function cancelStake(address _operator) public onlyGranteeOr(_operator) {\n        tokenGrant.cancelStake(_operator);\n    }\n\n    /// @notice Begin undelegating tokens from the given operator.\n    function undelegate(address _operator) public onlyGranteeOr(_operator) {\n        tokenGrant.undelegate(_operator);\n    }\n\n    /// @notice Recover tokens previously staked and delegated to the operator.\n    function recoverStake(address _operator) public {\n        tokenGrant.recoverStake(_operator);\n    }\n\n    function _setRequestedNewGrantee(address _newGrantee) internal {\n        require(_newGrantee != address(0), \"Invalid new grantee address\");\n        require(_newGrantee != grantee, \"New grantee same as current grantee\");\n\n        requestedNewGrantee = _newGrantee;\n    }\n\n    modifier withRequestedReassignment {\n        require(\n            requestedNewGrantee != address(0),\n            \"No reassignment requested\"\n        );\n        _;\n    }\n\n    modifier noRequestedReassignment {\n        require(\n            requestedNewGrantee == address(0),\n            \"Reassignment already requested\"\n        );\n        _;\n    }\n\n    modifier onlyGrantee {\n        require(\n            msg.sender == grantee,\n            \"Only grantee may perform this action\"\n        );\n        _;\n    }\n\n    modifier onlyGranteeOr(address _operator) {\n        require(\n            msg.sender == grantee || msg.sender == _operator,\n            \"Only grantee or operator may perform this action\"\n        );\n        _;\n    }\n\n    modifier onlyManager {\n        require(\n            msg.sender == grantManager,\n            \"Only grantManager may perform this action\"\n        );\n        _;\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/TokenSender.sol": {
      "content": "pragma solidity 0.5.17;\n\n/// @dev Interface of sender contract for approveAndCall pattern.\ninterface TokenSender {\n    function approveAndCall(address _spender, uint256 _value, bytes calldata _extraData) external;\n}"
    },
    "@keep-network/keep-core/contracts/libraries/RolesLookup.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"../utils/AddressArrayUtils.sol\";\nimport \"../StakeDelegatable.sol\";\nimport \"../TokenGrant.sol\";\nimport \"../ManagedGrant.sol\";\n\n/// @title Roles Lookup\n/// @notice Library facilitating lookup of roles in stake delegation setup.\nlibrary RolesLookup {\n    using AddressArrayUtils for address[];\n\n    /// @notice Returns true if the tokenOwner delegated tokens to operator\n    /// using the provided stakeDelegatable contract. Othwerwise, returns false.\n    /// This function works only for the case when tokenOwner own those tokens\n    /// and those are not tokens from a grant.\n    function isTokenOwnerForOperator(\n        address tokenOwner,\n        address operator,\n        StakeDelegatable stakeDelegatable\n    ) internal view returns (bool) {\n        return stakeDelegatable.ownerOf(operator) == tokenOwner;\n    }\n\n    /// @notice Returns true if the grantee delegated tokens to operator\n    /// with the provided tokenGrant contract. Otherwise, returns false.\n    /// This function works only for the case when tokens were generated from\n    /// a non-managed grant, that is, the grantee is a non-contract address to\n    /// which the delegated tokens were granted.\n    /// @dev This function does not validate the staking reltionship on\n    /// a particular staking contract. It only checks whether the grantee\n    /// staked at least one time with the given operator. If you are interested\n    /// in a particular token staking contract, you need to perform additional\n    /// check.\n    function isGranteeForOperator(\n        address grantee,\n        address operator,\n        TokenGrant tokenGrant\n    ) internal view returns (bool) {\n        address[] memory operators = tokenGrant.getGranteeOperators(grantee);\n        return operators.contains(operator);\n    }\n\n    /// @notice Returns true if the grantee from the given managed grant contract\n    /// delegated tokens to operator with the provided tokenGrant contract.\n    /// Otherwise, returns false. In case the grantee declared by the managed\n    /// grant contract does not match the provided grantee, function reverts.\n    /// This function works only for cases when grantee, from TokenGrant's\n    /// perspective, is a smart contract exposing grantee() function returning\n    /// the final grantee. One possibility is the ManagedGrant contract.\n    /// @dev This function does not validate the staking reltionship on\n    /// a particular staking contract. It only checks whether the grantee\n    /// staked at least one time with the given operator. If you are interested\n    /// in a particular token staking contract, you need to perform additional\n    /// check.\n    function isManagedGranteeForOperator(\n        address grantee,\n        address operator,\n        address managedGrantContract,\n        TokenGrant tokenGrant\n    ) internal view returns (bool) {\n        require(\n            ManagedGrant(managedGrantContract).grantee() == grantee,\n            \"Not a grantee of the provided contract\"\n        );\n\n        address[] memory operators = tokenGrant.getGranteeOperators(\n            managedGrantContract\n        );\n        return operators.contains(operator);\n    }\n\n    /// @notice Returns true if grant with the given ID has been created with\n    /// managed grant pointing currently to the grantee passed as a parameter.\n    /// @dev The function does not revert if grant has not been created with\n    /// a managed grantee. This function is not a view because it uses low-level\n    /// call to check if the grant has been created with a managed grant.\n    /// It does not however modify any state.\n    function isManagedGranteeForGrant(\n        address grantee,\n        uint256 grantId,\n        TokenGrant tokenGrant\n    ) internal returns (bool) {\n        (,,,,, address managedGrant) = tokenGrant.getGrant(grantId);\n        (, bytes memory result) = managedGrant.call(\n            abi.encodeWithSignature(\"grantee()\")\n        );\n        if (result.length == 0) {\n            return false;\n        }\n        address managedGrantee = abi.decode(result, (address));\n        return grantee == managedGrantee;\n    }\n}"
    },
    "@keep-network/keep-core/contracts/libraries/staking/Locks.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport { AuthorityVerifier } from \"../../Authorizations.sol\";\nimport \"./LockUtils.sol\";\n\nlibrary Locks {\n    using SafeMath for uint256;\n    using LockUtils for LockUtils.LockSet;\n\n    event StakeLocked(address indexed operator, address lockCreator, uint256 until);\n    event LockReleased(address indexed operator, address lockCreator);\n    event ExpiredLockReleased(address indexed operator, address lockCreator);\n\n    uint256 public constant maximumLockDuration = 86400 * 200; // 200 days in seconds\n\n    struct Storage {\n        // Locks placed on the operator.\n        // `operatorLocks[operator]` returns all locks placed on the operator.\n        // Each authorized operator contract can place one lock on an operator.\n        mapping(address => LockUtils.LockSet) operatorLocks;\n    }\n\n    function lockStake(\n        Storage storage self,\n        address operator,\n        uint256 duration\n    ) public {\n        require(duration <= maximumLockDuration, \"Lock duration too long\");\n        self.operatorLocks[operator].setLock(\n            msg.sender,\n            uint96(block.timestamp.add(duration))\n        );\n        emit StakeLocked(operator, msg.sender, block.timestamp.add(duration));\n    }\n\n    function releaseLock(\n        Storage storage self,\n        address operator\n    ) public {\n        self.operatorLocks[operator].releaseLock(msg.sender);\n        emit LockReleased(operator, msg.sender);\n    }\n\n    function releaseExpiredLock(\n        Storage storage self,\n        address operator,\n        address operatorContract,\n        address authorityVerifier\n    ) public {\n        LockUtils.LockSet storage locks = self.operatorLocks[operator];\n\n        require(\n            locks.contains(operatorContract),\n            \"No matching lock present\"\n        );\n\n        bool expired = block.timestamp >= locks.getLockTime(operatorContract);\n        bool disabled = !AuthorityVerifier(authorityVerifier)\n            .isApprovedOperatorContract(operatorContract);\n\n        require(\n            expired || disabled,\n            \"Lock still active and valid\"\n        );\n\n        locks.releaseLock(operatorContract);\n\n        emit ExpiredLockReleased(operator, operatorContract);\n    }\n\n    /// @dev AuthorityVerifier is a trusted implementation and not a third-party,\n    /// external contract. AuthorityVerifier never reverts on the check and\n    /// has a reasonable gas consumption.\n    function isStakeLocked(\n        Storage storage self,\n        address operator,\n        address authorityVerifier\n    ) public view returns (bool) {\n        LockUtils.Lock[] storage _locks = self.operatorLocks[operator].locks;\n        LockUtils.Lock memory lock;\n        for (uint i = 0; i < _locks.length; i++) {\n            lock = _locks[i];\n            if (block.timestamp < lock.expiresAt) {\n                if (\n                    AuthorityVerifier(authorityVerifier)\n                        .isApprovedOperatorContract(lock.creator)\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function isStakeReleased(\n        Storage storage self,\n        address operator,\n        address operatorContract\n    ) public view returns (bool) {\n        LockUtils.LockSet storage locks = self.operatorLocks[operator];\n        // `getLockTime` returns 0 if the lock doesn't exist,\n        // thus we don't need to check for its presence separately.\n        return block.timestamp >= locks.getLockTime(operatorContract);\n    }\n\n    function getLocks(\n        Storage storage self,\n        address operator\n    ) public view returns (address[] memory creators, uint256[] memory expirations) {\n        uint256 lockCount = self.operatorLocks[operator].locks.length;\n        creators = new address[](lockCount);\n        expirations = new uint256[](lockCount);\n        LockUtils.Lock memory lock;\n        for (uint i = 0; i < lockCount; i++) {\n            lock = self.operatorLocks[operator].locks[i];\n            creators[i] = lock.creator;\n            expirations[i] = lock.expiresAt;\n        }\n    }\n} \n"
    },
    "@keep-network/keep-core/contracts/Authorizations.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"./KeepRegistry.sol\";\n\n/// @title AuthorityDelegator\n/// @notice An operator contract can delegate authority to other operator\n/// contracts by implementing the AuthorityDelegator interface.\n///\n/// To delegate authority,\n/// the recipient of delegated authority must call `claimDelegatedAuthority`,\n/// specifying the contract it wants delegated authority from.\n/// The staking contract calls `delegator.__isRecognized(recipient)`\n/// and if the call returns `true`,\n/// the named delegator contract is set as the recipient's authority delegator.\n/// Any future checks of registry approval or per-operator authorization\n/// will transparently mirror the delegator's status.\n///\n/// Authority can be delegated recursively;\n/// an operator contract receiving delegated authority\n/// can recognize other operator contracts as recipients of its authority.\ninterface AuthorityDelegator {\n    function __isRecognized(address delegatedAuthorityRecipient) external returns (bool);\n}\n\n/// @title AuthorityVerifier\n/// @notice An operator contract can delegate authority to other operator\n/// contracts. Entry in the registry is not updated and source contract remains\n/// listed there as authorized. This interface is a verifier that support verification\n/// of contract authorization in case of authority delegation from the source contract.\ninterface AuthorityVerifier {\n    /// @notice Returns true if the given operator contract has been approved\n    /// for use. The function never reverts.\n    function isApprovedOperatorContract(address _operatorContract)\n        external\n        view\n        returns (bool);\n}\n\ncontract Authorizations is AuthorityVerifier {\n    // Authorized operator contracts.\n    mapping(address => mapping (address => bool)) internal authorizations;\n\n    // Granters of delegated authority to operator contracts.\n    // E.g. keep factories granting delegated authority to keeps.\n    // `delegatedAuthority[keep] = factory`\n    mapping(address => address) internal delegatedAuthority;\n\n    // Registry contract with a list of approved operator contracts and upgraders.\n    KeepRegistry internal registry;\n\n    modifier onlyApprovedOperatorContract(address operatorContract) {\n        require(\n            isApprovedOperatorContract(operatorContract),\n            \"Operator contract unapproved\"\n        );\n        _;\n    }\n\n    constructor(KeepRegistry _registry) public {\n        registry = _registry;\n    }\n\n    /// @notice Gets the authorizer for the specified operator address.\n    /// @return Authorizer address.\n    function authorizerOf(address _operator) public view returns (address);\n\n    /// @notice Authorizes operator contract to access staked token balance of\n    /// the provided operator. Can only be executed by stake operator authorizer.\n    /// Contracts using delegated authority\n    /// cannot be authorized with `authorizeOperatorContract`.\n    /// Instead, authorize `getAuthoritySource(_operatorContract)`.\n    /// @param _operator address of stake operator.\n    /// @param _operatorContract address of operator contract.\n    function authorizeOperatorContract(address _operator, address _operatorContract)\n        public\n        onlyApprovedOperatorContract(_operatorContract) {\n        require(\n            authorizerOf(_operator) == msg.sender,\n            \"Not operator authorizer\"\n        );\n        require(\n            getAuthoritySource(_operatorContract) == _operatorContract,\n            \"Delegated authority used\"\n        );\n        authorizations[_operatorContract][_operator] = true;\n    }\n\n    /// @notice Checks if operator contract has access to the staked token balance of\n    /// the provided operator.\n    /// @param _operator address of stake operator.\n    /// @param _operatorContract address of operator contract.\n    function isAuthorizedForOperator(\n        address _operator,\n        address _operatorContract\n    ) public view returns (bool) {\n        return authorizations[getAuthoritySource(_operatorContract)][_operator];\n    }\n\n    /// @notice Grant the sender the same authority as `delegatedAuthoritySource`\n    /// @dev If `delegatedAuthoritySource` is an approved operator contract\n    /// and recognizes the claimant, this relationship will be recorded in\n    /// `delegatedAuthority`. Later, the claimant can slash, seize, place locks etc.\n    /// on operators that have authorized the `delegatedAuthoritySource`.\n    /// If the `delegatedAuthoritySource` is disabled with the panic button,\n    /// any recipients of delegated authority from it will also be disabled.\n    function claimDelegatedAuthority(\n        address delegatedAuthoritySource\n    ) public onlyApprovedOperatorContract(delegatedAuthoritySource) {\n        require(\n            AuthorityDelegator(delegatedAuthoritySource).__isRecognized(msg.sender),\n            \"Unrecognized claimant\"\n        );\n        delegatedAuthority[msg.sender] = delegatedAuthoritySource;\n    }\n\n    /// @notice Checks if the operator contract is authorized in the registry.\n    /// If the contract uses delegated authority it checks authorization of the\n    /// source contract.\n    /// @param _operatorContract address of operator contract.\n    /// @return True if operator contract is approved, false if operator contract\n    /// has not been approved or if it was disabled by the panic button.\n    function isApprovedOperatorContract(address _operatorContract)\n        public\n        view\n        returns (bool)\n    {\n        return\n            registry.isApprovedOperatorContract(\n                getAuthoritySource(_operatorContract)\n            );\n    }\n\n    /// @notice Get the source of the operator contract's authority.\n    /// If the contract uses delegated authority,\n    /// returns the original source of the delegated authority.\n    /// If the contract doesn't use delegated authority,\n    /// returns the contract itself.\n    /// Authorize `getAuthoritySource(operatorContract)`\n    /// to grant `operatorContract` the authority to penalize an operator.\n    function getAuthoritySource(\n        address operatorContract\n    ) public view returns (address) {\n        address delegatedAuthoritySource = delegatedAuthority[operatorContract];\n        if (delegatedAuthoritySource == address(0)) {\n            return operatorContract;\n        }\n        return getAuthoritySource(delegatedAuthoritySource);\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/libraries/staking/LockUtils.sol": {
      "content": "pragma solidity 0.5.17;\n\nlibrary LockUtils {\n    struct Lock {\n        address creator;\n        uint96 expiresAt;\n    }\n\n    /// @notice The LockSet is like an array of unique `uint256`s,\n    /// but additionally supports O(1) membership tests and removals.\n    /// @dev Because the LockSet relies on a mapping,\n    /// it can only be used in storage, not in memory.\n    struct LockSet {\n        // locks[positions[lock.creator] - 1] = lock\n        Lock[] locks;\n        mapping(address => uint256) positions;\n    }\n\n    /// @notice Check whether the LockSet `self` contains a lock by `creator`\n    function contains(LockSet storage self, address creator)\n        internal view returns (bool) {\n        return (self.positions[creator] != 0);\n    }\n\n    function getLockTime(LockSet storage self, address creator)\n        internal view returns (uint96) {\n        uint256 positionPlusOne = self.positions[creator];\n        if (positionPlusOne == 0) { return 0; }\n        return self.locks[positionPlusOne - 1].expiresAt;\n    }\n\n    /// @notice Set the lock of `creator` to `expiresAt`,\n    /// overriding the current value if any.\n    function setLock(\n        LockSet storage self,\n        address _creator,\n        uint96 _expiresAt\n    ) internal {\n        uint256 positionPlusOne = self.positions[_creator];\n        Lock memory lock = Lock(_creator, _expiresAt);\n        // No existing lock\n        if (positionPlusOne == 0) {\n            self.locks.push(lock);\n            self.positions[_creator] = self.locks.length;\n        // Existing lock present\n        } else {\n            self.locks[positionPlusOne - 1].expiresAt = _expiresAt;\n        }\n    }\n\n    /// @notice Remove the lock of `creator`.\n    /// If no lock present, do nothing.\n    function releaseLock(\n        LockSet storage self,\n        address _creator\n    ) internal {\n        uint256 positionPlusOne = self.positions[_creator];\n        if (positionPlusOne != 0) {\n            uint256 lockCount = self.locks.length;\n            if (positionPlusOne != lockCount) {\n                // Not the last lock,\n                // so we need to move the last lock into the emptied position.\n                Lock memory lastLock = self.locks[lockCount - 1];\n                self.locks[positionPlusOne - 1] = lastLock;\n                self.positions[lastLock.creator] = positionPlusOne;\n            }\n            self.locks.length--;\n            self.positions[_creator] = 0;\n        }\n    }\n\n    /// @notice Return the locks of the LockSet `self`.\n    function enumerate(LockSet storage self)\n        internal view returns (Lock[] memory) {\n        return self.locks;\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/libraries/staking/TopUps.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"../../TokenStakingEscrow.sol\";\nimport \"../../utils/OperatorParams.sol\";\n\n\n/// @notice TokenStaking contract library allowing to perform two-step stake\n/// top-ups for existing delegations.\n/// Top-up is a two-step process: it is initiated with a declared top-up value\n/// and after waiting for at least the initialization period it can be\n/// committed.\nlibrary TopUps {\n    using SafeMath for uint256;\n    using OperatorParams for uint256;\n\n    event TopUpInitiated(address indexed operator, uint256 topUp);\n    event TopUpCompleted(address indexed operator, uint256 newAmount);\n\n    struct TopUp {\n        uint256 amount;\n        uint256 createdAt;\n    }\n\n    struct Storage {\n        // operator -> TopUp\n        mapping(address => TopUp) topUps;\n    }\n\n    /// @notice Performs top-up in one step when stake is not yet initialized by\n    /// adding the top-up amount to the stake and resetting stake initialization\n    /// time counter.\n    /// @dev This function should be called only for not yet initialized stake.\n    /// @param value Top-up value, the number of tokens added to the stake.\n    /// @param operator Operator The operator with existing delegation to which\n    /// the tokens should be added to.\n    /// @param operatorParams Parameters of that operator, as stored in the\n    /// staking contract.\n    /// @param escrow Reference to TokenStakingEscrow contract.\n    /// @return New value of parameters. It should be updated for the operator\n    /// in the staking contract.\n    function instantComplete(\n        Storage storage self,\n        uint256 value,\n        address operator,\n        uint256 operatorParams,\n        TokenStakingEscrow escrow\n    ) public returns (uint256 newParams) {\n        // Stake is not yet initialized so we don't need to check if the\n        // operator is not undelegating - initializing and undelegating at the\n        // same time is not possible. We do however, need to check whether the\n        // operator has not canceled its previous stake for that operator,\n        // depositing the stake it in the escrow. We do not want to allow\n        // resurrecting operators with cancelled stake by top-ups.\n        require(\n            !escrow.hasDeposit(operator),\n            \"Stake for the operator already deposited in the escrow\"\n        );\n        require(value > 0, \"Top-up value must be greater than zero\");\n\n        uint256 newAmount = operatorParams.getAmount().add(value);\n        newParams = operatorParams.setAmountAndCreationTimestamp(\n            newAmount,\n            block.timestamp\n        );\n\n        emit TopUpCompleted(operator, newAmount);\n    }\n\n    /// @notice Initiates top-up of the given value for tokens delegated to\n    /// the provided operator. If there is an existing top-up still\n    /// initializing, top-up values are summed up and initialization period\n    /// is set to the current block timestamp.\n    /// @dev This function should be called only for active operators with\n    /// initialized stake.\n    /// @param value Top-up value, the number of tokens added to the stake.\n    /// @param operator Operator The operator with existing delegation to which\n    /// the tokens should be added to.\n    /// @param operatorParams Parameters of that operator, as stored in the\n    /// staking contract.\n    /// @param escrow Reference to TokenStakingEscrow contract.\n    function initiate(\n        Storage storage self,\n        uint256 value,\n        address operator,\n        uint256 operatorParams,\n        TokenStakingEscrow escrow\n    ) public {\n        // Stake is initialized, the operator is still active so we need\n        // to check if it's not undelegating.\n        require(!isUndelegating(operatorParams), \"Stake undelegated\");\n        // We also need to check if the stake for the operator is not already\n        // in the escrow because it's been previously cancelled.\n        require(\n            !escrow.hasDeposit(operator),\n            \"Stake for the operator already deposited in the escrow\"\n        );\n        require(value > 0, \"Top-up value must be greater than zero\");\n\n        TopUp memory awaiting = self.topUps[operator];\n        self.topUps[operator] = TopUp(awaiting.amount.add(value), now);\n        emit TopUpInitiated(operator, value);\n    }\n\n    /// @notice Commits the top-up if it passed the initialization period.\n    /// Tokens are added to the stake once the top-up is committed.\n    /// @param operator Operator The operator with a pending stake top-up.\n    /// @param initializationPeriod Stake initialization period.\n    function commit(\n        Storage storage self,\n        address operator,\n        uint256 operatorParams,\n        uint256 initializationPeriod\n    ) public returns (uint256 newParams) {\n        TopUp memory topUp = self.topUps[operator];\n        require(topUp.amount > 0, \"No top up to commit\");\n        require(\n            now > topUp.createdAt.add(initializationPeriod),\n            \"Stake is initializing\"\n        );\n\n        uint256 newAmount = operatorParams.getAmount().add(topUp.amount);\n        newParams = operatorParams.setAmount(newAmount);\n\n        delete self.topUps[operator];\n        emit TopUpCompleted(operator, newAmount);\n    }\n\n    /// @notice Cancels pending, initiating top-up. If there is no initiating\n    /// top-up for the operator, function does nothing. This function should be\n    /// used when the stake is recovered to return tokens from a pending,\n    /// initiating top-up.\n    /// @param operator Operator The operator from which the stake is recovered.\n    function cancel(\n        Storage storage self,\n        address operator\n    ) public returns (uint256) {\n        TopUp memory topUp = self.topUps[operator];\n        if (topUp.amount == 0) {\n            return 0;\n        }\n\n        delete self.topUps[operator];\n        return topUp.amount;\n    }\n\n    /// @notice Returns true if the given operatorParams indicate that the\n    /// operator is undelegating its stake or that it completed stake\n    /// undelegation.\n    /// @param operatorParams Parameters of the operator, as stored in the\n    /// staking contract.\n    function isUndelegating(uint256 operatorParams)\n        internal view returns (bool) {\n        uint256 undelegatedAt = operatorParams.getUndelegationTimestamp();\n        return (undelegatedAt != 0) && (block.timestamp > undelegatedAt);\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/utils/PercentUtils.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nlibrary PercentUtils {\n    using SafeMath for uint256;\n\n    // Return `b`% of `a`\n    // 200.percent(40) == 80\n    // Commutative, works both ways\n    function percent(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(b).div(100);\n    }\n\n    // Return `a` as percentage of `b`:\n    // 80.asPercentOf(200) == 40\n    function asPercentOf(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(100).div(b);\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/TokenGrantStake.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./TokenStaking.sol\";\nimport \"./TokenSender.sol\";\nimport \"./utils/BytesLib.sol\";\n\n/// @dev Interface of sender contract for approveAndCall pattern.\ninterface tokenSender {\n    function approveAndCall(address _spender, uint256 _value, bytes calldata _extraData) external;\n}\n\ncontract TokenGrantStake {\n    using SafeMath for uint256;\n    using BytesLib for bytes;\n\n    ERC20Burnable token;\n    TokenStaking tokenStaking;\n\n    address tokenGrant; // Address of the master grant contract.\n\n    uint256 grantId; // ID of the grant for this stake.\n    uint256 amount; // Amount of staked tokens.\n    address operator; // Operator of the stake.\n\n    constructor(\n        address _tokenAddress,\n        uint256 _grantId,\n        address _tokenStaking\n    ) public {\n        require(\n            _tokenAddress != address(0x0),\n            \"Token address can't be zero.\"\n        );\n        require(\n            _tokenStaking != address(0x0),\n            \"Staking contract address can't be zero.\"\n        );\n\n        token = ERC20Burnable(_tokenAddress);\n        tokenGrant = msg.sender;\n        grantId = _grantId;\n        tokenStaking = TokenStaking(_tokenStaking);\n    }\n\n    function stake(\n        uint256 _amount,\n        bytes memory _extraData\n    ) public onlyGrant {\n        amount = _amount;\n        operator = _extraData.toAddress(20);\n        tokenSender(address(token)).approveAndCall(\n            address(tokenStaking),\n            _amount,\n            _extraData\n        );\n    }\n\n    function getGrantId() public view onlyGrant returns (uint256) {\n        return grantId;\n    }\n\n    function getAmount() public view onlyGrant returns (uint256) {\n        return amount;\n    }\n\n    function getStakingContract() public view onlyGrant returns (address) {\n        return address(tokenStaking);\n    }\n\n    function getDetails() public view onlyGrant returns (\n        uint256 _grantId,\n        uint256 _amount,\n        address _tokenStaking\n    ) {\n        return (\n            grantId,\n            amount,\n            address(tokenStaking)\n        );\n    }\n\n    function cancelStake() public onlyGrant returns (uint256) {\n        tokenStaking.cancelStake(operator);\n        return returnTokens();\n    }\n\n    function undelegate() public onlyGrant {\n        tokenStaking.undelegate(operator);\n    }\n\n    function recoverStake() public onlyGrant returns (uint256) {\n        tokenStaking.recoverStake(operator);\n        return returnTokens();\n    }\n\n    function returnTokens() internal returns (uint256) {\n        uint256 returnedAmount = token.balanceOf(address(this));\n        amount -= returnedAmount;\n        token.transfer(tokenGrant, returnedAmount);\n        return returnedAmount;\n    }\n\n    modifier onlyGrant {\n        require(\n            msg.sender == tokenGrant,\n            \"For token grant contract only\"\n        );\n        _;\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/GrantStakingPolicy.sol": {
      "content": "pragma solidity 0.5.17;\n\n/// @title GrantStakingPolicy\n/// @notice A staking policy defines the function `getStakeableAmount`\n/// which calculates how many tokens may be staked from a token grant.\ncontract GrantStakingPolicy {\n    function getStakeableAmount(\n        uint256 _now,\n        uint256 grantedAmount,\n        uint256 duration,\n        uint256 start,\n        uint256 cliff,\n        uint256 withdrawn) public view returns (uint256);\n}\n"
    },
    "solidity/contracts/KeepCreator.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"./CloneFactory.sol\";\n\ncontract KeepCreator is CloneFactory {\n    // Holds the address of the keep contract that will be used as a master\n    // contract for cloning.\n    address public masterKeepAddress;\n\n    // Keeps created by this factory.\n    address[] public keeps;\n\n    // Maps keep opened timestamp to each keep address\n    mapping(address => uint256) keepOpenedTimestamp;\n\n    constructor(address _masterKeepAddress) public {\n        masterKeepAddress = _masterKeepAddress;\n    }\n\n    /// @notice Gets how many keeps have been opened by this contract.\n    /// @dev    Checks the size of the keeps array.\n    /// @return The number of keeps opened so far.\n    function getKeepCount() external view returns (uint256) {\n        return keeps.length;\n    }\n\n    /// @notice Gets a specific keep address at a given index.\n    /// @return The address of the keep at the given index.\n    function getKeepAtIndex(uint256 index) external view returns (address) {\n        require(index < keeps.length, \"Out of bounds.\");\n        return keeps[index];\n    }\n\n    /// @notice Gets the opened timestamp of the given keep.\n    /// @return Timestamp the given keep was opened at or 0 if this keep\n    /// was not created by this factory.\n    function getKeepOpenedTimestamp(address _keep)\n        external\n        view\n        returns (uint256)\n    {\n        return keepOpenedTimestamp[_keep];\n    }\n\n    /// @notice Creates a new keep instance with a clone factory.\n    /// @dev It has to be called by a function implementing a keep opening mechanism.\n    function createKeep() internal returns (address keepAddress) {\n        keepAddress = createClone(masterKeepAddress);\n        keeps.push(keepAddress);\n\n        /* solium-disable-next-line security/no-block-members*/\n        keepOpenedTimestamp[keepAddress] = block.timestamp;\n    }\n}\n"
    },
    "solidity/contracts/CloneFactory.sol": {
      "content": "pragma solidity 0.5.17;\n\n/*\nThe MIT License (MIT)\nCopyright (c) 2018 Murray Software, LLC.\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n//solhint-disable max-line-length\n//solhint-disable no-inline-assembly\n\n// Implementation of [EIP-1167] based on [clone-factory]\n// source code.\n//\n// EIP 1167: https://eips.ethereum.org/EIPS/eip-1167\n// clone-factory: https://github.com/optionality/clone-factory\n// Modified to use ^0.5.10; instead of ^0.4.23 solidity version\n//\n// TODO: This code is copied from tbtc repo. We should consider pulling the code\n// and tests to a common repo.\n/* solium-disable */\n\ncontract CloneFactory {\n    function createClone(address target) internal returns (address result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            result := create(0, clone, 0x37)\n        }\n    }\n\n    function isClone(address target, address query)\n        internal\n        view\n        returns (bool result)\n    {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(\n                clone,\n                0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000\n            )\n            mstore(add(clone, 0xa), targetBytes)\n            mstore(\n                add(clone, 0x1e),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n\n            let other := add(clone, 0x40)\n            extcodecopy(query, other, 0, 0x2d)\n            result := and(\n                eq(mload(clone), mload(other)),\n                eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n            )\n        }\n    }\n}\n"
    },
    "solidity/contracts/GroupSelectionSeed.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"@keep-network/keep-core/contracts/IRandomBeacon.sol\";\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\n\ncontract GroupSelectionSeed is IRandomBeaconConsumer, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    IRandomBeacon randomBeacon;\n\n    // Gas required for a callback from the random beacon. The value specifies\n    // gas required to call `__beaconCallback` function in the worst-case\n    // scenario with all the checks and maximum allowed uint256 relay entry as\n    // a callback parameter.\n    uint256 public constant callbackGas = 30000;\n\n    // Random beacon sends back callback surplus to the requestor. It may also\n    // decide to send additional request subsidy fee. What's more, it may happen\n    // that the beacon is busy and we will not refresh group selection seed from\n    // the beacon. We accumulate all funds received from the beacon in the\n    // reseed pool and later use this pool to reseed using a public reseed\n    // function on a manual request at any moment.\n    uint256 public reseedPool;\n\n    uint256 public groupSelectionSeed;\n\n    constructor(address _randomBeacon) public {\n        randomBeacon = IRandomBeacon(_randomBeacon);\n\n        // Initial value before the random beacon updates the seed.\n        // https://www.wolframalpha.com/input/?i=pi+to+78+digits\n        groupSelectionSeed = 31415926535897932384626433832795028841971693993751058209749445923078164062862;\n    }\n\n    /// @notice Adds any received funds to the reseed pool.\n    function() external payable {\n        reseedPool += msg.value;\n    }\n\n    /// @notice Sets a new group selection seed value.\n    /// @dev The function is expected to be called in a callback by the random\n    /// beacon.\n    /// @param _relayEntry Beacon output.\n    function __beaconCallback(uint256 _relayEntry) external onlyRandomBeacon {\n        groupSelectionSeed = _relayEntry;\n    }\n\n    /// @notice Gets a fee estimate for a new random entry.\n    /// @return Uint256 estimate.\n    function newEntryFeeEstimate() public view returns (uint256) {\n        return randomBeacon.entryFeeEstimate(callbackGas);\n    }\n\n    /// @notice Calculates the fee requestor has to pay to reseed the factory\n    /// for signer selection. Depending on how much value is stored in the\n    /// reseed pool and the price of a new relay entry, returned value may vary.\n    function newGroupSelectionSeedFee() public view returns (uint256) {\n        uint256 beaconFee = randomBeacon.entryFeeEstimate(callbackGas);\n        return beaconFee <= reseedPool ? 0 : beaconFee.sub(reseedPool);\n    }\n\n    /// @notice Reseeds the value used for a signer selection. Requires enough\n    /// payment to be passed. The required payment can be calculated using\n    /// reseedFee function. Factory is automatically triggering reseeding after\n    /// opening a new keep but the reseed can be also triggered at any moment\n    /// using this function.\n    function requestNewGroupSelectionSeed() public payable nonReentrant {\n        reseedPool = reseedPool.add(msg.value);\n\n        uint256 beaconFee = randomBeacon.entryFeeEstimate(callbackGas);\n        require(reseedPool >= beaconFee, \"Not enough funds to trigger reseed\");\n        reseedPool = reseedPool.sub(beaconFee);\n\n        (bool success, bytes memory returnData) = requestRelayEntry(beaconFee);\n        if (!success) {\n            revert(string(returnData));\n        }\n    }\n\n    /// @notice Updates group selection seed.\n    /// @dev The main goal of this function is to request the random beacon to\n    /// generate a new random number. The beacon generates the number asynchronously\n    /// and will call a callback function when the number is ready. In the meantime\n    /// we update current group selection seed to a new value using a hash function.\n    /// In case of the random beacon request failure this function won't revert\n    /// but add beacon payment to factory's reseed pool.\n    function newGroupSelectionSeed() internal {\n        // Calculate new group selection seed based on the current seed.\n        // We added address of the factory as a key to calculate value different\n        // than sortition pool RNG will, so we don't end up selecting almost\n        // identical group.\n        groupSelectionSeed = uint256(\n            keccak256(abi.encodePacked(groupSelectionSeed, address(this)))\n        );\n\n        // Call the random beacon to get a random group selection seed.\n        (bool success, ) = requestRelayEntry(msg.value);\n        if (!success) {\n            reseedPool += msg.value;\n        }\n    }\n\n    /// @notice Requests for a relay entry using the beacon payment provided as\n    /// the parameter.\n    function requestRelayEntry(uint256 payment)\n        internal\n        returns (bool, bytes memory)\n    {\n        return\n            address(randomBeacon).call.value(payment)(\n                abi.encodeWithSignature(\n                    \"requestRelayEntry(address,uint256)\",\n                    address(this),\n                    callbackGas\n                )\n            );\n    }\n\n    /// @notice Checks if the caller is the random beacon.\n    /// @dev Throws an error if called by any account other than the random beacon.\n    modifier onlyRandomBeacon() {\n        require(\n            address(randomBeacon) == msg.sender,\n            \"Caller is not the random beacon\"\n        );\n        _;\n    }\n}\n"
    },
    "@keep-network/keep-core/contracts/IRandomBeacon.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\n\n/// @title Keep Random Beacon\n///\n/// @notice Keep Random Beacon generates verifiable randomness that is resistant\n/// to bad actors both in the relay network and on the anchoring blockchain.\ninterface IRandomBeacon {\n    /// @notice Event emitted for each new relay entry generated. It contains\n    /// request ID allowing to associate the generated relay entry with relay\n    /// request created previously with `requestRelayEntry` function. Event is\n    /// emitted no matter if callback was executed or not.\n    ///\n    /// @param requestId Relay request ID for which entry was generated.\n    /// @param entry Generated relay entry.\n    event RelayEntryGenerated(uint256 requestId, uint256 entry);\n\n    /// @notice Provides the customer with an estimated entry fee in wei to use\n    /// in the request. The fee estimate is only valid for the transaction it is\n    /// called in, so the customer must make the request immediately after\n    /// obtaining the estimate. Insufficient payment will lead to the request\n    /// being rejected and the transaction reverted.\n    ///\n    /// The customer may decide to provide more ether for an entry fee than\n    /// estimated by this function. This is especially helpful when callback gas\n    /// cost fluctuates. Any surplus between the passed fee and the actual cost\n    /// of producing an entry and executing a callback is returned back to the\n    /// customer.\n    /// @param callbackGas Gas required for the callback.\n    function entryFeeEstimate(uint256 callbackGas)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Submits a request to generate a new relay entry. Executes\n    /// callback on the provided callback contract with the generated entry and\n    /// emits `RelayEntryGenerated(uint256 requestId, uint256 entry)` event.\n    /// Callback contract has to declare public `__beaconCallback(uint256)`\n    /// function that is going to be executed with the result, once ready.\n    /// It is recommended to implement `IRandomBeaconConsumer` interface to\n    /// ensure the correct callback function signature.\n    ///\n    /// @dev Beacon does not support concurrent relay requests. No new requests\n    /// should be made while the beacon is already processing another request.\n    /// Requests made while the beacon is busy will be rejected and the\n    /// transaction reverted.\n    ///\n    /// @param callbackContract Callback contract address. Callback is called\n    /// once a new relay entry has been generated. Must declare public\n    /// `__beaconCallback(uint256)` function. It is recommended to implement\n    /// `IRandomBeaconConsumer` interface to ensure the correct callback function\n    /// signature.\n    /// @param callbackGas Gas required for the callback.\n    /// The customer needs to ensure they provide a sufficient callback gas\n    /// to cover the gas fee of executing the callback. Any surplus is returned\n    /// to the customer. If the callback gas amount turns to be not enough to\n    /// execute the callback, callback execution is skipped.\n    /// @return An uint256 representing uniquely generated relay request ID\n    function requestRelayEntry(address callbackContract, uint256 callbackGas)\n        external\n        payable\n        returns (uint256);\n\n    /// @notice Submits a request to generate a new relay entry. Emits\n    /// `RelayEntryGenerated(uint256 requestId, uint256 entry)` event for the\n    /// generated entry.\n    ///\n    /// @dev Beacon does not support concurrent relay requests. No new requests\n    /// should be made while the beacon is already processing another request.\n    /// Requests made while the beacon is busy will be rejected and the\n    /// transaction reverted.\n    ///\n    /// @return An uint256 representing uniquely generated relay request ID\n    function requestRelayEntry() external payable returns (uint256);\n}\n\n\n/// @title Keep Random Beacon Consumer\n///\n/// @notice Receives Keep Random Beacon relay entries with `__beaconCallback`\n/// function. Contract implementing this interface does not have to be the one\n/// requesting relay entry but it is the one receiving the requested relay entry\n/// once it is produced.\n///\n/// @dev Use this interface to indicate the contract receives relay entries from\n/// the beacon and to ensure the correctness of callback function signature.\ninterface IRandomBeaconConsumer {\n    /// @notice Receives relay entry produced by Keep Random Beacon. This function\n    /// should be called only by Keep Random Beacon.\n    ///\n    /// @param relayEntry Relay entry (random number) produced by Keep Random\n    /// Beacon.\n    function __beaconCallback(uint256 relayEntry) external;\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n * available, which can be aplied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n"
    },
    "solidity/contracts/CandidatesPools.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@keep-network/sortition-pools/contracts/AbstractSortitionPool.sol\";\n\ncontract CandidatesPools {\n    // Notification that a new sortition pool has been created.\n    event SortitionPoolCreated(\n        address indexed application,\n        address sortitionPool\n    );\n\n    // Mapping of pools with registered member candidates for each application.\n    mapping(address => address) candidatesPools; // application -> candidates pool\n\n    /// @notice Creates new sortition pool for the application.\n    /// @dev Emits an event after sortition pool creation.\n    /// @param _application Address of the application.\n    /// @return Address of the created sortition pool contract.\n    function createSortitionPool(address _application)\n        external\n        returns (address)\n    {\n        require(\n            candidatesPools[_application] == address(0),\n            \"Sortition pool already exists\"\n        );\n\n        address sortitionPoolAddress = newSortitionPool(_application);\n\n        candidatesPools[_application] = sortitionPoolAddress;\n\n        emit SortitionPoolCreated(_application, sortitionPoolAddress);\n\n        return candidatesPools[_application];\n    }\n\n    /// @notice Register caller as a candidate to be selected as keep member\n    /// for the provided customer application.\n    /// @dev If caller is already registered it returns without any changes.\n    /// @param _application Address of the application.\n    function registerMemberCandidate(address _application) external {\n        AbstractSortitionPool candidatesPool = AbstractSortitionPool(\n            getSortitionPool(_application)\n        );\n\n        address operator = msg.sender;\n        if (!candidatesPool.isOperatorInPool(operator)) {\n            candidatesPool.joinPool(operator);\n        }\n    }\n\n    /// @notice Checks if operator's details in the member candidates pool are\n    /// up to date for the given application. If not update operator status\n    /// function should be called by the one who is monitoring the status.\n    /// @param _operator Operator's address.\n    /// @param _application Customer application address.\n    function isOperatorUpToDate(address _operator, address _application)\n        external\n        view\n        returns (bool)\n    {\n        return\n            getSortitionPoolForOperator(_operator, _application)\n                .isOperatorUpToDate(_operator);\n    }\n\n    /// @notice Invokes update of operator's details in the member candidates pool\n    /// for the given application\n    /// @param _operator Operator's address.\n    /// @param _application Customer application address.\n    function updateOperatorStatus(address _operator, address _application)\n        external\n    {\n        getSortitionPoolForOperator(_operator, _application)\n            .updateOperatorStatus(_operator);\n    }\n\n    /// @notice Gets the sortition pool address for the given application.\n    /// @dev Reverts if sortition does not exist for the application.\n    /// @param _application Address of the application.\n    /// @return Address of the sortition pool contract.\n    function getSortitionPool(address _application)\n        public\n        view\n        returns (address)\n    {\n        require(\n            candidatesPools[_application] != address(0),\n            \"No pool found for the application\"\n        );\n\n        return candidatesPools[_application];\n    }\n\n    /// @notice Checks if operator is registered as a candidate for the given\n    /// customer application.\n    /// @param _operator Operator's address.\n    /// @param _application Customer application address.\n    /// @return True if operator is already registered in the candidates pool,\n    /// false otherwise.\n    function isOperatorRegistered(address _operator, address _application)\n        public\n        view\n        returns (bool)\n    {\n        if (candidatesPools[_application] == address(0)) {\n            return false;\n        }\n\n        AbstractSortitionPool candidatesPool = AbstractSortitionPool(\n            candidatesPools[_application]\n        );\n\n        return candidatesPool.isOperatorRegistered(_operator);\n    }\n\n    /// @notice Checks if given operator is eligible for the given application.\n    /// @param _operator Operator's address.\n    /// @param _application Customer application address.\n    function isOperatorEligible(address _operator, address _application)\n        public\n        view\n        returns (bool)\n    {\n        if (candidatesPools[_application] == address(0)) {\n            return false;\n        }\n\n        AbstractSortitionPool candidatesPool = AbstractSortitionPool(\n            candidatesPools[_application]\n        );\n\n        return candidatesPool.isOperatorEligible(_operator);\n    }\n\n    /// @notice Gets the total weight of operators\n    /// in the sortition pool for the given application.\n    /// @dev Reverts if sortition does not exits for the application.\n    /// @param _application Address of the application.\n    /// @return The sum of all registered operators' weights in the pool.\n    /// Reverts if sortition pool for the application does not exist.\n    function getSortitionPoolWeight(address _application)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            AbstractSortitionPool(getSortitionPool(_application)).totalWeight();\n    }\n\n    /// @notice Creates new sortition pool for the application.\n    /// @dev Have to be implemented by keep factory to call desired sortition\n    /// pool factory.\n    /// @param _application Address of the application.\n    /// @return Address of the created sortition pool contract.\n    function newSortitionPool(address _application) internal returns (address);\n\n    /// @notice Gets bonded sortition pool of specific application for the\n    /// operator.\n    /// @dev Reverts if the operator is not registered for the application.\n    /// @param _operator Operator's address.\n    /// @param _application Customer application address.\n    /// @return Bonded sortition pool.\n    function getSortitionPoolForOperator(\n        address _operator,\n        address _application\n    ) internal view returns (AbstractSortitionPool) {\n        require(\n            isOperatorRegistered(_operator, _application),\n            \"Operator not registered for the application\"\n        );\n\n        return AbstractSortitionPool(candidatesPools[_application]);\n    }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/AbstractSortitionPool.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./GasStation.sol\";\nimport \"./RNG.sol\";\nimport \"./SortitionTree.sol\";\nimport \"./DynamicArray.sol\";\nimport \"./api/IStaking.sol\";\n\n/// @title Abstract Sortition Pool\n/// @notice Abstract contract encapsulating common logic of all sortition pools.\n/// @dev Inheriting implementations are expected to implement getEligibleWeight\n/// function.\ncontract AbstractSortitionPool is SortitionTree, GasStation {\n  using Leaf for uint256;\n  using Position for uint256;\n  using DynamicArray for DynamicArray.UintArray;\n  using DynamicArray for DynamicArray.AddressArray;\n  using RNG for RNG.State;\n\n  enum Decision {\n    Select, // Add to the group, and use new seed\n    Skip, // Retry with same seed, skip this leaf\n    Delete, // Retry with same seed, delete this leaf\n    UpdateRetry, // Retry with same seed, update this leaf\n    UpdateSelect // Select and reseed, but also update this leaf\n  }\n\n  struct Fate {\n    Decision decision;\n    // The new weight of the leaf if Decision is Update*, otherwise 0\n    uint256 maybeWeight;\n  }\n\n  // Require 10 blocks after joining before the operator can be selected for\n  // a group. This reduces the degrees of freedom miners and other\n  // front-runners have in conducting pool-bumping attacks.\n  //\n  // We don't use the stack of empty leaves until we run out of space on the\n  // rightmost leaf (i.e. after 2 million operators have joined the pool).\n  // It means all insertions are at the right end, so one can't reorder\n  // operators already in the pool until the pool has been filled once.\n  // Because the index is calculated by taking the minimum number of required\n  // random bits, and seeing if it falls in the range of the total pool weight,\n  // the only scenarios where insertions on the right matter are if it crosses\n  // a power of two threshold for the total weight and unlocks another random\n  // bit, or if a random number that would otherwise be discarded happens to\n  // fall within that space.\n  uint256 constant INIT_BLOCKS = 10;\n\n  uint256 constant GAS_DEPOSIT_SIZE = 1;\n\n  /// @notice The number of blocks that must be mined before the operator who\n  // joined the pool is eligible for work selection.\n  function operatorInitBlocks() public pure returns (uint256) {\n    return INIT_BLOCKS;\n  }\n\n  // Return whether the operator is eligible for the pool.\n  function isOperatorEligible(address operator) public view returns (bool) {\n    return getEligibleWeight(operator) > 0;\n  }\n\n  // Return whether the operator is present in the pool.\n  function isOperatorInPool(address operator) public view returns (bool) {\n    return getFlaggedLeafPosition(operator) != 0;\n  }\n\n  // Return whether the operator's weight in the pool\n  // matches their eligible weight.\n  function isOperatorUpToDate(address operator) public view returns (bool) {\n    return getEligibleWeight(operator) == getPoolWeight(operator);\n  }\n\n  // Returns whether the operator has passed the initialization blocks period\n  // to be eligible for the work selection. Reverts if the operator is not in\n  // the pool.\n  function isOperatorInitialized(address operator) public view returns (bool) {\n    require(isOperatorInPool(operator), \"Operator is not in the pool\");\n\n    uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n    uint256 leafPosition = flaggedPosition.unsetFlag();\n    uint256 leaf = leaves[leafPosition];\n\n    return isLeafInitialized(leaf);\n  }\n\n  // Return the weight of the operator in the pool,\n  // which may or may not be out of date.\n  function getPoolWeight(address operator) public view returns (uint256) {\n    uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n    if (flaggedPosition == 0) {\n      return 0;\n    } else {\n      uint256 leafPosition = flaggedPosition.unsetFlag();\n      uint256 leafWeight = leaves[leafPosition].weight();\n      return leafWeight;\n    }\n  }\n\n  // Add an operator to the pool,\n  // reverting if the operator is already present.\n  function joinPool(address operator) public {\n    uint256 eligibleWeight = getEligibleWeight(operator);\n    require(eligibleWeight > 0, \"Operator not eligible\");\n\n    depositGas(operator);\n    insertOperator(operator, eligibleWeight);\n  }\n\n  // Update the operator's weight if present and eligible,\n  // or remove from the pool if present and ineligible.\n  function updateOperatorStatus(address operator) public {\n    uint256 eligibleWeight = getEligibleWeight(operator);\n    uint256 inPoolWeight = getPoolWeight(operator);\n\n    require(eligibleWeight != inPoolWeight, \"Operator already up to date\");\n\n    if (eligibleWeight == 0) {\n      removeOperator(operator);\n      releaseGas(operator);\n    } else {\n      updateOperator(operator, eligibleWeight);\n    }\n  }\n\n  function generalizedSelectGroup(\n    uint256 groupSize,\n    bytes32 seed,\n    // This uint256 is actually a void pointer.\n    // We can't pass a SelectionParams,\n    // because the implementation of the SelectionParams struct\n    // can vary between different concrete sortition pool implementations.\n    //\n    // Whatever SelectionParams struct is used by the concrete contract\n    // should be created in the `selectGroup`/`selectSetGroup` function,\n    // then coerced into a uint256 to be passed into this function.\n    // The paramsPtr is then passed to the `decideFate` implementation\n    // which can coerce it back into the concrete SelectionParams.\n    // This allows `generalizedSelectGroup`\n    // to work with any desired eligibility logic.\n    uint256 paramsPtr,\n    bool noDuplicates\n  ) internal returns (address[] memory) {\n    uint256 _root = root;\n    bool rootChanged = false;\n\n    DynamicArray.AddressArray memory selected;\n    selected = DynamicArray.addressArray(groupSize);\n\n    RNG.State memory rng;\n    rng = RNG.initialize(seed, _root.sumWeight(), groupSize);\n\n    while (selected.array.length < groupSize) {\n      rng.generateNewIndex();\n\n      (uint256 leafPosition, uint256 startingIndex) = pickWeightedLeaf(\n        rng.currentMappedIndex,\n        _root\n      );\n\n      uint256 leaf = leaves[leafPosition];\n      address operator = leaf.operator();\n      uint256 leafWeight = leaf.weight();\n\n      Fate memory fate = decideFate(leaf, selected, paramsPtr);\n\n      if (fate.decision == Decision.Select) {\n        selected.arrayPush(operator);\n        if (noDuplicates) {\n          rng.addSkippedInterval(startingIndex, leafWeight);\n        }\n        rng.reseed(seed, selected.array.length);\n        continue;\n      }\n      if (fate.decision == Decision.Skip) {\n        rng.addSkippedInterval(startingIndex, leafWeight);\n        continue;\n      }\n      if (fate.decision == Decision.Delete) {\n        // Update the RNG\n        rng.updateInterval(startingIndex, leafWeight, 0);\n        // Remove the leaf and update root\n        _root = removeLeaf(leafPosition, _root);\n        rootChanged = true;\n        // Remove the record of the operator's leaf and release gas\n        removeLeafPositionRecord(operator);\n        releaseGas(operator);\n        continue;\n      }\n      if (fate.decision == Decision.UpdateRetry) {\n        _root = setLeaf(leafPosition, leaf.setWeight(fate.maybeWeight), _root);\n        rootChanged = true;\n        rng.updateInterval(startingIndex, leafWeight, fate.maybeWeight);\n        continue;\n      }\n      if (fate.decision == Decision.UpdateSelect) {\n        _root = setLeaf(leafPosition, leaf.setWeight(fate.maybeWeight), _root);\n        rootChanged = true;\n        selected.arrayPush(operator);\n        rng.updateInterval(startingIndex, leafWeight, fate.maybeWeight);\n        if (noDuplicates) {\n          rng.addSkippedInterval(startingIndex, fate.maybeWeight);\n        }\n        rng.reseed(seed, selected.array.length);\n        continue;\n      }\n    }\n    if (rootChanged) {\n      root = _root;\n    }\n    return selected.array;\n  }\n\n  function isLeafInitialized(uint256 leaf) internal view returns (bool) {\n    uint256 createdAt = leaf.creationBlock();\n\n    return block.number > (createdAt + operatorInitBlocks());\n  }\n\n  // Return the eligible weight of the operator,\n  // which may differ from the weight in the pool.\n  // Return 0 if ineligible.\n  function getEligibleWeight(address operator) internal view returns (uint256);\n\n  function decideFate(\n    uint256 leaf,\n    DynamicArray.AddressArray memory selected,\n    uint256 paramsPtr\n  ) internal view returns (Fate memory);\n\n  function gasDepositSize() internal pure returns (uint256) {\n    return GAS_DEPOSIT_SIZE;\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/GasStation.sol": {
      "content": "pragma solidity 0.5.17;\n\ncontract GasStation {\n  mapping(address => mapping(uint256 => uint256)) gasDeposits;\n\n  function depositGas(address addr) internal {\n    setDeposit(addr, 1);\n  }\n\n  function releaseGas(address addr) internal {\n    setDeposit(addr, 0);\n  }\n\n  function setDeposit(address addr, uint256 val) internal {\n    for (uint256 i = 0; i < gasDepositSize(); i++) {\n      gasDeposits[addr][i] = val;\n    }\n  }\n\n  function gasDepositSize() internal pure returns (uint256);\n}\n"
    },
    "@keep-network/sortition-pools/contracts/RNG.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./Leaf.sol\";\nimport \"./Interval.sol\";\nimport \"./DynamicArray.sol\";\n\nlibrary RNG {\n  using DynamicArray for DynamicArray.UintArray;\n  ////////////////////////////////////////////////////////////////////////////\n  // Parameters for configuration\n\n  // How many bits a position uses per level of the tree;\n  // each branch of the tree contains 2**SLOT_BITS slots.\n  uint256 constant SLOT_BITS = 3;\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Derived constants, do not touch\n  uint256 constant SLOT_COUNT = 2**SLOT_BITS;\n  uint256 constant WEIGHT_WIDTH = 256 / SLOT_COUNT;\n  ////////////////////////////////////////////////////////////////////////////\n\n  struct State {\n    // RNG output\n    uint256 currentMappedIndex;\n    uint256 currentTruncatedIndex;\n    // The random bytes used to derive indices\n    bytes32 currentSeed;\n    // The full range of indices;\n    // generated random numbers are in [0, fullRange).\n    uint256 fullRange;\n    // The truncated range of indices;\n    // how many non-skipped indices are left to consider.\n    // Random indices are generated within this range,\n    // and mapped to the full range by skipping the specified intervals.\n    uint256 truncatedRange;\n    DynamicArray.UintArray skippedIntervals;\n  }\n\n  function initialize(\n    bytes32 seed,\n    uint256 range,\n    uint256 expectedSkippedCount\n  ) internal view returns (State memory self) {\n    self = State(\n      0,\n      0,\n      seed,\n      range,\n      range,\n      DynamicArray.uintArray(expectedSkippedCount)\n    );\n    reseed(self, seed, 0);\n    return self;\n  }\n\n  function reseed(\n    State memory self,\n    bytes32 seed,\n    uint256 nonce\n  ) internal view {\n    self.currentSeed = keccak256(\n      abi.encodePacked(seed, nonce, address(this), \"reseed\")\n    );\n  }\n\n  function retryIndex(State memory self) internal view {\n    uint256 truncatedIndex = self.currentTruncatedIndex;\n    if (self.currentTruncatedIndex < self.truncatedRange) {\n      self.currentMappedIndex = Interval.skip(\n        truncatedIndex,\n        self.skippedIntervals\n      );\n    } else {\n      generateNewIndex(self);\n    }\n  }\n\n  function updateInterval(\n    State memory self,\n    uint256 startIndex,\n    uint256 oldWeight,\n    uint256 newWeight\n  ) internal pure {\n    int256 weightDiff = int256(newWeight) - int256(oldWeight);\n    uint256 effectiveStartIndex = startIndex + newWeight;\n    self.truncatedRange = uint256(int256(self.truncatedRange) + weightDiff);\n    self.fullRange = uint256(int256(self.fullRange) + weightDiff);\n    Interval.remapIndices(\n      effectiveStartIndex,\n      weightDiff,\n      self.skippedIntervals\n    );\n  }\n\n  function addSkippedInterval(\n    State memory self,\n    uint256 startIndex,\n    uint256 weight\n  ) internal pure {\n    self.truncatedRange -= weight;\n    Interval.insert(self.skippedIntervals, Interval.make(startIndex, weight));\n  }\n\n  /// @notice Generate a new index based on the current seed,\n  /// without reseeding first.\n  /// This will result in the same truncated index as before\n  /// if it still fits in the current truncated range.\n  function generateNewIndex(State memory self) internal view {\n    uint256 _truncatedRange = self.truncatedRange;\n    require(_truncatedRange > 0, \"Not enough operators in pool\");\n    uint256 bits = bitsRequired(_truncatedRange);\n    uint256 truncatedIndex = truncate(bits, uint256(self.currentSeed));\n    while (truncatedIndex >= _truncatedRange) {\n      self.currentSeed = keccak256(\n        abi.encodePacked(self.currentSeed, address(this), \"generate\")\n      );\n      truncatedIndex = truncate(bits, uint256(self.currentSeed));\n    }\n    self.currentTruncatedIndex = truncatedIndex;\n    self.currentMappedIndex = Interval.skip(\n      truncatedIndex,\n      self.skippedIntervals\n    );\n  }\n\n  /// @notice Calculate how many bits are required\n  /// for an index in the range `[0 .. range-1]`.\n  ///\n  /// @param range The upper bound of the desired range, exclusive.\n  ///\n  /// @return uint The smallest number of bits\n  /// that can contain the number `range-1`.\n  function bitsRequired(uint256 range) internal pure returns (uint256) {\n    uint256 bits = WEIGHT_WIDTH - 1;\n\n    // Left shift by `bits`,\n    // so we have a 1 in the (bits + 1)th least significant bit\n    // and 0 in other bits.\n    // If this number is equal or greater than `range`,\n    // the range [0, range-1] fits in `bits` bits.\n    //\n    // Because we loop from high bits to low bits,\n    // we find the highest number of bits that doesn't fit the range,\n    // and return that number + 1.\n    while (1 << bits >= range) {\n      bits--;\n    }\n\n    return bits + 1;\n  }\n\n  /// @notice Truncate `input` to the `bits` least significant bits.\n  function truncate(uint256 bits, uint256 input)\n    internal\n    pure\n    returns (uint256)\n  {\n    return input & ((1 << bits) - 1);\n  }\n\n  /// @notice Get an index in the range `[0 .. range-1]`\n  /// and the new state of the RNG,\n  /// using the provided `state` of the RNG.\n  ///\n  /// @param range The upper bound of the index, exclusive.\n  ///\n  /// @param state The previous state of the RNG.\n  /// The initial state needs to be obtained\n  /// from a trusted randomness oracle (the random beacon),\n  /// or from a chain of earlier calls to `RNG.getIndex()`\n  /// on an originally trusted seed.\n  ///\n  /// @dev Calculates the number of bits required for the desired range,\n  /// takes the least significant bits of `state`\n  /// and checks if the obtained index is within the desired range.\n  /// The original state is hashed with `keccak256` to get a new state.\n  /// If the index is outside the range,\n  /// the function retries until it gets a suitable index.\n  ///\n  /// @return index A random integer between `0` and `range - 1`, inclusive.\n  ///\n  /// @return newState The new state of the RNG.\n  /// When `getIndex()` is called one or more times,\n  /// care must be taken to always use the output `state`\n  /// of the most recent call as the input `state` of a subsequent call.\n  /// At the end of a transaction calling `RNG.getIndex()`,\n  /// the previous stored state must be overwritten with the latest output.\n  function getIndex(uint256 range, bytes32 state)\n    internal\n    view\n    returns (uint256, bytes32)\n  {\n    uint256 bits = bitsRequired(range);\n    bool found = false;\n    uint256 index = 0;\n    bytes32 newState = state;\n    while (!found) {\n      index = truncate(bits, uint256(newState));\n      newState = keccak256(abi.encodePacked(newState, address(this)));\n      if (index < range) {\n        found = true;\n      }\n    }\n    return (index, newState);\n  }\n\n  /// @notice Return an index corresponding to a new, unique leaf.\n  ///\n  /// @dev Gets a new index in a truncated range\n  /// with the weights of all previously selected leaves subtracted.\n  /// This index is then mapped to the full range of possible indices,\n  /// skipping the ranges covered by previous leaves.\n  ///\n  /// @param range The full range in which the unique index should be.\n  ///\n  /// @param state The RNG state.\n  ///\n  /// @param previousLeaves List of indices and weights\n  /// corresponding to the _first_ index of each previously selected leaf,\n  /// and the weight of the same leaf.\n  /// An index number `i` is a starting index of leaf `o`\n  /// if querying for index `i` in the sortition pool returns `o`,\n  /// but querying for `i-1` returns a different leaf.\n  /// This list REALLY needs to be sorted from smallest to largest.\n  ///\n  /// @param sumPreviousWeights The sum of the weights of previous leaves.\n  /// Could be calculated from `previousLeafWeights`\n  /// but providing it explicitly makes the function a bit simpler.\n  ///\n  /// @return uniqueIndex An index in [0, range) that does not overlap\n  /// any of the previousLeaves,\n  /// as determined by the range [index, index + weight).\n  function getUniqueIndex(\n    uint256 range,\n    bytes32 state,\n    uint256[] memory previousLeaves,\n    uint256 sumPreviousWeights\n  ) internal view returns (uint256 uniqueIndex, bytes32 newState) {\n    // Get an index in the truncated range.\n    // The truncated range covers only new leaves,\n    // but has to be mapped to the actual range of indices.\n    uint256 truncatedRange = range - sumPreviousWeights;\n    uint256 truncatedIndex;\n    (truncatedIndex, newState) = getIndex(truncatedRange, state);\n\n    // Map the truncated index to the available unique indices.\n    uniqueIndex = Interval.skip(\n      truncatedIndex,\n      DynamicArray.convert(previousLeaves)\n    );\n\n    return (uniqueIndex, newState);\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Leaf.sol": {
      "content": "pragma solidity 0.5.17;\n\nlibrary Leaf {\n  ////////////////////////////////////////////////////////////////////////////\n  // Parameters for configuration\n\n  // How many bits a position uses per level of the tree;\n  // each branch of the tree contains 2**SLOT_BITS slots.\n  uint256 constant SLOT_BITS = 3;\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Derived constants, do not touch\n  uint256 constant SLOT_COUNT = 2**SLOT_BITS;\n  uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;\n  uint256 constant SLOT_MAX = (2**SLOT_WIDTH) - 1;\n\n  uint256 constant WEIGHT_WIDTH = SLOT_WIDTH;\n  uint256 constant WEIGHT_MAX = SLOT_MAX;\n\n  uint256 constant BLOCKHEIGHT_WIDTH = 96 - WEIGHT_WIDTH;\n  uint256 constant BLOCKHEIGHT_MAX = (2**BLOCKHEIGHT_WIDTH) - 1;\n\n  ////////////////////////////////////////////////////////////////////////////\n\n  function make(\n    address _operator,\n    uint256 _creationBlock,\n    uint256 _weight\n  ) internal pure returns (uint256) {\n    // Converting a bytesX type into a larger type\n    // adds zero bytes on the right.\n    uint256 op = uint256(bytes32(bytes20(_operator)));\n    // Bitwise AND the weight to erase\n    // all but the 32 least significant bits\n    uint256 wt = _weight & WEIGHT_MAX;\n    // Erase all but the 64 least significant bits,\n    // then shift left by 32 bits to make room for the weight\n    uint256 cb = (_creationBlock & BLOCKHEIGHT_MAX) << WEIGHT_WIDTH;\n    // Bitwise OR them all together to get\n    // [address operator || uint64 creationBlock || uint32 weight]\n    return (op | cb | wt);\n  }\n\n  function operator(uint256 leaf) internal pure returns (address) {\n    // Converting a bytesX type into a smaller type\n    // truncates it on the right.\n    return address(bytes20(bytes32(leaf)));\n  }\n\n  /// @notice Return the block number the leaf was created in.\n  function creationBlock(uint256 leaf) internal pure returns (uint256) {\n    return ((leaf >> WEIGHT_WIDTH) & BLOCKHEIGHT_MAX);\n  }\n\n  function weight(uint256 leaf) internal pure returns (uint256) {\n    // Weight is stored in the 32 least significant bits.\n    // Bitwise AND ensures that we only get the contents of those bits.\n    return (leaf & WEIGHT_MAX);\n  }\n\n  function setWeight(uint256 leaf, uint256 newWeight)\n    internal\n    pure\n    returns (uint256)\n  {\n    return ((leaf & ~WEIGHT_MAX) | (newWeight & WEIGHT_MAX));\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Interval.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./Leaf.sol\";\nimport \"./DynamicArray.sol\";\n\nlibrary Interval {\n  using DynamicArray for DynamicArray.UintArray;\n  ////////////////////////////////////////////////////////////////////////////\n  // Parameters for configuration\n\n  // How many bits a position uses per level of the tree;\n  // each branch of the tree contains 2**SLOT_BITS slots.\n  uint256 constant SLOT_BITS = 3;\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Derived constants, do not touch\n  uint256 constant SLOT_COUNT = 2**SLOT_BITS;\n  uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;\n  uint256 constant SLOT_MAX = (2**SLOT_WIDTH) - 1;\n\n  uint256 constant WEIGHT_WIDTH = SLOT_WIDTH;\n  uint256 constant WEIGHT_MAX = SLOT_MAX;\n\n  uint256 constant START_INDEX_WIDTH = WEIGHT_WIDTH;\n  uint256 constant START_INDEX_MAX = WEIGHT_MAX;\n  uint256 constant START_INDEX_SHIFT = WEIGHT_WIDTH;\n\n  ////////////////////////////////////////////////////////////////////////////\n\n  // Interval stores information about a selected interval\n  // inside a single uint256 in a manner similar to Leaf\n  // but optimized for use within group selection\n  //\n  // The information stored consists of:\n  // - weight\n  // - starting index\n\n  function make(uint256 startingIndex, uint256 weight)\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 idx = (startingIndex & START_INDEX_MAX) << START_INDEX_SHIFT;\n    uint256 wt = weight & WEIGHT_MAX;\n    return (idx | wt);\n  }\n\n  function opWeight(uint256 op) internal pure returns (uint256) {\n    return (op & WEIGHT_MAX);\n  }\n\n  // Return the starting index of the interval\n  function index(uint256 a) internal pure returns (uint256) {\n    return ((a >> WEIGHT_WIDTH) & START_INDEX_MAX);\n  }\n\n  function setIndex(uint256 op, uint256 i) internal pure returns (uint256) {\n    uint256 shiftedIndex = ((i & START_INDEX_MAX) << WEIGHT_WIDTH);\n    return (op & (~(START_INDEX_MAX << WEIGHT_WIDTH))) | shiftedIndex;\n  }\n\n  function insert(DynamicArray.UintArray memory intervals, uint256 interval)\n    internal\n    pure\n  {\n    uint256 tempInterval = interval;\n    for (uint256 i = 0; i < intervals.array.length; i++) {\n      uint256 thisInterval = intervals.array[i];\n      // We can compare the raw underlying uint256 values\n      // because the starting index is stored\n      // in the most significant nonzero bits.\n      if (tempInterval < thisInterval) {\n        intervals.array[i] = tempInterval;\n        tempInterval = thisInterval;\n      }\n    }\n    intervals.arrayPush(tempInterval);\n  }\n\n  function skip(uint256 truncatedIndex, DynamicArray.UintArray memory intervals)\n    internal\n    pure\n    returns (uint256 mappedIndex)\n  {\n    mappedIndex = truncatedIndex;\n    for (uint256 i = 0; i < intervals.array.length; i++) {\n      uint256 interval = intervals.array[i];\n      // If the index is greater than the starting index of the `i`th leaf,\n      // we need to skip that leaf.\n      if (mappedIndex >= index(interval)) {\n        // Add the weight of this previous leaf to the index,\n        // ensuring that we skip the leaf.\n        mappedIndex += Leaf.weight(interval);\n      } else {\n        break;\n      }\n    }\n    return mappedIndex;\n  }\n\n  /// @notice Recalculate the starting indices of the previousLeaves\n  /// when an interval is removed or added at the specified index.\n  /// @dev Applies weightDiff to each starting index in previousLeaves\n  /// that exceeds affectedStartingIndex.\n  /// @param affectedStartingIndex The starting index of the interval.\n  /// @param weightDiff The difference in weight;\n  /// negative for a deleted interval,\n  /// positive for an added interval.\n  /// @param previousLeaves The starting indices and weights\n  /// of the previously selected leaves.\n  /// @return The starting indices of the previous leaves\n  /// in a tree with the affected interval updated.\n  function remapIndices(\n    uint256 affectedStartingIndex,\n    int256 weightDiff,\n    DynamicArray.UintArray memory previousLeaves\n  ) internal pure {\n    uint256 nPreviousLeaves = previousLeaves.array.length;\n\n    for (uint256 i = 0; i < nPreviousLeaves; i++) {\n      uint256 interval = previousLeaves.array[i];\n      uint256 startingIndex = index(interval);\n      // If index is greater than the index of the affected interval,\n      // update the starting index by the weight change.\n      if (startingIndex > affectedStartingIndex) {\n        uint256 newIndex = uint256(int256(startingIndex) + weightDiff);\n        previousLeaves.array[i] = setIndex(interval, newIndex);\n      }\n    }\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/DynamicArray.sol": {
      "content": "pragma solidity 0.5.17;\n\nlibrary DynamicArray {\n  // The in-memory dynamic Array is implemented\n  // by recording the amount of allocated memory\n  // separately from the length of the array.\n  // This gives us a perfectly normal in-memory array\n  // with all the behavior we're used to,\n  // but also makes O(1) `push` operations possible\n  // by expanding into the preallocated memory.\n  //\n  // When we run out of preallocated memory when trying to `push`,\n  // we allocate twice as much and copy the array over.\n  // With linear allocation costs this would amortize to O(1)\n  // but with EVM allocations being actually quadratic\n  // the real performance is a very technical O(N).\n  // Nonetheless, this is reasonably performant in practice.\n  //\n  // A dynamic array can be useful\n  // even when you aren't dealing with an unknown number of items.\n  // Because the array tracks the allocated space\n  // separately from the number of stored items,\n  // you can push items into the dynamic array\n  // and iterate over the currently present items\n  // without tracking their number yourself,\n  // or using a special null value for empty elements.\n  //\n  // Because Solidity doesn't really have useful safety features,\n  // only enough superficial inconveniences\n  // to lull yourself into a false sense of security,\n  // dynamic arrays require a bit of care to handle appropriately.\n  //\n  // First of all,\n  // dynamic arrays must not be created or modified manually.\n  // Use `uintArray(length)`, or `convert(existingArray)`\n  // which will perform a safe and efficient conversion for you.\n  // This also applies to storage;\n  // in-memory dynamic arrays are for efficient in-memory operations only,\n  // and it is unnecessary to store dynamic arrays.\n  // Use a regular `uint256[]` instead.\n  // The contents of `array` may be written like `dynamicArray.array[i] = x`\n  // but never reassign the `array` pointer itself\n  // nor mess with `allocatedMemory` in any way whatsoever.\n  // If you fail to follow these precautions,\n  // dragons inhabiting the no-man's-land\n  // between the array as it's seen by Solidity\n  // and the next thing allocated after it\n  // will be unleashed to wreak havoc upon your memory buffers.\n  //\n  // Second,\n  // because the `array` may be reassigned when pushing,\n  // the following pattern is unsafe:\n  // ```\n  // UintArray dynamicArray;\n  // uint256 len = dynamicArray.array.length;\n  // uint256[] danglingPointer = dynamicArray.array;\n  // danglingPointer[0] = x;\n  // dynamicArray.push(y);\n  // danglingPointer[0] = z;\n  // uint256 surprise = danglingPointer[len];\n  // ```\n  // After the above code block,\n  // `dynamicArray.array[0]` may be either `x` or `z`,\n  // and `surprise` may be `y` or out of bounds.\n  // This will not share your address space with a malevolent agent of chaos,\n  // but it will cause entirely avoidable scratchings of the head.\n  //\n  // Dynamic arrays should be safe to use like ordinary arrays\n  // if you always refer to the array field of the dynamic array\n  // when reading or writing values:\n  // ```\n  // UintArray dynamicArray;\n  // uint256 len = dynamicArray.array.length;\n  // dynamicArray.array[0] = x;\n  // dynamicArray.push(y);\n  // dynamicArray.array[0] = z;\n  // uint256 notSurprise = dynamicArray.array[len];\n  // ```\n  // After this code `notSurprise` is reliably `y`,\n  // and `dynamicArray.array[0]` is `z`.\n  struct UintArray {\n    // XXX: Do not modify this value.\n    // In fact, do not even read it.\n    // There is never a legitimate reason to do anything with this value.\n    // She is quiet and wishes to be left alone.\n    // The silent vigil of `allocatedMemory`\n    // is the only thing standing between your contract\n    // and complete chaos in its memory.\n    // Respect her wish or face the monstrosities she is keeping at bay.\n    uint256 allocatedMemory;\n    // Unlike her sharp and vengeful sister,\n    // `array` is safe to use normally\n    // for anything you might do with a normal `uint256[]`.\n    // Reads and loops will check bounds,\n    // and writing in individual indices like `myArray.array[i] = x`\n    // is perfectly fine.\n    // No curse will befall you as long as you obey this rule:\n    //\n    // XXX: Never try to replace her or separate her from her sister\n    // by writing down the accursed words\n    // `myArray.array = anotherArray` or `lonelyArray = myArray.array`.\n    //\n    // If you do, your cattle will be diseased,\n    // your children will be led astray in the woods,\n    // and your memory will be silently overwritten.\n    // Instead, give her a friend with\n    // `mySecondArray = convert(anotherArray)`,\n    // and call her by her family name first.\n    // She will recognize your respect\n    // and ward your memory against corruption.\n    uint256[] array;\n  }\n\n  struct AddressArray {\n    uint256 allocatedMemory;\n    address[] array;\n  }\n\n  /// @notice Create an empty dynamic array,\n  /// with preallocated memory for up to `length` elements.\n  /// @dev Knowing or estimating the preallocated length in advance\n  /// helps avoid frequent early allocations when filling the array.\n  /// @param length The number of items to preallocate space for.\n  /// @return A new dynamic array.\n  function uintArray(uint256 length) internal pure returns (UintArray memory) {\n    uint256[] memory array = _allocateUints(length);\n    return UintArray(length, array);\n  }\n\n  function addressArray(uint256 length)\n    internal\n    pure\n    returns (AddressArray memory)\n  {\n    address[] memory array = _allocateAddresses(length);\n    return AddressArray(length, array);\n  }\n\n  /// @notice Convert an existing non-dynamic array into a dynamic array.\n  /// @dev The dynamic array is created\n  /// with allocated memory equal to the length of the array.\n  /// @param array The array to convert.\n  /// @return A new dynamic array,\n  /// containing the contents of the argument `array`.\n  function convert(uint256[] memory array)\n    internal\n    pure\n    returns (UintArray memory)\n  {\n    return UintArray(array.length, array);\n  }\n\n  function convert(address[] memory array)\n    internal\n    pure\n    returns (AddressArray memory)\n  {\n    return AddressArray(array.length, array);\n  }\n\n  /// @notice Push `item` into the dynamic array.\n  /// @dev This function will be safe\n  /// as long as you haven't scorned either of the sisters.\n  /// If you have, the dragons will be released\n  /// to wreak havoc upon your memory.\n  /// A spell to dispel the curse exists,\n  /// but a sacred vow prohibits it from being shared\n  /// with those who do not know how to discover it on their own.\n  /// @param self The dynamic array to push into;\n  /// after the call it will be mutated in place to contain the item,\n  /// allocating more memory behind the scenes if necessary.\n  /// @param item The item you wish to push into the array.\n  function arrayPush(UintArray memory self, uint256 item) internal pure {\n    uint256 length = self.array.length;\n    uint256 allocLength = self.allocatedMemory;\n    // The dynamic array is full so we need to allocate more first.\n    // We check for >= instead of ==\n    // so that we can put the require inside the conditional,\n    // reducing the gas costs of `push` slightly.\n    if (length >= allocLength) {\n      // This should never happen if `allocatedMemory` isn't messed with.\n      require(length == allocLength, \"Array length exceeds allocation\");\n      // Allocate twice the original array length,\n      // then copy the contents over.\n      uint256 newMemory = length * 2;\n      uint256[] memory newArray = _allocateUints(newMemory);\n      _copy(newArray, self.array);\n      self.array = newArray;\n      self.allocatedMemory = newMemory;\n    }\n    // We have enough free memory so we can push into the array.\n    _push(self.array, item);\n  }\n\n  function arrayPush(AddressArray memory self, address item) internal pure {\n    uint256 length = self.array.length;\n    uint256 allocLength = self.allocatedMemory;\n    if (length >= allocLength) {\n      require(length == allocLength, \"Array length exceeds allocation\");\n      uint256 newMemory = length * 2;\n      address[] memory newArray = _allocateAddresses(newMemory);\n      _copy(newArray, self.array);\n      self.array = newArray;\n      self.allocatedMemory = newMemory;\n    }\n    _push(self.array, item);\n  }\n\n  /// @notice Pop the last item from the dynamic array,\n  /// removing it and decrementing the array length in place.\n  /// @dev This makes the dragons happy\n  /// as they have more space to roam.\n  /// Thus they have no desire to escape and ravage your buffers.\n  /// @param self The array to pop from.\n  /// @return item The previously last element in the array.\n  function arrayPop(UintArray memory self)\n    internal\n    pure\n    returns (uint256 item)\n  {\n    uint256[] memory array = self.array;\n    uint256 length = array.length;\n    require(length > 0, \"Can't pop from empty array\");\n    return _pop(array);\n  }\n\n  function arrayPop(AddressArray memory self)\n    internal\n    pure\n    returns (address item)\n  {\n    address[] memory array = self.array;\n    uint256 length = array.length;\n    require(length > 0, \"Can't pop from empty array\");\n    return _pop(array);\n  }\n\n  /// @notice Allocate an empty array,\n  /// reserving enough memory to safely store `length` items.\n  /// @dev The array starts with zero length,\n  /// but the allocated buffer has space for `length` words.\n  /// \"What be beyond the bounds of `array`?\" you may ask.\n  /// The answer is: dragons.\n  /// But do not worry,\n  /// for `Array.allocatedMemory` protects your EVM from them.\n  function _allocateUints(uint256 length)\n    private\n    pure\n    returns (uint256[] memory array)\n  {\n    // Calculate the size of the allocated block.\n    // Solidity arrays without a specified constant length\n    // (i.e. `uint256[]` instead of `uint256[8]`)\n    // store the length at the first memory position\n    // and the contents of the array after it,\n    // so we add 1 to the length to account for this.\n    uint256 inMemorySize = (length + 1) * 0x20;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      // Get some free memory\n      array := mload(0x40)\n      // Write a zero in the length field;\n      // we set the length elsewhere\n      // if we store anything in the array immediately.\n      // When we allocate we only know how many words we reserve,\n      // not how many actually get written.\n      mstore(array, 0)\n      // Move the free memory pointer\n      // to the end of the allocated block.\n      mstore(0x40, add(array, inMemorySize))\n    }\n    return array;\n  }\n\n  function _allocateAddresses(uint256 length)\n    private\n    pure\n    returns (address[] memory array)\n  {\n    uint256 inMemorySize = (length + 1) * 0x20;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      array := mload(0x40)\n      mstore(array, 0)\n      mstore(0x40, add(array, inMemorySize))\n    }\n    return array;\n  }\n\n  /// @notice Unsafe function to copy the contents of one array\n  /// into an empty initialized array\n  /// with sufficient free memory available.\n  function _copy(uint256[] memory dest, uint256[] memory src) private pure {\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      let length := mload(src)\n      let byteLength := mul(length, 0x20)\n      // Store the resulting length of the array.\n      mstore(dest, length)\n      // Maintain a write pointer\n      // for the current write location in the destination array\n      // by adding the 32 bytes for the array length\n      // to the starting location.\n      let writePtr := add(dest, 0x20)\n      // Stop copying when the write pointer reaches\n      // the length of the source array.\n      // We can track the endpoint either from the write or read pointer.\n      // This uses the write pointer\n      // because that's the way it was done\n      // in the (public domain) code I stole this from.\n      let end := add(writePtr, byteLength)\n\n      for {\n        // Initialize a read pointer to the start of the source array,\n        // 32 bytes into its memory.\n        let readPtr := add(src, 0x20)\n      } lt(writePtr, end) {\n        // Increase both pointers by 32 bytes each iteration.\n        writePtr := add(writePtr, 0x20)\n        readPtr := add(readPtr, 0x20)\n      } {\n        // Write the source array into the dest memory\n        // 32 bytes at a time.\n        mstore(writePtr, mload(readPtr))\n      }\n    }\n  }\n\n  function _copy(address[] memory dest, address[] memory src) private pure {\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      let length := mload(src)\n      let byteLength := mul(length, 0x20)\n      mstore(dest, length)\n      let writePtr := add(dest, 0x20)\n      let end := add(writePtr, byteLength)\n\n      for {\n        let readPtr := add(src, 0x20)\n      } lt(writePtr, end) {\n        writePtr := add(writePtr, 0x20)\n        readPtr := add(readPtr, 0x20)\n      } {\n        mstore(writePtr, mload(readPtr))\n      }\n    }\n  }\n\n  /// @notice Unsafe function to push past the limit of an array.\n  /// Only use with preallocated free memory.\n  function _push(uint256[] memory array, uint256 item) private pure {\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      // Get array length\n      let length := mload(array)\n      let newLength := add(length, 1)\n      // Calculate how many bytes the array takes in memory,\n      // including the length field.\n      // This is equal to 32 * the incremented length.\n      let arraySize := mul(0x20, newLength)\n      // Calculate the first memory position after the array\n      let nextPosition := add(array, arraySize)\n      // Store the item in the available position\n      mstore(nextPosition, item)\n      // Increment array length\n      mstore(array, newLength)\n    }\n  }\n\n  function _push(address[] memory array, address item) private pure {\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      let length := mload(array)\n      let newLength := add(length, 1)\n      let arraySize := mul(0x20, newLength)\n      let nextPosition := add(array, arraySize)\n      mstore(nextPosition, item)\n      mstore(array, newLength)\n    }\n  }\n\n  function _pop(uint256[] memory array) private pure returns (uint256 item) {\n    uint256 length = array.length;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      // Calculate the memory position of the last element\n      let lastPosition := add(array, mul(length, 0x20))\n      // Retrieve the last item\n      item := mload(lastPosition)\n      // Decrement array length\n      mstore(array, sub(length, 1))\n    }\n    return item;\n  }\n\n  function _pop(address[] memory array) private pure returns (address item) {\n    uint256 length = array.length;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      let lastPosition := add(array, mul(length, 0x20))\n      item := mload(lastPosition)\n      mstore(array, sub(length, 1))\n    }\n    return item;\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/SortitionTree.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./StackLib.sol\";\nimport \"./Branch.sol\";\nimport \"./Position.sol\";\nimport \"./Leaf.sol\";\n\ncontract SortitionTree {\n  using StackLib for uint256[];\n  using Branch for uint256;\n  using Position for uint256;\n  using Leaf for uint256;\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Parameters for configuration\n\n  // How many bits a position uses per level of the tree;\n  // each branch of the tree contains 2**SLOT_BITS slots.\n  uint256 constant SLOT_BITS = 3;\n  uint256 constant LEVELS = 7;\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Derived constants, do not touch\n  uint256 constant SLOT_COUNT = 2**SLOT_BITS;\n  uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;\n  uint256 constant SLOT_MAX = (2**SLOT_WIDTH) - 1;\n  uint256 constant POOL_CAPACITY = SLOT_COUNT**LEVELS;\n  ////////////////////////////////////////////////////////////////////////////\n\n  // implicit tree\n  // root 8\n  // level2 64\n  // level3 512\n  // level4 4k\n  // level5 32k\n  // level6 256k\n  // level7 2M\n  uint256 root;\n  mapping(uint256 => mapping(uint256 => uint256)) branches;\n  mapping(uint256 => uint256) leaves;\n\n  // the flagged (see setFlag() and unsetFlag() in Position.sol) positions\n  // of all operators present in the pool\n  mapping(address => uint256) flaggedLeafPosition;\n\n  // the leaf after the rightmost occupied leaf of each stack\n  uint256 rightmostLeaf;\n  // the empty leaves in each stack\n  // between 0 and the rightmost occupied leaf\n  uint256[] emptyLeaves;\n\n  constructor() public {\n    root = 0;\n    rightmostLeaf = 0;\n  }\n\n  // checks if operator is already registered in the pool\n  function isOperatorRegistered(address operator) public view returns (bool) {\n    return getFlaggedLeafPosition(operator) != 0;\n  }\n\n  // Sum the number of operators in each trunk\n  function operatorsInPool() public view returns (uint256) {\n    // Get the number of leaves that might be occupied;\n    // if `rightmostLeaf` equals `firstLeaf()` the tree must be empty,\n    // otherwise the difference between these numbers\n    // gives the number of leaves that may be occupied.\n    uint256 nPossiblyUsedLeaves = rightmostLeaf;\n    // Get the number of empty leaves\n    // not accounted for by the `rightmostLeaf`\n    uint256 nEmptyLeaves = emptyLeaves.getSize();\n\n    return (nPossiblyUsedLeaves - nEmptyLeaves);\n  }\n\n  function totalWeight() public view returns (uint256) {\n    return root.sumWeight();\n  }\n\n  function insertOperator(address operator, uint256 weight) internal {\n    require(\n      !isOperatorRegistered(operator),\n      \"Operator is already registered in the pool\"\n    );\n\n    uint256 position = getEmptyLeafPosition();\n    // Record the block the operator was inserted in\n    uint256 theLeaf = Leaf.make(operator, block.number, weight);\n\n    root = setLeaf(position, theLeaf, root);\n\n    // Without position flags,\n    // the position 0x000000 would be treated as empty\n    flaggedLeafPosition[operator] = position.setFlag();\n  }\n\n  function removeOperator(address operator) internal {\n    uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n    require(flaggedPosition != 0, \"Operator is not registered in the pool\");\n    uint256 unflaggedPosition = flaggedPosition.unsetFlag();\n    root = removeLeaf(unflaggedPosition, root);\n    removeLeafPositionRecord(operator);\n  }\n\n  function updateOperator(address operator, uint256 weight) internal {\n    require(\n      isOperatorRegistered(operator),\n      \"Operator is not registered in the pool\"\n    );\n\n    uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n    uint256 unflaggedPosition = flaggedPosition.unsetFlag();\n    updateLeaf(unflaggedPosition, weight);\n  }\n\n  function removeLeafPositionRecord(address operator) internal {\n    flaggedLeafPosition[operator] = 0;\n  }\n\n  function getFlaggedLeafPosition(address operator)\n    internal\n    view\n    returns (uint256)\n  {\n    return flaggedLeafPosition[operator];\n  }\n\n  function removeLeaf(uint256 position, uint256 _root)\n    internal\n    returns (uint256)\n  {\n    uint256 rightmostSubOne = rightmostLeaf - 1;\n    bool isRightmost = position == rightmostSubOne;\n\n    uint256 newRoot = setLeaf(position, 0, _root);\n\n    if (isRightmost) {\n      rightmostLeaf = rightmostSubOne;\n    } else {\n      emptyLeaves.stackPush(position);\n    }\n    return newRoot;\n  }\n\n  function updateLeaf(uint256 position, uint256 weight) internal {\n    uint256 oldLeaf = leaves[position];\n    if (oldLeaf.weight() != weight) {\n      uint256 newLeaf = oldLeaf.setWeight(weight);\n      root = setLeaf(position, newLeaf, root);\n    }\n  }\n\n  function setLeaf(\n    uint256 position,\n    uint256 theLeaf,\n    uint256 _root\n  ) internal returns (uint256) {\n    uint256 childSlot;\n    uint256 treeNode;\n    uint256 newNode;\n    uint256 nodeWeight = theLeaf.weight();\n\n    // set leaf\n    leaves[position] = theLeaf;\n\n    uint256 parent = position;\n    // set levels 7 to 2\n    for (uint256 level = LEVELS; level >= 2; level--) {\n      childSlot = parent.slot();\n      parent = parent.parent();\n      treeNode = branches[level][parent];\n      newNode = treeNode.setSlot(childSlot, nodeWeight);\n      branches[level][parent] = newNode;\n      nodeWeight = newNode.sumWeight();\n    }\n\n    // set level Root\n    childSlot = parent.slot();\n    return _root.setSlot(childSlot, nodeWeight);\n  }\n\n  function pickWeightedLeaf(uint256 index, uint256 _root)\n    internal\n    view\n    returns (uint256 leafPosition, uint256 leafFirstIndex)\n  {\n    uint256 currentIndex = index;\n    uint256 currentNode = _root;\n    uint256 currentPosition = 0;\n    uint256 currentSlot;\n\n    require(index < currentNode.sumWeight(), \"Index exceeds weight\");\n\n    // get root slot\n    (currentSlot, currentIndex) = currentNode.pickWeightedSlot(currentIndex);\n\n    // get slots from levels 2 to 7\n    for (uint256 level = 2; level <= LEVELS; level++) {\n      currentPosition = currentPosition.child(currentSlot);\n      currentNode = branches[level][currentPosition];\n      (currentSlot, currentIndex) = currentNode.pickWeightedSlot(currentIndex);\n    }\n\n    // get leaf position\n    leafPosition = currentPosition.child(currentSlot);\n    // get the first index of the leaf\n    // This works because the last weight returned from `pickWeightedSlot()`\n    // equals the \"overflow\" from getting the current slot.\n    leafFirstIndex = index - currentIndex;\n  }\n\n  function getEmptyLeafPosition() internal returns (uint256) {\n    uint256 rLeaf = rightmostLeaf;\n    bool spaceOnRight = (rLeaf + 1) < POOL_CAPACITY;\n    if (spaceOnRight) {\n      rightmostLeaf = rLeaf + 1;\n      return rLeaf;\n    } else {\n      bool emptyLeavesInStack = leavesInStack();\n      require(emptyLeavesInStack, \"Pool is full\");\n      return emptyLeaves.stackPop();\n    }\n  }\n\n  function leavesInStack() internal view returns (bool) {\n    return emptyLeaves.getSize() > 0;\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/StackLib.sol": {
      "content": "pragma solidity 0.5.17;\n\nlibrary StackLib {\n  function stackPeek(uint256[] storage _array) internal view returns (uint256) {\n    require(_array.length > 0, \"No value to peek, array is empty\");\n    return (_array[_array.length - 1]);\n  }\n\n  function stackPush(uint256[] storage _array, uint256 _element) public {\n    _array.push(_element);\n  }\n\n  function stackPop(uint256[] storage _array) internal returns (uint256) {\n    require(_array.length > 0, \"No value to pop, array is empty\");\n    uint256 value = _array[_array.length - 1];\n    _array.length -= 1;\n    return value;\n  }\n\n  function getSize(uint256[] storage _array) internal view returns (uint256) {\n    return _array.length;\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Branch.sol": {
      "content": "pragma solidity 0.5.17;\n\n/// @notice The implicit 8-ary trees of the sortition pool\n/// rely on packing 8 \"slots\" of 32-bit values into each uint256.\n/// The Branch library permits efficient calculations on these slots.\nlibrary Branch {\n  ////////////////////////////////////////////////////////////////////////////\n  // Parameters for configuration\n\n  // How many bits a position uses per level of the tree;\n  // each branch of the tree contains 2**SLOT_BITS slots.\n  uint256 constant SLOT_BITS = 3;\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Derived constants, do not touch\n  uint256 constant SLOT_COUNT = 2**SLOT_BITS;\n  uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;\n  uint256 constant LAST_SLOT = SLOT_COUNT - 1;\n  uint256 constant SLOT_MAX = (2**SLOT_WIDTH) - 1;\n\n  ////////////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate the right shift required\n  /// to make the 32 least significant bits of an uint256\n  /// be the bits of the `position`th slot\n  /// when treating the uint256 as a uint32[8].\n  ///\n  /// @dev Not used for efficiency reasons,\n  /// but left to illustrate the meaning of a common pattern.\n  /// I wish solidity had macros, even C macros.\n  function slotShift(uint256 position) internal pure returns (uint256) {\n    return position * SLOT_WIDTH;\n  }\n\n  /// @notice Return the `position`th slot of the `node`,\n  /// treating `node` as a uint32[32].\n  function getSlot(uint256 node, uint256 position)\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 shiftBits = position * SLOT_WIDTH;\n    // Doing a bitwise AND with `SLOT_MAX`\n    // clears all but the 32 least significant bits.\n    // Because of the right shift by `slotShift(position)` bits,\n    // those 32 bits contain the 32 bits in the `position`th slot of `node`.\n    return (node >> shiftBits) & SLOT_MAX;\n  }\n\n  /// @notice Return `node` with the `position`th slot set to zero.\n  function clearSlot(uint256 node, uint256 position)\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 shiftBits = position * SLOT_WIDTH;\n    // Shifting `SLOT_MAX` left by `slotShift(position)` bits\n    // gives us a number where all bits of the `position`th slot are set,\n    // and all other bits are unset.\n    //\n    // Using a bitwise NOT on this number,\n    // we get a uint256 where all bits are set\n    // except for those of the `position`th slot.\n    //\n    // Bitwise ANDing the original `node` with this number\n    // sets the bits of `position`th slot to zero,\n    // leaving all other bits unchanged.\n    return node & ~(SLOT_MAX << shiftBits);\n  }\n\n  /// @notice Return `node` with the `position`th slot set to `weight`.\n  ///\n  /// @param weight The weight of of the node.\n  /// Safely truncated to a 32-bit number,\n  /// but this should never be called with an overflowing weight regardless.\n  function setSlot(\n    uint256 node,\n    uint256 position,\n    uint256 weight\n  ) internal pure returns (uint256) {\n    uint256 shiftBits = position * SLOT_WIDTH;\n    // Clear the `position`th slot like in `clearSlot()`.\n    uint256 clearedNode = node & ~(SLOT_MAX << shiftBits);\n    // Bitwise AND `weight` with `SLOT_MAX`\n    // to clear all but the 32 least significant bits.\n    //\n    // Shift this left by `slotShift(position)` bits\n    // to obtain a uint256 with all bits unset\n    // except in the `position`th slot\n    // which contains the 32-bit value of `weight`.\n    uint256 shiftedWeight = (weight & SLOT_MAX) << shiftBits;\n    // When we bitwise OR these together,\n    // all other slots except the `position`th one come from the left argument,\n    // and the `position`th gets filled with `weight` from the right argument.\n    return clearedNode | shiftedWeight;\n  }\n\n  /// @notice Calculate the summed weight of all slots in the `node`.\n  function sumWeight(uint256 node) internal pure returns (uint256 sum) {\n    sum = node & SLOT_MAX;\n    // Iterate through each slot\n    // by shifting `node` right in increments of 32 bits,\n    // and adding the 32 least significant bits to the `sum`.\n    uint256 newNode = node >> SLOT_WIDTH;\n    while (newNode > 0) {\n      sum += (newNode & SLOT_MAX);\n      newNode = newNode >> SLOT_WIDTH;\n    }\n    return sum;\n  }\n\n  /// @notice Pick a slot in `node` that corresponds to `index`.\n  /// Treats the node like an array of virtual stakers,\n  /// the number of virtual stakers in each slot corresponding to its weight,\n  /// and picks which slot contains the `index`th virtual staker.\n  ///\n  /// @dev Requires that `index` be lower than `sumWeight(node)`.\n  /// However, this is not enforced for performance reasons.\n  /// If `index` exceeds the permitted range,\n  /// `pickWeightedSlot()` returns the rightmost slot\n  /// and an excessively high `newIndex`.\n  ///\n  /// @return slot The slot of `node` containing the `index`th virtual staker.\n  ///\n  /// @return newIndex The index of the `index`th virtual staker of `node`\n  /// within the returned slot.\n  function pickWeightedSlot(uint256 node, uint256 index)\n    internal\n    pure\n    returns (uint256 slot, uint256 newIndex)\n  {\n    newIndex = index;\n    uint256 newNode = node;\n    uint256 currentSlotWeight = newNode & SLOT_MAX;\n    while (newIndex >= currentSlotWeight) {\n      newIndex -= currentSlotWeight;\n      slot++;\n      newNode = newNode >> SLOT_WIDTH;\n      currentSlotWeight = newNode & SLOT_MAX;\n    }\n    return (slot, newIndex);\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Position.sol": {
      "content": "pragma solidity 0.5.17;\n\nlibrary Position {\n  ////////////////////////////////////////////////////////////////////////////\n  // Parameters for configuration\n\n  // How many bits a position uses per level of the tree;\n  // each branch of the tree contains 2**SLOT_BITS slots.\n  uint256 constant SLOT_BITS = 3;\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Derived constants, do not touch\n  uint256 constant SLOT_POINTER_MAX = (2**SLOT_BITS) - 1;\n  uint256 constant LEAF_FLAG = 1 << 255;\n\n  ////////////////////////////////////////////////////////////////////////////\n\n  // Return the last 3 bits of a position number,\n  // corresponding to its slot in its parent\n  function slot(uint256 a) internal pure returns (uint256) {\n    return a & SLOT_POINTER_MAX;\n  }\n\n  // Return the parent of a position number\n  function parent(uint256 a) internal pure returns (uint256) {\n    return a >> SLOT_BITS;\n  }\n\n  // Return the location of the child of a at the given slot\n  function child(uint256 a, uint256 s) internal pure returns (uint256) {\n    return (a << SLOT_BITS) | (s & SLOT_POINTER_MAX); // slot(s)\n  }\n\n  // Return the uint p as a flagged position uint:\n  // the least significant 21 bits contain the position\n  // and the 22nd bit is set as a flag\n  // to distinguish the position 0x000000 from an empty field.\n  function setFlag(uint256 p) internal pure returns (uint256) {\n    return p | LEAF_FLAG;\n  }\n\n  // Turn a flagged position into an unflagged position\n  // by removing the flag at the 22nd least significant bit.\n  //\n  // We shouldn't _actually_ need this\n  // as all position-manipulating code should ignore non-position bits anyway\n  // but it's cheap to call so might as well do it.\n  function unsetFlag(uint256 p) internal pure returns (uint256) {\n    return p & (~LEAF_FLAG);\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/api/IStaking.sol": {
      "content": "pragma solidity 0.5.17;\n\ninterface IStaking {\n    // Gives the amount of KEEP tokens staked by the `operator`\n    // eligible for work selection in the specified `operatorContract`.\n    //\n    // If the operator doesn't exist or hasn't finished initializing,\n    // or the operator contract hasn't been authorized for the operator,\n    // returns 0.\n    function eligibleStake(\n        address operator,\n        address operatorContract\n    ) external view returns (uint256);\n}\n"
    },
    "@keep-network/sortition-pools/contracts/BondedSortitionPool.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./AbstractSortitionPool.sol\";\nimport \"./RNG.sol\";\nimport \"./api/IStaking.sol\";\nimport \"./api/IBonding.sol\";\nimport \"./DynamicArray.sol\";\n\n/// @title Bonded Sortition Pool\n/// @notice A logarithmic data structure used to store the pool of eligible\n/// operators weighted by their stakes. It allows to select a group of operators\n/// based on the provided pseudo-random seed and bonding requirements.\n/// @dev Keeping pool up to date cannot be done eagerly as proliferation of\n/// privileged customers could be used to perform DOS attacks by increasing the\n/// cost of such updates. When a sortition pool prospectively selects an\n/// operator, the selected operator’s eligibility status and weight needs to be\n/// checked and, if necessary, updated in the sortition pool. If the changes\n/// would be detrimental to the operator, the operator selection is performed\n/// again with the updated input to ensure correctness.\n/// The pool should specify a reasonable minimum bondable value for operators\n/// trying to join the pool, to prevent griefing the selection.\ncontract BondedSortitionPool is AbstractSortitionPool {\n  using DynamicArray for DynamicArray.UintArray;\n  using DynamicArray for DynamicArray.AddressArray;\n  using RNG for RNG.State;\n\n  struct PoolParams {\n    IStaking stakingContract;\n    uint256 minimumStake;\n    IBonding bondingContract;\n    // Defines the minimum unbounded value the operator needs to have to be\n    // eligible to join and stay in the sortition pool. Operators not\n    // satisfying minimum bondable value are removed from the pool.\n    uint256 minimumBondableValue;\n    // Bond required from each operator for the currently pending group\n    // selection. If operator does not have at least this unbounded value,\n    // it is skipped during the selection.\n    uint256 requestedBond;\n    // The weight divisor in the pool can differ from the minimum stake\n    uint256 poolWeightDivisor;\n    address owner;\n  }\n\n  PoolParams poolParams;\n\n  constructor(\n    IStaking _stakingContract,\n    IBonding _bondingContract,\n    uint256 _minimumStake,\n    uint256 _minimumBondableValue,\n    uint256 _poolWeightDivisor,\n    address _poolOwner\n  ) public {\n    require(_minimumStake > 0, \"Minimum stake cannot be zero\");\n\n    poolParams = PoolParams(\n      _stakingContract,\n      _minimumStake,\n      _bondingContract,\n      _minimumBondableValue,\n      0,\n      _poolWeightDivisor,\n      _poolOwner\n    );\n  }\n\n  /// @notice Selects a new group of operators of the provided size based on\n  /// the provided pseudo-random seed and bonding requirements. All operators\n  /// in the group are unique.\n  ///\n  /// If there are not enough operators in a pool to form a group or not\n  /// enough operators are eligible for work selection given the bonding\n  /// requirements, the function fails.\n  /// @param groupSize Size of the requested group\n  /// @param seed Pseudo-random number used to select operators to group\n  /// @param minimumStake The current minimum stake value\n  /// @param bondValue Size of the requested bond per operator\n  function selectSetGroup(\n    uint256 groupSize,\n    bytes32 seed,\n    uint256 minimumStake,\n    uint256 bondValue\n  ) public returns (address[] memory) {\n    PoolParams memory params = initializeSelectionParams(\n      minimumStake,\n      bondValue\n    );\n    require(msg.sender == params.owner, \"Only owner may select groups\");\n    uint256 paramsPtr;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      paramsPtr := params\n    }\n    return generalizedSelectGroup(groupSize, seed, paramsPtr, true);\n  }\n\n  /// @notice Sets the minimum bondable value required from the operator\n  /// so that it is eligible to be in the pool. The pool should specify\n  /// a reasonable minimum requirement for operators trying to join the pool\n  /// to prevent griefing group selection.\n  /// @param minimumBondableValue The minimum bondable value required from the\n  /// operator.\n  function setMinimumBondableValue(uint256 minimumBondableValue) public {\n    require(\n      msg.sender == poolParams.owner,\n      \"Only owner may update minimum bond value\"\n    );\n\n    poolParams.minimumBondableValue = minimumBondableValue;\n  }\n\n  /// @notice Returns the minimum bondable value required from the operator\n  /// so that it is eligible to be in the pool.\n  function getMinimumBondableValue() public view returns (uint256) {\n    return poolParams.minimumBondableValue;\n  }\n\n  function initializeSelectionParams(uint256 minimumStake, uint256 bondValue)\n    internal\n    returns (PoolParams memory params)\n  {\n    params = poolParams;\n\n    if (params.requestedBond != bondValue) {\n      params.requestedBond = bondValue;\n    }\n\n    if (params.minimumStake != minimumStake) {\n      params.minimumStake = minimumStake;\n      poolParams.minimumStake = minimumStake;\n    }\n\n    return params;\n  }\n\n  // Return the eligible weight of the operator,\n  // which may differ from the weight in the pool.\n  // Return 0 if ineligible.\n  function getEligibleWeight(address operator) internal view returns (uint256) {\n    address ownerAddress = poolParams.owner;\n    // Get the amount of bondable value available for this pool.\n    // We only care that this covers one single bond\n    // regardless of the weight of the operator in the pool.\n    uint256 bondableValue = poolParams.bondingContract.availableUnbondedValue(\n      operator,\n      ownerAddress,\n      address(this)\n    );\n\n    // Don't query stake if bond is insufficient.\n    if (bondableValue < poolParams.minimumBondableValue) {\n      return 0;\n    }\n\n    uint256 eligibleStake = poolParams.stakingContract.eligibleStake(\n      operator,\n      ownerAddress\n    );\n\n    // Weight = floor(eligibleStake / poolWeightDivisor)\n    // but only if eligibleStake >= minimumStake.\n    // Ethereum uint256 division performs implicit floor\n    // If eligibleStake < poolWeightDivisor, return 0 = ineligible.\n    if (eligibleStake < poolParams.minimumStake) {\n      return 0;\n    }\n    return (eligibleStake / poolParams.poolWeightDivisor);\n  }\n\n  function decideFate(\n    uint256 leaf,\n    DynamicArray.AddressArray memory, // `selected`, for future use\n    uint256 paramsPtr\n  ) internal view returns (Fate memory) {\n    PoolParams memory params;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      params := paramsPtr\n    }\n    address operator = leaf.operator();\n    uint256 leafWeight = leaf.weight();\n\n    if (!isLeafInitialized(leaf)) {\n      return Fate(Decision.Skip, 0);\n    }\n\n    address ownerAddress = params.owner;\n\n    // Get the amount of bondable value available for this pool.\n    // We only care that this covers one single bond\n    // regardless of the weight of the operator in the pool.\n    uint256 bondableValue = params.bondingContract.availableUnbondedValue(\n      operator,\n      ownerAddress,\n      address(this)\n    );\n\n    // If unbonded value is insufficient for the operator to be in the pool,\n    // delete the operator.\n    if (bondableValue < params.minimumBondableValue) {\n      return Fate(Decision.Delete, 0);\n    }\n    // If unbonded value is sufficient for the operator to be in the pool\n    // but it is not sufficient for the current selection, skip the operator.\n    if (bondableValue < params.requestedBond) {\n      return Fate(Decision.Skip, 0);\n    }\n\n    uint256 eligibleStake = params.stakingContract.eligibleStake(\n      operator,\n      ownerAddress\n    );\n\n    // Weight = floor(eligibleStake / poolWeightDivisor)\n    // Ethereum uint256 division performs implicit floor\n    uint256 eligibleWeight = eligibleStake / params.poolWeightDivisor;\n\n    if (eligibleWeight < leafWeight || eligibleStake < params.minimumStake) {\n      return Fate(Decision.Delete, 0);\n    }\n    return Fate(Decision.Select, 0);\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/BondedSortitionPoolFactory.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./BondedSortitionPool.sol\";\nimport \"./api/IBonding.sol\";\nimport \"./api/IStaking.sol\";\n\n/// @title Bonded Sortition Pool Factory\n/// @notice Factory for the creation of new bonded sortition pools.\ncontract BondedSortitionPoolFactory {\n  /// @notice Creates a new bonded sortition pool instance.\n  /// @return Address of the new bonded sortition pool contract instance.\n  function createSortitionPool(\n    IStaking stakingContract,\n    IBonding bondingContract,\n    uint256 minimumStake,\n    uint256 initialMinimumBond,\n    uint256 poolWeightDivisor\n  ) public returns (address) {\n    return\n      address(\n        new BondedSortitionPool(\n          stakingContract,\n          bondingContract,\n          minimumStake,\n          initialMinimumBond,\n          poolWeightDivisor,\n          msg.sender\n        )\n      );\n  }\n}\n"
    },
    "openzeppelin-solidity/contracts/math/Math.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}