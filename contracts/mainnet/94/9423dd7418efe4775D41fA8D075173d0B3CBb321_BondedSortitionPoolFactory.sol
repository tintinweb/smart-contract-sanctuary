{{
  "language": "Solidity",
  "sources": {
    "@keep-network/sortition-pools/contracts/BondedSortitionPoolFactory.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./BondedSortitionPool.sol\";\nimport \"./api/IBonding.sol\";\nimport \"./api/IStaking.sol\";\n\n/// @title Bonded Sortition Pool Factory\n/// @notice Factory for the creation of new bonded sortition pools.\ncontract BondedSortitionPoolFactory {\n  /// @notice Creates a new bonded sortition pool instance.\n  /// @return Address of the new bonded sortition pool contract instance.\n  function createSortitionPool(\n    IStaking stakingContract,\n    IBonding bondingContract,\n    uint256 minimumStake,\n    uint256 initialMinimumBond,\n    uint256 poolWeightDivisor\n  ) public returns (address) {\n    return\n      address(\n        new BondedSortitionPool(\n          stakingContract,\n          bondingContract,\n          minimumStake,\n          initialMinimumBond,\n          poolWeightDivisor,\n          msg.sender\n        )\n      );\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/BondedSortitionPool.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./AbstractSortitionPool.sol\";\nimport \"./RNG.sol\";\nimport \"./api/IStaking.sol\";\nimport \"./api/IBonding.sol\";\nimport \"./DynamicArray.sol\";\n\n/// @title Bonded Sortition Pool\n/// @notice A logarithmic data structure used to store the pool of eligible\n/// operators weighted by their stakes. It allows to select a group of operators\n/// based on the provided pseudo-random seed and bonding requirements.\n/// @dev Keeping pool up to date cannot be done eagerly as proliferation of\n/// privileged customers could be used to perform DOS attacks by increasing the\n/// cost of such updates. When a sortition pool prospectively selects an\n/// operator, the selected operatorâ€™s eligibility status and weight needs to be\n/// checked and, if necessary, updated in the sortition pool. If the changes\n/// would be detrimental to the operator, the operator selection is performed\n/// again with the updated input to ensure correctness.\n/// The pool should specify a reasonable minimum bondable value for operators\n/// trying to join the pool, to prevent griefing the selection.\ncontract BondedSortitionPool is AbstractSortitionPool {\n  using DynamicArray for DynamicArray.UintArray;\n  using DynamicArray for DynamicArray.AddressArray;\n  using RNG for RNG.State;\n\n  struct PoolParams {\n    IStaking stakingContract;\n    uint256 minimumStake;\n    IBonding bondingContract;\n    // Defines the minimum unbounded value the operator needs to have to be\n    // eligible to join and stay in the sortition pool. Operators not\n    // satisfying minimum bondable value are removed from the pool.\n    uint256 minimumBondableValue;\n    // Bond required from each operator for the currently pending group\n    // selection. If operator does not have at least this unbounded value,\n    // it is skipped during the selection.\n    uint256 requestedBond;\n    // The weight divisor in the pool can differ from the minimum stake\n    uint256 poolWeightDivisor;\n    address owner;\n  }\n\n  PoolParams poolParams;\n\n  constructor(\n    IStaking _stakingContract,\n    IBonding _bondingContract,\n    uint256 _minimumStake,\n    uint256 _minimumBondableValue,\n    uint256 _poolWeightDivisor,\n    address _poolOwner\n  ) public {\n    require(_minimumStake > 0, \"Minimum stake cannot be zero\");\n\n    poolParams = PoolParams(\n      _stakingContract,\n      _minimumStake,\n      _bondingContract,\n      _minimumBondableValue,\n      0,\n      _poolWeightDivisor,\n      _poolOwner\n    );\n  }\n\n  /// @notice Selects a new group of operators of the provided size based on\n  /// the provided pseudo-random seed and bonding requirements. All operators\n  /// in the group are unique.\n  ///\n  /// If there are not enough operators in a pool to form a group or not\n  /// enough operators are eligible for work selection given the bonding\n  /// requirements, the function fails.\n  /// @param groupSize Size of the requested group\n  /// @param seed Pseudo-random number used to select operators to group\n  /// @param minimumStake The current minimum stake value\n  /// @param bondValue Size of the requested bond per operator\n  function selectSetGroup(\n    uint256 groupSize,\n    bytes32 seed,\n    uint256 minimumStake,\n    uint256 bondValue\n  ) public returns (address[] memory) {\n    PoolParams memory params = initializeSelectionParams(\n      minimumStake,\n      bondValue\n    );\n    require(msg.sender == params.owner, \"Only owner may select groups\");\n    uint256 paramsPtr;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      paramsPtr := params\n    }\n    return generalizedSelectGroup(groupSize, seed, paramsPtr, true);\n  }\n\n  /// @notice Sets the minimum bondable value required from the operator\n  /// so that it is eligible to be in the pool. The pool should specify\n  /// a reasonable minimum requirement for operators trying to join the pool\n  /// to prevent griefing group selection.\n  /// @param minimumBondableValue The minimum bondable value required from the\n  /// operator.\n  function setMinimumBondableValue(uint256 minimumBondableValue) public {\n    require(\n      msg.sender == poolParams.owner,\n      \"Only owner may update minimum bond value\"\n    );\n\n    poolParams.minimumBondableValue = minimumBondableValue;\n  }\n\n  /// @notice Returns the minimum bondable value required from the operator\n  /// so that it is eligible to be in the pool.\n  function getMinimumBondableValue() public view returns (uint256) {\n    return poolParams.minimumBondableValue;\n  }\n\n  function initializeSelectionParams(uint256 minimumStake, uint256 bondValue)\n    internal\n    returns (PoolParams memory params)\n  {\n    params = poolParams;\n\n    if (params.requestedBond != bondValue) {\n      params.requestedBond = bondValue;\n    }\n\n    if (params.minimumStake != minimumStake) {\n      params.minimumStake = minimumStake;\n      poolParams.minimumStake = minimumStake;\n    }\n\n    return params;\n  }\n\n  // Return the eligible weight of the operator,\n  // which may differ from the weight in the pool.\n  // Return 0 if ineligible.\n  function getEligibleWeight(address operator) internal view returns (uint256) {\n    address ownerAddress = poolParams.owner;\n    // Get the amount of bondable value available for this pool.\n    // We only care that this covers one single bond\n    // regardless of the weight of the operator in the pool.\n    uint256 bondableValue = poolParams.bondingContract.availableUnbondedValue(\n      operator,\n      ownerAddress,\n      address(this)\n    );\n\n    // Don't query stake if bond is insufficient.\n    if (bondableValue < poolParams.minimumBondableValue) {\n      return 0;\n    }\n\n    uint256 eligibleStake = poolParams.stakingContract.eligibleStake(\n      operator,\n      ownerAddress\n    );\n\n    // Weight = floor(eligibleStake / poolWeightDivisor)\n    // but only if eligibleStake >= minimumStake.\n    // Ethereum uint256 division performs implicit floor\n    // If eligibleStake < poolWeightDivisor, return 0 = ineligible.\n    if (eligibleStake < poolParams.minimumStake) {\n      return 0;\n    }\n    return (eligibleStake / poolParams.poolWeightDivisor);\n  }\n\n  function decideFate(\n    uint256 leaf,\n    DynamicArray.AddressArray memory, // `selected`, for future use\n    uint256 paramsPtr\n  ) internal view returns (Fate memory) {\n    PoolParams memory params;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      params := paramsPtr\n    }\n    address operator = leaf.operator();\n    uint256 leafWeight = leaf.weight();\n\n    if (!isLeafInitialized(leaf)) {\n      return Fate(Decision.Skip, 0);\n    }\n\n    address ownerAddress = params.owner;\n\n    // Get the amount of bondable value available for this pool.\n    // We only care that this covers one single bond\n    // regardless of the weight of the operator in the pool.\n    uint256 bondableValue = params.bondingContract.availableUnbondedValue(\n      operator,\n      ownerAddress,\n      address(this)\n    );\n\n    // If unbonded value is insufficient for the operator to be in the pool,\n    // delete the operator.\n    if (bondableValue < params.minimumBondableValue) {\n      return Fate(Decision.Delete, 0);\n    }\n    // If unbonded value is sufficient for the operator to be in the pool\n    // but it is not sufficient for the current selection, skip the operator.\n    if (bondableValue < params.requestedBond) {\n      return Fate(Decision.Skip, 0);\n    }\n\n    uint256 eligibleStake = params.stakingContract.eligibleStake(\n      operator,\n      ownerAddress\n    );\n\n    // Weight = floor(eligibleStake / poolWeightDivisor)\n    // Ethereum uint256 division performs implicit floor\n    uint256 eligibleWeight = eligibleStake / params.poolWeightDivisor;\n\n    if (eligibleWeight < leafWeight || eligibleStake < params.minimumStake) {\n      return Fate(Decision.Delete, 0);\n    }\n    return Fate(Decision.Select, 0);\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/api/IBonding.sol": {
      "content": "pragma solidity 0.5.17;\n\ninterface IBonding {\n    // Gives the amount of ETH\n    // the `operator` has made available for bonding by the `bondCreator`.\n    // If the operator doesn't exist,\n    // or the bond creator isn't authorized,\n    // returns 0.\n    function availableUnbondedValue(\n        address operator,\n        address bondCreator,\n        address authorizedSortitionPool\n    ) external view returns (uint256);\n}\n"
    },
    "@keep-network/sortition-pools/contracts/api/IStaking.sol": {
      "content": "pragma solidity 0.5.17;\n\ninterface IStaking {\n    // Gives the amount of KEEP tokens staked by the `operator`\n    // eligible for work selection in the specified `operatorContract`.\n    //\n    // If the operator doesn't exist or hasn't finished initializing,\n    // or the operator contract hasn't been authorized for the operator,\n    // returns 0.\n    function eligibleStake(\n        address operator,\n        address operatorContract\n    ) external view returns (uint256);\n}\n"
    },
    "@keep-network/sortition-pools/contracts/AbstractSortitionPool.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./GasStation.sol\";\nimport \"./RNG.sol\";\nimport \"./SortitionTree.sol\";\nimport \"./DynamicArray.sol\";\nimport \"./api/IStaking.sol\";\n\n/// @title Abstract Sortition Pool\n/// @notice Abstract contract encapsulating common logic of all sortition pools.\n/// @dev Inheriting implementations are expected to implement getEligibleWeight\n/// function.\ncontract AbstractSortitionPool is SortitionTree, GasStation {\n  using Leaf for uint256;\n  using Position for uint256;\n  using DynamicArray for DynamicArray.UintArray;\n  using DynamicArray for DynamicArray.AddressArray;\n  using RNG for RNG.State;\n\n  enum Decision {\n    Select, // Add to the group, and use new seed\n    Skip, // Retry with same seed, skip this leaf\n    Delete, // Retry with same seed, delete this leaf\n    UpdateRetry, // Retry with same seed, update this leaf\n    UpdateSelect // Select and reseed, but also update this leaf\n  }\n\n  struct Fate {\n    Decision decision;\n    // The new weight of the leaf if Decision is Update*, otherwise 0\n    uint256 maybeWeight;\n  }\n\n  // Require 10 blocks after joining before the operator can be selected for\n  // a group. This reduces the degrees of freedom miners and other\n  // front-runners have in conducting pool-bumping attacks.\n  //\n  // We don't use the stack of empty leaves until we run out of space on the\n  // rightmost leaf (i.e. after 2 million operators have joined the pool).\n  // It means all insertions are at the right end, so one can't reorder\n  // operators already in the pool until the pool has been filled once.\n  // Because the index is calculated by taking the minimum number of required\n  // random bits, and seeing if it falls in the range of the total pool weight,\n  // the only scenarios where insertions on the right matter are if it crosses\n  // a power of two threshold for the total weight and unlocks another random\n  // bit, or if a random number that would otherwise be discarded happens to\n  // fall within that space.\n  uint256 constant INIT_BLOCKS = 10;\n\n  uint256 constant GAS_DEPOSIT_SIZE = 1;\n\n  /// @notice The number of blocks that must be mined before the operator who\n  // joined the pool is eligible for work selection.\n  function operatorInitBlocks() public pure returns (uint256) {\n    return INIT_BLOCKS;\n  }\n\n  // Return whether the operator is eligible for the pool.\n  function isOperatorEligible(address operator) public view returns (bool) {\n    return getEligibleWeight(operator) > 0;\n  }\n\n  // Return whether the operator is present in the pool.\n  function isOperatorInPool(address operator) public view returns (bool) {\n    return getFlaggedLeafPosition(operator) != 0;\n  }\n\n  // Return whether the operator's weight in the pool\n  // matches their eligible weight.\n  function isOperatorUpToDate(address operator) public view returns (bool) {\n    return getEligibleWeight(operator) == getPoolWeight(operator);\n  }\n\n  // Returns whether the operator has passed the initialization blocks period\n  // to be eligible for the work selection. Reverts if the operator is not in\n  // the pool.\n  function isOperatorInitialized(address operator) public view returns (bool) {\n    require(isOperatorInPool(operator), \"Operator is not in the pool\");\n\n    uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n    uint256 leafPosition = flaggedPosition.unsetFlag();\n    uint256 leaf = leaves[leafPosition];\n\n    return isLeafInitialized(leaf);\n  }\n\n  // Return the weight of the operator in the pool,\n  // which may or may not be out of date.\n  function getPoolWeight(address operator) public view returns (uint256) {\n    uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n    if (flaggedPosition == 0) {\n      return 0;\n    } else {\n      uint256 leafPosition = flaggedPosition.unsetFlag();\n      uint256 leafWeight = leaves[leafPosition].weight();\n      return leafWeight;\n    }\n  }\n\n  // Add an operator to the pool,\n  // reverting if the operator is already present.\n  function joinPool(address operator) public {\n    uint256 eligibleWeight = getEligibleWeight(operator);\n    require(eligibleWeight > 0, \"Operator not eligible\");\n\n    depositGas(operator);\n    insertOperator(operator, eligibleWeight);\n  }\n\n  // Update the operator's weight if present and eligible,\n  // or remove from the pool if present and ineligible.\n  function updateOperatorStatus(address operator) public {\n    uint256 eligibleWeight = getEligibleWeight(operator);\n    uint256 inPoolWeight = getPoolWeight(operator);\n\n    require(eligibleWeight != inPoolWeight, \"Operator already up to date\");\n\n    if (eligibleWeight == 0) {\n      removeOperator(operator);\n      releaseGas(operator);\n    } else {\n      updateOperator(operator, eligibleWeight);\n    }\n  }\n\n  function generalizedSelectGroup(\n    uint256 groupSize,\n    bytes32 seed,\n    // This uint256 is actually a void pointer.\n    // We can't pass a SelectionParams,\n    // because the implementation of the SelectionParams struct\n    // can vary between different concrete sortition pool implementations.\n    //\n    // Whatever SelectionParams struct is used by the concrete contract\n    // should be created in the `selectGroup`/`selectSetGroup` function,\n    // then coerced into a uint256 to be passed into this function.\n    // The paramsPtr is then passed to the `decideFate` implementation\n    // which can coerce it back into the concrete SelectionParams.\n    // This allows `generalizedSelectGroup`\n    // to work with any desired eligibility logic.\n    uint256 paramsPtr,\n    bool noDuplicates\n  ) internal returns (address[] memory) {\n    uint256 _root = root;\n    bool rootChanged = false;\n\n    DynamicArray.AddressArray memory selected;\n    selected = DynamicArray.addressArray(groupSize);\n\n    RNG.State memory rng;\n    rng = RNG.initialize(seed, _root.sumWeight(), groupSize);\n\n    while (selected.array.length < groupSize) {\n      rng.generateNewIndex();\n\n      (uint256 leafPosition, uint256 startingIndex) = pickWeightedLeaf(\n        rng.currentMappedIndex,\n        _root\n      );\n\n      uint256 leaf = leaves[leafPosition];\n      address operator = leaf.operator();\n      uint256 leafWeight = leaf.weight();\n\n      Fate memory fate = decideFate(leaf, selected, paramsPtr);\n\n      if (fate.decision == Decision.Select) {\n        selected.arrayPush(operator);\n        if (noDuplicates) {\n          rng.addSkippedInterval(startingIndex, leafWeight);\n        }\n        rng.reseed(seed, selected.array.length);\n        continue;\n      }\n      if (fate.decision == Decision.Skip) {\n        rng.addSkippedInterval(startingIndex, leafWeight);\n        continue;\n      }\n      if (fate.decision == Decision.Delete) {\n        // Update the RNG\n        rng.updateInterval(startingIndex, leafWeight, 0);\n        // Remove the leaf and update root\n        _root = removeLeaf(leafPosition, _root);\n        rootChanged = true;\n        // Remove the record of the operator's leaf and release gas\n        removeLeafPositionRecord(operator);\n        releaseGas(operator);\n        continue;\n      }\n      if (fate.decision == Decision.UpdateRetry) {\n        _root = setLeaf(leafPosition, leaf.setWeight(fate.maybeWeight), _root);\n        rootChanged = true;\n        rng.updateInterval(startingIndex, leafWeight, fate.maybeWeight);\n        continue;\n      }\n      if (fate.decision == Decision.UpdateSelect) {\n        _root = setLeaf(leafPosition, leaf.setWeight(fate.maybeWeight), _root);\n        rootChanged = true;\n        selected.arrayPush(operator);\n        rng.updateInterval(startingIndex, leafWeight, fate.maybeWeight);\n        if (noDuplicates) {\n          rng.addSkippedInterval(startingIndex, fate.maybeWeight);\n        }\n        rng.reseed(seed, selected.array.length);\n        continue;\n      }\n    }\n    if (rootChanged) {\n      root = _root;\n    }\n    return selected.array;\n  }\n\n  function isLeafInitialized(uint256 leaf) internal view returns (bool) {\n    uint256 createdAt = leaf.creationBlock();\n\n    return block.number > (createdAt + operatorInitBlocks());\n  }\n\n  // Return the eligible weight of the operator,\n  // which may differ from the weight in the pool.\n  // Return 0 if ineligible.\n  function getEligibleWeight(address operator) internal view returns (uint256);\n\n  function decideFate(\n    uint256 leaf,\n    DynamicArray.AddressArray memory selected,\n    uint256 paramsPtr\n  ) internal view returns (Fate memory);\n\n  function gasDepositSize() internal pure returns (uint256) {\n    return GAS_DEPOSIT_SIZE;\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/RNG.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./Leaf.sol\";\nimport \"./Interval.sol\";\nimport \"./DynamicArray.sol\";\n\nlibrary RNG {\n  using DynamicArray for DynamicArray.UintArray;\n  ////////////////////////////////////////////////////////////////////////////\n  // Parameters for configuration\n\n  // How many bits a position uses per level of the tree;\n  // each branch of the tree contains 2**SLOT_BITS slots.\n  uint256 constant SLOT_BITS = 3;\n  uint256 constant LEVELS = 7;\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Derived constants, do not touch\n  uint256 constant POSITION_BITS = LEVELS * SLOT_BITS;\n  ////////////////////////////////////////////////////////////////////////////\n\n  struct State {\n    // RNG output\n    uint256 currentMappedIndex;\n    uint256 currentTruncatedIndex;\n    // The random bytes used to derive indices\n    bytes32 currentSeed;\n    // The full range of indices;\n    // generated random numbers are in [0, fullRange).\n    uint256 fullRange;\n    // The truncated range of indices;\n    // how many non-skipped indices are left to consider.\n    // Random indices are generated within this range,\n    // and mapped to the full range by skipping the specified intervals.\n    uint256 truncatedRange;\n    DynamicArray.UintArray skippedIntervals;\n  }\n\n  function initialize(\n    bytes32 seed,\n    uint256 range,\n    uint256 expectedSkippedCount\n  ) internal view returns (State memory self) {\n    self = State(\n      0,\n      0,\n      seed,\n      range,\n      range,\n      DynamicArray.uintArray(expectedSkippedCount)\n    );\n    reseed(self, seed, 0);\n    return self;\n  }\n\n  function reseed(\n    State memory self,\n    bytes32 seed,\n    uint256 nonce\n  ) internal view {\n    self.currentSeed = keccak256(\n      abi.encodePacked(seed, nonce, address(this), \"reseed\")\n    );\n  }\n\n  function retryIndex(State memory self) internal view {\n    uint256 truncatedIndex = self.currentTruncatedIndex;\n    if (self.currentTruncatedIndex < self.truncatedRange) {\n      self.currentMappedIndex = Interval.skip(\n        truncatedIndex,\n        self.skippedIntervals\n      );\n    } else {\n      generateNewIndex(self);\n    }\n  }\n\n  function updateInterval(\n    State memory self,\n    uint256 startIndex,\n    uint256 oldWeight,\n    uint256 newWeight\n  ) internal pure {\n    int256 weightDiff = int256(newWeight) - int256(oldWeight);\n    uint256 effectiveStartIndex = startIndex + newWeight;\n    self.truncatedRange = uint256(int256(self.truncatedRange) + weightDiff);\n    self.fullRange = uint256(int256(self.fullRange) + weightDiff);\n    Interval.remapIndices(\n      effectiveStartIndex,\n      weightDiff,\n      self.skippedIntervals\n    );\n  }\n\n  function addSkippedInterval(\n    State memory self,\n    uint256 startIndex,\n    uint256 weight\n  ) internal pure {\n    self.truncatedRange -= weight;\n    Interval.insert(self.skippedIntervals, Interval.make(startIndex, weight));\n  }\n\n  /// @notice Generate a new index based on the current seed,\n  /// without reseeding first.\n  /// This will result in the same truncated index as before\n  /// if it still fits in the current truncated range.\n  function generateNewIndex(State memory self) internal view {\n    uint256 _truncatedRange = self.truncatedRange;\n    require(_truncatedRange > 0, \"Not enough operators in pool\");\n    uint256 bits = bitsRequired(_truncatedRange);\n    uint256 truncatedIndex = truncate(bits, uint256(self.currentSeed));\n    while (truncatedIndex >= _truncatedRange) {\n      self.currentSeed = keccak256(\n        abi.encodePacked(self.currentSeed, address(this), \"generate\")\n      );\n      truncatedIndex = truncate(bits, uint256(self.currentSeed));\n    }\n    self.currentTruncatedIndex = truncatedIndex;\n    self.currentMappedIndex = Interval.skip(\n      truncatedIndex,\n      self.skippedIntervals\n    );\n  }\n\n  /// @notice Calculate how many bits are required\n  /// for an index in the range `[0 .. range-1]`.\n  ///\n  /// @dev Our sortition pool can support up to 2^21 virtual stakers,\n  /// therefore we calculate how many bits we need from 1 to 21.\n  ///\n  /// @param range The upper bound of the desired range, exclusive.\n  ///\n  /// @return uint The smallest number of bits\n  /// that can contain the number `range-1`.\n  function bitsRequired(uint256 range) internal pure returns (uint256) {\n    // Start at 19 to be faster for large ranges\n    uint256 bits = POSITION_BITS - 1;\n\n    // Left shift by `bits`,\n    // so we have a 1 in the (bits + 1)th least significant bit\n    // and 0 in other bits.\n    // If this number is equal or greater than `range`,\n    // the range [0, range-1] fits in `bits` bits.\n    //\n    // Because we loop from high bits to low bits,\n    // we find the highest number of bits that doesn't fit the range,\n    // and return that number + 1.\n    while (1 << bits >= range) {\n      bits--;\n    }\n\n    return bits + 1;\n  }\n\n  /// @notice Truncate `input` to the `bits` least significant bits.\n  function truncate(uint256 bits, uint256 input)\n    internal\n    pure\n    returns (uint256)\n  {\n    return input & ((1 << bits) - 1);\n  }\n\n  /// @notice Get an index in the range `[0 .. range-1]`\n  /// and the new state of the RNG,\n  /// using the provided `state` of the RNG.\n  ///\n  /// @param range The upper bound of the index, exclusive.\n  ///\n  /// @param state The previous state of the RNG.\n  /// The initial state needs to be obtained\n  /// from a trusted randomness oracle (the random beacon),\n  /// or from a chain of earlier calls to `RNG.getIndex()`\n  /// on an originally trusted seed.\n  ///\n  /// @dev Calculates the number of bits required for the desired range,\n  /// takes the least significant bits of `state`\n  /// and checks if the obtained index is within the desired range.\n  /// The original state is hashed with `keccak256` to get a new state.\n  /// If the index is outside the range,\n  /// the function retries until it gets a suitable index.\n  ///\n  /// @return index A random integer between `0` and `range - 1`, inclusive.\n  ///\n  /// @return newState The new state of the RNG.\n  /// When `getIndex()` is called one or more times,\n  /// care must be taken to always use the output `state`\n  /// of the most recent call as the input `state` of a subsequent call.\n  /// At the end of a transaction calling `RNG.getIndex()`,\n  /// the previous stored state must be overwritten with the latest output.\n  function getIndex(uint256 range, bytes32 state)\n    internal\n    view\n    returns (uint256, bytes32)\n  {\n    uint256 bits = bitsRequired(range);\n    bool found = false;\n    uint256 index = 0;\n    bytes32 newState = state;\n    while (!found) {\n      index = truncate(bits, uint256(newState));\n      newState = keccak256(abi.encodePacked(newState, address(this)));\n      if (index < range) {\n        found = true;\n      }\n    }\n    return (index, newState);\n  }\n\n  /// @notice Return an index corresponding to a new, unique leaf.\n  ///\n  /// @dev Gets a new index in a truncated range\n  /// with the weights of all previously selected leaves subtracted.\n  /// This index is then mapped to the full range of possible indices,\n  /// skipping the ranges covered by previous leaves.\n  ///\n  /// @param range The full range in which the unique index should be.\n  ///\n  /// @param state The RNG state.\n  ///\n  /// @param previousLeaves List of indices and weights\n  /// corresponding to the _first_ index of each previously selected leaf,\n  /// and the weight of the same leaf.\n  /// An index number `i` is a starting index of leaf `o`\n  /// if querying for index `i` in the sortition pool returns `o`,\n  /// but querying for `i-1` returns a different leaf.\n  /// This list REALLY needs to be sorted from smallest to largest.\n  ///\n  /// @param sumPreviousWeights The sum of the weights of previous leaves.\n  /// Could be calculated from `previousLeafWeights`\n  /// but providing it explicitly makes the function a bit simpler.\n  ///\n  /// @return uniqueIndex An index in [0, range) that does not overlap\n  /// any of the previousLeaves,\n  /// as determined by the range [index, index + weight).\n  function getUniqueIndex(\n    uint256 range,\n    bytes32 state,\n    uint256[] memory previousLeaves,\n    uint256 sumPreviousWeights\n  ) internal view returns (uint256 uniqueIndex, bytes32 newState) {\n    // Get an index in the truncated range.\n    // The truncated range covers only new leaves,\n    // but has to be mapped to the actual range of indices.\n    uint256 truncatedRange = range - sumPreviousWeights;\n    uint256 truncatedIndex;\n    (truncatedIndex, newState) = getIndex(truncatedRange, state);\n\n    // Map the truncated index to the available unique indices.\n    uniqueIndex = Interval.skip(\n      truncatedIndex,\n      DynamicArray.convert(previousLeaves)\n    );\n\n    return (uniqueIndex, newState);\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/DynamicArray.sol": {
      "content": "pragma solidity 0.5.17;\n\nlibrary DynamicArray {\n  // The in-memory dynamic Array is implemented\n  // by recording the amount of allocated memory\n  // separately from the length of the array.\n  // This gives us a perfectly normal in-memory array\n  // with all the behavior we're used to,\n  // but also makes O(1) `push` operations possible\n  // by expanding into the preallocated memory.\n  //\n  // When we run out of preallocated memory when trying to `push`,\n  // we allocate twice as much and copy the array over.\n  // With linear allocation costs this would amortize to O(1)\n  // but with EVM allocations being actually quadratic\n  // the real performance is a very technical O(N).\n  // Nonetheless, this is reasonably performant in practice.\n  //\n  // A dynamic array can be useful\n  // even when you aren't dealing with an unknown number of items.\n  // Because the array tracks the allocated space\n  // separately from the number of stored items,\n  // you can push items into the dynamic array\n  // and iterate over the currently present items\n  // without tracking their number yourself,\n  // or using a special null value for empty elements.\n  //\n  // Because Solidity doesn't really have useful safety features,\n  // only enough superficial inconveniences\n  // to lull yourself into a false sense of security,\n  // dynamic arrays require a bit of care to handle appropriately.\n  //\n  // First of all,\n  // dynamic arrays must not be created or modified manually.\n  // Use `uintArray(length)`, or `convert(existingArray)`\n  // which will perform a safe and efficient conversion for you.\n  // This also applies to storage;\n  // in-memory dynamic arrays are for efficient in-memory operations only,\n  // and it is unnecessary to store dynamic arrays.\n  // Use a regular `uint256[]` instead.\n  // The contents of `array` may be written like `dynamicArray.array[i] = x`\n  // but never reassign the `array` pointer itself\n  // nor mess with `allocatedMemory` in any way whatsoever.\n  // If you fail to follow these precautions,\n  // dragons inhabiting the no-man's-land\n  // between the array as it's seen by Solidity\n  // and the next thing allocated after it\n  // will be unleashed to wreak havoc upon your memory buffers.\n  //\n  // Second,\n  // because the `array` may be reassigned when pushing,\n  // the following pattern is unsafe:\n  // ```\n  // UintArray dynamicArray;\n  // uint256 len = dynamicArray.array.length;\n  // uint256[] danglingPointer = dynamicArray.array;\n  // danglingPointer[0] = x;\n  // dynamicArray.push(y);\n  // danglingPointer[0] = z;\n  // uint256 surprise = danglingPointer[len];\n  // ```\n  // After the above code block,\n  // `dynamicArray.array[0]` may be either `x` or `z`,\n  // and `surprise` may be `y` or out of bounds.\n  // This will not share your address space with a malevolent agent of chaos,\n  // but it will cause entirely avoidable scratchings of the head.\n  //\n  // Dynamic arrays should be safe to use like ordinary arrays\n  // if you always refer to the array field of the dynamic array\n  // when reading or writing values:\n  // ```\n  // UintArray dynamicArray;\n  // uint256 len = dynamicArray.array.length;\n  // dynamicArray.array[0] = x;\n  // dynamicArray.push(y);\n  // dynamicArray.array[0] = z;\n  // uint256 notSurprise = dynamicArray.array[len];\n  // ```\n  // After this code `notSurprise` is reliably `y`,\n  // and `dynamicArray.array[0]` is `z`.\n  struct UintArray {\n    // XXX: Do not modify this value.\n    // In fact, do not even read it.\n    // There is never a legitimate reason to do anything with this value.\n    // She is quiet and wishes to be left alone.\n    // The silent vigil of `allocatedMemory`\n    // is the only thing standing between your contract\n    // and complete chaos in its memory.\n    // Respect her wish or face the monstrosities she is keeping at bay.\n    uint256 allocatedMemory;\n    // Unlike her sharp and vengeful sister,\n    // `array` is safe to use normally\n    // for anything you might do with a normal `uint256[]`.\n    // Reads and loops will check bounds,\n    // and writing in individual indices like `myArray.array[i] = x`\n    // is perfectly fine.\n    // No curse will befall you as long as you obey this rule:\n    //\n    // XXX: Never try to replace her or separate her from her sister\n    // by writing down the accursed words\n    // `myArray.array = anotherArray` or `lonelyArray = myArray.array`.\n    //\n    // If you do, your cattle will be diseased,\n    // your children will be led astray in the woods,\n    // and your memory will be silently overwritten.\n    // Instead, give her a friend with\n    // `mySecondArray = convert(anotherArray)`,\n    // and call her by her family name first.\n    // She will recognize your respect\n    // and ward your memory against corruption.\n    uint256[] array;\n  }\n\n  struct AddressArray {\n    uint256 allocatedMemory;\n    address[] array;\n  }\n\n  /// @notice Create an empty dynamic array,\n  /// with preallocated memory for up to `length` elements.\n  /// @dev Knowing or estimating the preallocated length in advance\n  /// helps avoid frequent early allocations when filling the array.\n  /// @param length The number of items to preallocate space for.\n  /// @return A new dynamic array.\n  function uintArray(uint256 length) internal pure returns (UintArray memory) {\n    uint256[] memory array = _allocateUints(length);\n    return UintArray(length, array);\n  }\n\n  function addressArray(uint256 length)\n    internal\n    pure\n    returns (AddressArray memory)\n  {\n    address[] memory array = _allocateAddresses(length);\n    return AddressArray(length, array);\n  }\n\n  /// @notice Convert an existing non-dynamic array into a dynamic array.\n  /// @dev The dynamic array is created\n  /// with allocated memory equal to the length of the array.\n  /// @param array The array to convert.\n  /// @return A new dynamic array,\n  /// containing the contents of the argument `array`.\n  function convert(uint256[] memory array)\n    internal\n    pure\n    returns (UintArray memory)\n  {\n    return UintArray(array.length, array);\n  }\n\n  function convert(address[] memory array)\n    internal\n    pure\n    returns (AddressArray memory)\n  {\n    return AddressArray(array.length, array);\n  }\n\n  /// @notice Push `item` into the dynamic array.\n  /// @dev This function will be safe\n  /// as long as you haven't scorned either of the sisters.\n  /// If you have, the dragons will be released\n  /// to wreak havoc upon your memory.\n  /// A spell to dispel the curse exists,\n  /// but a sacred vow prohibits it from being shared\n  /// with those who do not know how to discover it on their own.\n  /// @param self The dynamic array to push into;\n  /// after the call it will be mutated in place to contain the item,\n  /// allocating more memory behind the scenes if necessary.\n  /// @param item The item you wish to push into the array.\n  function arrayPush(UintArray memory self, uint256 item) internal pure {\n    uint256 length = self.array.length;\n    uint256 allocLength = self.allocatedMemory;\n    // The dynamic array is full so we need to allocate more first.\n    // We check for >= instead of ==\n    // so that we can put the require inside the conditional,\n    // reducing the gas costs of `push` slightly.\n    if (length >= allocLength) {\n      // This should never happen if `allocatedMemory` isn't messed with.\n      require(length == allocLength, \"Array length exceeds allocation\");\n      // Allocate twice the original array length,\n      // then copy the contents over.\n      uint256 newMemory = length * 2;\n      uint256[] memory newArray = _allocateUints(newMemory);\n      _copy(newArray, self.array);\n      self.array = newArray;\n      self.allocatedMemory = newMemory;\n    }\n    // We have enough free memory so we can push into the array.\n    _push(self.array, item);\n  }\n\n  function arrayPush(AddressArray memory self, address item) internal pure {\n    uint256 length = self.array.length;\n    uint256 allocLength = self.allocatedMemory;\n    if (length >= allocLength) {\n      require(length == allocLength, \"Array length exceeds allocation\");\n      uint256 newMemory = length * 2;\n      address[] memory newArray = _allocateAddresses(newMemory);\n      _copy(newArray, self.array);\n      self.array = newArray;\n      self.allocatedMemory = newMemory;\n    }\n    _push(self.array, item);\n  }\n\n  /// @notice Pop the last item from the dynamic array,\n  /// removing it and decrementing the array length in place.\n  /// @dev This makes the dragons happy\n  /// as they have more space to roam.\n  /// Thus they have no desire to escape and ravage your buffers.\n  /// @param self The array to pop from.\n  /// @return item The previously last element in the array.\n  function arrayPop(UintArray memory self)\n    internal\n    pure\n    returns (uint256 item)\n  {\n    uint256[] memory array = self.array;\n    uint256 length = array.length;\n    require(length > 0, \"Can't pop from empty array\");\n    return _pop(array);\n  }\n\n  function arrayPop(AddressArray memory self)\n    internal\n    pure\n    returns (address item)\n  {\n    address[] memory array = self.array;\n    uint256 length = array.length;\n    require(length > 0, \"Can't pop from empty array\");\n    return _pop(array);\n  }\n\n  /// @notice Allocate an empty array,\n  /// reserving enough memory to safely store `length` items.\n  /// @dev The array starts with zero length,\n  /// but the allocated buffer has space for `length` words.\n  /// \"What be beyond the bounds of `array`?\" you may ask.\n  /// The answer is: dragons.\n  /// But do not worry,\n  /// for `Array.allocatedMemory` protects your EVM from them.\n  function _allocateUints(uint256 length)\n    private\n    pure\n    returns (uint256[] memory array)\n  {\n    // Calculate the size of the allocated block.\n    // Solidity arrays without a specified constant length\n    // (i.e. `uint256[]` instead of `uint256[8]`)\n    // store the length at the first memory position\n    // and the contents of the array after it,\n    // so we add 1 to the length to account for this.\n    uint256 inMemorySize = (length + 1) * 0x20;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      // Get some free memory\n      array := mload(0x40)\n      // Write a zero in the length field;\n      // we set the length elsewhere\n      // if we store anything in the array immediately.\n      // When we allocate we only know how many words we reserve,\n      // not how many actually get written.\n      mstore(array, 0)\n      // Move the free memory pointer\n      // to the end of the allocated block.\n      mstore(0x40, add(array, inMemorySize))\n    }\n    return array;\n  }\n\n  function _allocateAddresses(uint256 length)\n    private\n    pure\n    returns (address[] memory array)\n  {\n    uint256 inMemorySize = (length + 1) * 0x20;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      array := mload(0x40)\n      mstore(array, 0)\n      mstore(0x40, add(array, inMemorySize))\n    }\n    return array;\n  }\n\n  /// @notice Unsafe function to copy the contents of one array\n  /// into an empty initialized array\n  /// with sufficient free memory available.\n  function _copy(uint256[] memory dest, uint256[] memory src) private pure {\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      let length := mload(src)\n      let byteLength := mul(length, 0x20)\n      // Store the resulting length of the array.\n      mstore(dest, length)\n      // Maintain a write pointer\n      // for the current write location in the destination array\n      // by adding the 32 bytes for the array length\n      // to the starting location.\n      let writePtr := add(dest, 0x20)\n      // Stop copying when the write pointer reaches\n      // the length of the source array.\n      // We can track the endpoint either from the write or read pointer.\n      // This uses the write pointer\n      // because that's the way it was done\n      // in the (public domain) code I stole this from.\n      let end := add(writePtr, byteLength)\n\n      for {\n        // Initialize a read pointer to the start of the source array,\n        // 32 bytes into its memory.\n        let readPtr := add(src, 0x20)\n      } lt(writePtr, end) {\n        // Increase both pointers by 32 bytes each iteration.\n        writePtr := add(writePtr, 0x20)\n        readPtr := add(readPtr, 0x20)\n      } {\n        // Write the source array into the dest memory\n        // 32 bytes at a time.\n        mstore(writePtr, mload(readPtr))\n      }\n    }\n  }\n\n  function _copy(address[] memory dest, address[] memory src) private pure {\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      let length := mload(src)\n      let byteLength := mul(length, 0x20)\n      mstore(dest, length)\n      let writePtr := add(dest, 0x20)\n      let end := add(writePtr, byteLength)\n\n      for {\n        let readPtr := add(src, 0x20)\n      } lt(writePtr, end) {\n        writePtr := add(writePtr, 0x20)\n        readPtr := add(readPtr, 0x20)\n      } {\n        mstore(writePtr, mload(readPtr))\n      }\n    }\n  }\n\n  /// @notice Unsafe function to push past the limit of an array.\n  /// Only use with preallocated free memory.\n  function _push(uint256[] memory array, uint256 item) private pure {\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      // Get array length\n      let length := mload(array)\n      let newLength := add(length, 1)\n      // Calculate how many bytes the array takes in memory,\n      // including the length field.\n      // This is equal to 32 * the incremented length.\n      let arraySize := mul(0x20, newLength)\n      // Calculate the first memory position after the array\n      let nextPosition := add(array, arraySize)\n      // Store the item in the available position\n      mstore(nextPosition, item)\n      // Increment array length\n      mstore(array, newLength)\n    }\n  }\n\n  function _push(address[] memory array, address item) private pure {\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      let length := mload(array)\n      let newLength := add(length, 1)\n      let arraySize := mul(0x20, newLength)\n      let nextPosition := add(array, arraySize)\n      mstore(nextPosition, item)\n      mstore(array, newLength)\n    }\n  }\n\n  function _pop(uint256[] memory array) private pure returns (uint256 item) {\n    uint256 length = array.length;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      // Calculate the memory position of the last element\n      let lastPosition := add(array, mul(length, 0x20))\n      // Retrieve the last item\n      item := mload(lastPosition)\n      // Decrement array length\n      mstore(array, sub(length, 1))\n    }\n    return item;\n  }\n\n  function _pop(address[] memory array) private pure returns (address item) {\n    uint256 length = array.length;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      let lastPosition := add(array, mul(length, 0x20))\n      item := mload(lastPosition)\n      mstore(array, sub(length, 1))\n    }\n    return item;\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/GasStation.sol": {
      "content": "pragma solidity 0.5.17;\n\ncontract GasStation {\n  mapping(address => mapping(uint256 => uint256)) gasDeposits;\n\n  function depositGas(address addr) internal {\n    setDeposit(addr, 1);\n  }\n\n  function releaseGas(address addr) internal {\n    setDeposit(addr, 0);\n  }\n\n  function setDeposit(address addr, uint256 val) internal {\n    for (uint256 i = 0; i < gasDepositSize(); i++) {\n      gasDeposits[addr][i] = val;\n    }\n  }\n\n  function gasDepositSize() internal pure returns (uint256);\n}\n"
    },
    "@keep-network/sortition-pools/contracts/SortitionTree.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./StackLib.sol\";\nimport \"./Branch.sol\";\nimport \"./Position.sol\";\nimport \"./Leaf.sol\";\n\ncontract SortitionTree {\n  using StackLib for uint256[];\n  using Branch for uint256;\n  using Position for uint256;\n  using Leaf for uint256;\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Parameters for configuration\n\n  // How many bits a position uses per level of the tree;\n  // each branch of the tree contains 2**SLOT_BITS slots.\n  uint256 constant SLOT_BITS = 3;\n  uint256 constant LEVELS = 7;\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Derived constants, do not touch\n  uint256 constant SLOT_COUNT = 2**SLOT_BITS;\n  uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;\n  uint256 constant SLOT_MAX = (2**SLOT_WIDTH) - 1;\n  uint256 constant POOL_CAPACITY = SLOT_COUNT**LEVELS;\n  ////////////////////////////////////////////////////////////////////////////\n\n  // implicit tree\n  // root 8\n  // level2 64\n  // level3 512\n  // level4 4k\n  // level5 32k\n  // level6 256k\n  // level7 2M\n  uint256 root;\n  mapping(uint256 => mapping(uint256 => uint256)) branches;\n  mapping(uint256 => uint256) leaves;\n\n  // the flagged (see setFlag() and unsetFlag() in Position.sol) positions\n  // of all operators present in the pool\n  mapping(address => uint256) flaggedLeafPosition;\n\n  // the leaf after the rightmost occupied leaf of each stack\n  uint256 rightmostLeaf;\n  // the empty leaves in each stack\n  // between 0 and the rightmost occupied leaf\n  uint256[] emptyLeaves;\n\n  constructor() public {\n    root = 0;\n    rightmostLeaf = 0;\n  }\n\n  // checks if operator is already registered in the pool\n  function isOperatorRegistered(address operator) public view returns (bool) {\n    return getFlaggedLeafPosition(operator) != 0;\n  }\n\n  // Sum the number of operators in each trunk\n  function operatorsInPool() public view returns (uint256) {\n    // Get the number of leaves that might be occupied;\n    // if `rightmostLeaf` equals `firstLeaf()` the tree must be empty,\n    // otherwise the difference between these numbers\n    // gives the number of leaves that may be occupied.\n    uint256 nPossiblyUsedLeaves = rightmostLeaf;\n    // Get the number of empty leaves\n    // not accounted for by the `rightmostLeaf`\n    uint256 nEmptyLeaves = emptyLeaves.getSize();\n\n    return (nPossiblyUsedLeaves - nEmptyLeaves);\n  }\n\n  function totalWeight() public view returns (uint256) {\n    return root.sumWeight();\n  }\n\n  function insertOperator(address operator, uint256 weight) internal {\n    require(\n      !isOperatorRegistered(operator),\n      \"Operator is already registered in the pool\"\n    );\n\n    uint256 position = getEmptyLeafPosition();\n    // Record the block the operator was inserted in\n    uint256 theLeaf = Leaf.make(operator, block.number, weight);\n\n    root = setLeaf(position, theLeaf, root);\n\n    // Without position flags,\n    // the position 0x000000 would be treated as empty\n    flaggedLeafPosition[operator] = position.setFlag();\n  }\n\n  function removeOperator(address operator) internal {\n    uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n    require(flaggedPosition != 0, \"Operator is not registered in the pool\");\n    uint256 unflaggedPosition = flaggedPosition.unsetFlag();\n    root = removeLeaf(unflaggedPosition, root);\n    removeLeafPositionRecord(operator);\n  }\n\n  function updateOperator(address operator, uint256 weight) internal {\n    require(\n      isOperatorRegistered(operator),\n      \"Operator is not registered in the pool\"\n    );\n\n    uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n    uint256 unflaggedPosition = flaggedPosition.unsetFlag();\n    updateLeaf(unflaggedPosition, weight);\n  }\n\n  function removeLeafPositionRecord(address operator) internal {\n    flaggedLeafPosition[operator] = 0;\n  }\n\n  function getFlaggedLeafPosition(address operator)\n    internal\n    view\n    returns (uint256)\n  {\n    return flaggedLeafPosition[operator];\n  }\n\n  function removeLeaf(uint256 position, uint256 _root)\n    internal\n    returns (uint256)\n  {\n    uint256 rightmostSubOne = rightmostLeaf - 1;\n    bool isRightmost = position == rightmostSubOne;\n\n    uint256 newRoot = setLeaf(position, 0, _root);\n\n    if (isRightmost) {\n      rightmostLeaf = rightmostSubOne;\n    } else {\n      emptyLeaves.stackPush(position);\n    }\n    return newRoot;\n  }\n\n  function updateLeaf(uint256 position, uint256 weight) internal {\n    uint256 oldLeaf = leaves[position];\n    if (oldLeaf.weight() != weight) {\n      uint256 newLeaf = oldLeaf.setWeight(weight);\n      root = setLeaf(position, newLeaf, root);\n    }\n  }\n\n  function setLeaf(\n    uint256 position,\n    uint256 theLeaf,\n    uint256 _root\n  ) internal returns (uint256) {\n    uint256 childSlot;\n    uint256 treeNode;\n    uint256 newNode;\n    uint256 nodeWeight = theLeaf.weight();\n\n    // set leaf\n    leaves[position] = theLeaf;\n\n    uint256 parent = position;\n    // set levels 7 to 2\n    for (uint256 level = LEVELS; level >= 2; level--) {\n      childSlot = parent.slot();\n      parent = parent.parent();\n      treeNode = branches[level][parent];\n      newNode = treeNode.setSlot(childSlot, nodeWeight);\n      branches[level][parent] = newNode;\n      nodeWeight = newNode.sumWeight();\n    }\n\n    // set level Root\n    childSlot = parent.slot();\n    return _root.setSlot(childSlot, nodeWeight);\n  }\n\n  function pickWeightedLeaf(uint256 index, uint256 _root)\n    internal\n    view\n    returns (uint256 leafPosition, uint256 leafFirstIndex)\n  {\n    uint256 currentIndex = index;\n    uint256 currentNode = _root;\n    uint256 currentPosition = 0;\n    uint256 currentSlot;\n\n    require(index < currentNode.sumWeight(), \"Index exceeds weight\");\n\n    // get root slot\n    (currentSlot, currentIndex) = currentNode.pickWeightedSlot(currentIndex);\n\n    // get slots from levels 2 to 7\n    for (uint256 level = 2; level <= LEVELS; level++) {\n      currentPosition = currentPosition.child(currentSlot);\n      currentNode = branches[level][currentPosition];\n      (currentSlot, currentIndex) = currentNode.pickWeightedSlot(currentIndex);\n    }\n\n    // get leaf position\n    leafPosition = currentPosition.child(currentSlot);\n    // get the first index of the leaf\n    // This works because the last weight returned from `pickWeightedSlot()`\n    // equals the \"overflow\" from getting the current slot.\n    leafFirstIndex = index - currentIndex;\n  }\n\n  function getEmptyLeafPosition() internal returns (uint256) {\n    uint256 rLeaf = rightmostLeaf;\n    bool spaceOnRight = (rLeaf + 1) < POOL_CAPACITY;\n    if (spaceOnRight) {\n      rightmostLeaf = rLeaf + 1;\n      return rLeaf;\n    } else {\n      bool emptyLeavesInStack = leavesInStack();\n      require(emptyLeavesInStack, \"Pool is full\");\n      return emptyLeaves.stackPop();\n    }\n  }\n\n  function leavesInStack() internal view returns (bool) {\n    return emptyLeaves.getSize() > 0;\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/StackLib.sol": {
      "content": "pragma solidity 0.5.17;\n\nlibrary StackLib {\n  function stackPeek(uint256[] storage _array) internal view returns (uint256) {\n    require(_array.length > 0, \"No value to peek, array is empty\");\n    return (_array[_array.length - 1]);\n  }\n\n  function stackPush(uint256[] storage _array, uint256 _element) public {\n    _array.push(_element);\n  }\n\n  function stackPop(uint256[] storage _array) internal returns (uint256) {\n    require(_array.length > 0, \"No value to pop, array is empty\");\n    uint256 value = _array[_array.length - 1];\n    _array.length -= 1;\n    return value;\n  }\n\n  function getSize(uint256[] storage _array) internal view returns (uint256) {\n    return _array.length;\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Branch.sol": {
      "content": "pragma solidity 0.5.17;\n\n/// @notice The implicit 8-ary trees of the sortition pool\n/// rely on packing 8 \"slots\" of 32-bit values into each uint256.\n/// The Branch library permits efficient calculations on these slots.\nlibrary Branch {\n  ////////////////////////////////////////////////////////////////////////////\n  // Parameters for configuration\n\n  // How many bits a position uses per level of the tree;\n  // each branch of the tree contains 2**SLOT_BITS slots.\n  uint256 constant SLOT_BITS = 3;\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Derived constants, do not touch\n  uint256 constant SLOT_COUNT = 2**SLOT_BITS;\n  uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;\n  uint256 constant LAST_SLOT = SLOT_COUNT - 1;\n  uint256 constant SLOT_MAX = (2**SLOT_WIDTH) - 1;\n\n  ////////////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate the right shift required\n  /// to make the 32 least significant bits of an uint256\n  /// be the bits of the `position`th slot\n  /// when treating the uint256 as a uint32[8].\n  ///\n  /// @dev Not used for efficiency reasons,\n  /// but left to illustrate the meaning of a common pattern.\n  /// I wish solidity had macros, even C macros.\n  function slotShift(uint256 position) internal pure returns (uint256) {\n    return position * SLOT_WIDTH;\n  }\n\n  /// @notice Return the `position`th slot of the `node`,\n  /// treating `node` as a uint32[32].\n  function getSlot(uint256 node, uint256 position)\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 shiftBits = position * SLOT_WIDTH;\n    // Doing a bitwise AND with `SLOT_MAX`\n    // clears all but the 32 least significant bits.\n    // Because of the right shift by `slotShift(position)` bits,\n    // those 32 bits contain the 32 bits in the `position`th slot of `node`.\n    return (node >> shiftBits) & SLOT_MAX;\n  }\n\n  /// @notice Return `node` with the `position`th slot set to zero.\n  function clearSlot(uint256 node, uint256 position)\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 shiftBits = position * SLOT_WIDTH;\n    // Shifting `SLOT_MAX` left by `slotShift(position)` bits\n    // gives us a number where all bits of the `position`th slot are set,\n    // and all other bits are unset.\n    //\n    // Using a bitwise NOT on this number,\n    // we get a uint256 where all bits are set\n    // except for those of the `position`th slot.\n    //\n    // Bitwise ANDing the original `node` with this number\n    // sets the bits of `position`th slot to zero,\n    // leaving all other bits unchanged.\n    return node & ~(SLOT_MAX << shiftBits);\n  }\n\n  /// @notice Return `node` with the `position`th slot set to `weight`.\n  ///\n  /// @param weight The weight of of the node.\n  /// Safely truncated to a 32-bit number,\n  /// but this should never be called with an overflowing weight regardless.\n  function setSlot(\n    uint256 node,\n    uint256 position,\n    uint256 weight\n  ) internal pure returns (uint256) {\n    uint256 shiftBits = position * SLOT_WIDTH;\n    // Clear the `position`th slot like in `clearSlot()`.\n    uint256 clearedNode = node & ~(SLOT_MAX << shiftBits);\n    // Bitwise AND `weight` with `SLOT_MAX`\n    // to clear all but the 32 least significant bits.\n    //\n    // Shift this left by `slotShift(position)` bits\n    // to obtain a uint256 with all bits unset\n    // except in the `position`th slot\n    // which contains the 32-bit value of `weight`.\n    uint256 shiftedWeight = (weight & SLOT_MAX) << shiftBits;\n    // When we bitwise OR these together,\n    // all other slots except the `position`th one come from the left argument,\n    // and the `position`th gets filled with `weight` from the right argument.\n    return clearedNode | shiftedWeight;\n  }\n\n  /// @notice Calculate the summed weight of all slots in the `node`.\n  function sumWeight(uint256 node) internal pure returns (uint256 sum) {\n    sum = node & SLOT_MAX;\n    // Iterate through each slot\n    // by shifting `node` right in increments of 32 bits,\n    // and adding the 32 least significant bits to the `sum`.\n    uint256 newNode = node >> SLOT_WIDTH;\n    while (newNode > 0) {\n      sum += (newNode & SLOT_MAX);\n      newNode = newNode >> SLOT_WIDTH;\n    }\n    return sum;\n  }\n\n  /// @notice Pick a slot in `node` that corresponds to `index`.\n  /// Treats the node like an array of virtual stakers,\n  /// the number of virtual stakers in each slot corresponding to its weight,\n  /// and picks which slot contains the `index`th virtual staker.\n  ///\n  /// @dev Requires that `index` be lower than `sumWeight(node)`.\n  /// However, this is not enforced for performance reasons.\n  /// If `index` exceeds the permitted range,\n  /// `pickWeightedSlot()` returns the rightmost slot\n  /// and an excessively high `newIndex`.\n  ///\n  /// @return slot The slot of `node` containing the `index`th virtual staker.\n  ///\n  /// @return newIndex The index of the `index`th virtual staker of `node`\n  /// within the returned slot.\n  function pickWeightedSlot(uint256 node, uint256 index)\n    internal\n    pure\n    returns (uint256 slot, uint256 newIndex)\n  {\n    newIndex = index;\n    uint256 newNode = node;\n    uint256 currentSlotWeight = newNode & SLOT_MAX;\n    while (newIndex >= currentSlotWeight) {\n      newIndex -= currentSlotWeight;\n      slot++;\n      newNode = newNode >> SLOT_WIDTH;\n      currentSlotWeight = newNode & SLOT_MAX;\n    }\n    return (slot, newIndex);\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Position.sol": {
      "content": "pragma solidity 0.5.17;\n\nlibrary Position {\n  ////////////////////////////////////////////////////////////////////////////\n  // Parameters for configuration\n\n  // How many bits a position uses per level of the tree;\n  // each branch of the tree contains 2**SLOT_BITS slots.\n  uint256 constant SLOT_BITS = 3;\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Derived constants, do not touch\n  uint256 constant SLOT_POINTER_MAX = (2**SLOT_BITS) - 1;\n  uint256 constant LEAF_FLAG = 1 << 255;\n\n  ////////////////////////////////////////////////////////////////////////////\n\n  // Return the last 3 bits of a position number,\n  // corresponding to its slot in its parent\n  function slot(uint256 a) internal pure returns (uint256) {\n    return a & SLOT_POINTER_MAX;\n  }\n\n  // Return the parent of a position number\n  function parent(uint256 a) internal pure returns (uint256) {\n    return a >> SLOT_BITS;\n  }\n\n  // Return the location of the child of a at the given slot\n  function child(uint256 a, uint256 s) internal pure returns (uint256) {\n    return (a << SLOT_BITS) | (s & SLOT_POINTER_MAX); // slot(s)\n  }\n\n  // Return the uint p as a flagged position uint:\n  // the least significant 21 bits contain the position\n  // and the 22nd bit is set as a flag\n  // to distinguish the position 0x000000 from an empty field.\n  function setFlag(uint256 p) internal pure returns (uint256) {\n    return p | LEAF_FLAG;\n  }\n\n  // Turn a flagged position into an unflagged position\n  // by removing the flag at the 22nd least significant bit.\n  //\n  // We shouldn't _actually_ need this\n  // as all position-manipulating code should ignore non-position bits anyway\n  // but it's cheap to call so might as well do it.\n  function unsetFlag(uint256 p) internal pure returns (uint256) {\n    return p & (~LEAF_FLAG);\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Leaf.sol": {
      "content": "pragma solidity 0.5.17;\n\nlibrary Leaf {\n  ////////////////////////////////////////////////////////////////////////////\n  // Parameters for configuration\n\n  // How many bits a position uses per level of the tree;\n  // each branch of the tree contains 2**SLOT_BITS slots.\n  uint256 constant SLOT_BITS = 3;\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Derived constants, do not touch\n  uint256 constant SLOT_COUNT = 2**SLOT_BITS;\n  uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;\n  uint256 constant SLOT_MAX = (2**SLOT_WIDTH) - 1;\n\n  uint256 constant WEIGHT_WIDTH = SLOT_WIDTH;\n  uint256 constant WEIGHT_MAX = SLOT_MAX;\n\n  uint256 constant BLOCKHEIGHT_WIDTH = 96 - WEIGHT_WIDTH;\n  uint256 constant BLOCKHEIGHT_MAX = (2**BLOCKHEIGHT_WIDTH) - 1;\n\n  ////////////////////////////////////////////////////////////////////////////\n\n  function make(\n    address _operator,\n    uint256 _creationBlock,\n    uint256 _weight\n  ) internal pure returns (uint256) {\n    // Converting a bytesX type into a larger type\n    // adds zero bytes on the right.\n    uint256 op = uint256(bytes32(bytes20(_operator)));\n    // Bitwise AND the weight to erase\n    // all but the 32 least significant bits\n    uint256 wt = _weight & WEIGHT_MAX;\n    // Erase all but the 64 least significant bits,\n    // then shift left by 32 bits to make room for the weight\n    uint256 cb = (_creationBlock & BLOCKHEIGHT_MAX) << WEIGHT_WIDTH;\n    // Bitwise OR them all together to get\n    // [address operator || uint64 creationBlock || uint32 weight]\n    return (op | cb | wt);\n  }\n\n  function operator(uint256 leaf) internal pure returns (address) {\n    // Converting a bytesX type into a smaller type\n    // truncates it on the right.\n    return address(bytes20(bytes32(leaf)));\n  }\n\n  /// @notice Return the block number the leaf was created in.\n  function creationBlock(uint256 leaf) internal pure returns (uint256) {\n    return ((leaf >> WEIGHT_WIDTH) & BLOCKHEIGHT_MAX);\n  }\n\n  function weight(uint256 leaf) internal pure returns (uint256) {\n    // Weight is stored in the 32 least significant bits.\n    // Bitwise AND ensures that we only get the contents of those bits.\n    return (leaf & WEIGHT_MAX);\n  }\n\n  function setWeight(uint256 leaf, uint256 newWeight)\n    internal\n    pure\n    returns (uint256)\n  {\n    return ((leaf & ~WEIGHT_MAX) | (newWeight & WEIGHT_MAX));\n  }\n}\n"
    },
    "@keep-network/sortition-pools/contracts/Interval.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./Leaf.sol\";\nimport \"./DynamicArray.sol\";\n\nlibrary Interval {\n  using DynamicArray for DynamicArray.UintArray;\n  ////////////////////////////////////////////////////////////////////////////\n  // Parameters for configuration\n\n  // How many bits a position uses per level of the tree;\n  // each branch of the tree contains 2**SLOT_BITS slots.\n  uint256 constant SLOT_BITS = 3;\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Derived constants, do not touch\n  uint256 constant SLOT_COUNT = 2**SLOT_BITS;\n  uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;\n  uint256 constant SLOT_MAX = (2**SLOT_WIDTH) - 1;\n\n  uint256 constant WEIGHT_WIDTH = SLOT_WIDTH;\n  uint256 constant WEIGHT_MAX = SLOT_MAX;\n\n  uint256 constant START_INDEX_WIDTH = WEIGHT_WIDTH;\n  uint256 constant START_INDEX_MAX = WEIGHT_MAX;\n  uint256 constant START_INDEX_SHIFT = WEIGHT_WIDTH;\n\n  ////////////////////////////////////////////////////////////////////////////\n\n  // Interval stores information about a selected interval\n  // inside a single uint256 in a manner similar to Leaf\n  // but optimized for use within group selection\n  //\n  // The information stored consists of:\n  // - weight\n  // - starting index\n\n  function make(uint256 startingIndex, uint256 weight)\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 idx = (startingIndex & START_INDEX_MAX) << START_INDEX_SHIFT;\n    uint256 wt = weight & WEIGHT_MAX;\n    return (idx | wt);\n  }\n\n  function opWeight(uint256 op) internal pure returns (uint256) {\n    return (op & WEIGHT_MAX);\n  }\n\n  // Return the starting index of the interval\n  function index(uint256 a) internal pure returns (uint256) {\n    return ((a >> WEIGHT_WIDTH) & START_INDEX_MAX);\n  }\n\n  function setIndex(uint256 op, uint256 i) internal pure returns (uint256) {\n    uint256 shiftedIndex = ((i & START_INDEX_MAX) << WEIGHT_WIDTH);\n    return (op & (~(START_INDEX_MAX << WEIGHT_WIDTH))) | shiftedIndex;\n  }\n\n  function insert(DynamicArray.UintArray memory intervals, uint256 interval)\n    internal\n    pure\n  {\n    uint256 tempInterval = interval;\n    for (uint256 i = 0; i < intervals.array.length; i++) {\n      uint256 thisInterval = intervals.array[i];\n      // We can compare the raw underlying uint256 values\n      // because the starting index is stored\n      // in the most significant nonzero bits.\n      if (tempInterval < thisInterval) {\n        intervals.array[i] = tempInterval;\n        tempInterval = thisInterval;\n      }\n    }\n    intervals.arrayPush(tempInterval);\n  }\n\n  function skip(uint256 truncatedIndex, DynamicArray.UintArray memory intervals)\n    internal\n    pure\n    returns (uint256 mappedIndex)\n  {\n    mappedIndex = truncatedIndex;\n    for (uint256 i = 0; i < intervals.array.length; i++) {\n      uint256 interval = intervals.array[i];\n      // If the index is greater than the starting index of the `i`th leaf,\n      // we need to skip that leaf.\n      if (mappedIndex >= index(interval)) {\n        // Add the weight of this previous leaf to the index,\n        // ensuring that we skip the leaf.\n        mappedIndex += Leaf.weight(interval);\n      } else {\n        break;\n      }\n    }\n    return mappedIndex;\n  }\n\n  /// @notice Recalculate the starting indices of the previousLeaves\n  /// when an interval is removed or added at the specified index.\n  /// @dev Applies weightDiff to each starting index in previousLeaves\n  /// that exceeds affectedStartingIndex.\n  /// @param affectedStartingIndex The starting index of the interval.\n  /// @param weightDiff The difference in weight;\n  /// negative for a deleted interval,\n  /// positive for an added interval.\n  /// @param previousLeaves The starting indices and weights\n  /// of the previously selected leaves.\n  /// @return The starting indices of the previous leaves\n  /// in a tree with the affected interval updated.\n  function remapIndices(\n    uint256 affectedStartingIndex,\n    int256 weightDiff,\n    DynamicArray.UintArray memory previousLeaves\n  ) internal pure {\n    uint256 nPreviousLeaves = previousLeaves.array.length;\n\n    for (uint256 i = 0; i < nPreviousLeaves; i++) {\n      uint256 interval = previousLeaves.array[i];\n      uint256 startingIndex = index(interval);\n      // If index is greater than the index of the affected interval,\n      // update the starting index by the weight change.\n      if (startingIndex > affectedStartingIndex) {\n        uint256 newIndex = uint256(int256(startingIndex) + weightDiff);\n        previousLeaves.array[i] = setIndex(interval, newIndex);\n      }\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "libraries": {
      "@keep-network/sortition-pools/contracts/BondedSortitionPoolFactory.sol": {
        "StackLib": "0xdf6542260a9F768f07030E4895083F804241F4C4"
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}