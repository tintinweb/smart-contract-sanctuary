{{
  "language": "Solidity",
  "sources": {
    "contracts/DInterest.sol": {
      "content": "pragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"./libs/DecMath.sol\";\nimport \"./moneymarkets/IMoneyMarket.sol\";\nimport \"./models/fee/IFeeModel.sol\";\nimport \"./models/interest/IInterestModel.sol\";\nimport \"./NFT.sol\";\nimport \"./rewards/MPHMinter.sol\";\nimport \"./models/interest-oracle/IInterestOracle.sol\";\n\n// DeLorean Interest -- It's coming back from the future!\n// EL PSY CONGROO\n// Author: Zefram Lou\n// Contact: zefram@baconlabs.dev\ncontract DInterest is ReentrancyGuard, Ownable {\n    using SafeMath for uint256;\n    using DecMath for uint256;\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    // Constants\n    uint256 internal constant PRECISION = 10**18;\n    uint256 internal constant ONE = 10**18;\n\n    // User deposit data\n    // Each deposit has an ID used in the depositNFT, which is equal to its index in `deposits` plus 1\n    struct Deposit {\n        uint256 amount; // Amount of stablecoin deposited\n        uint256 maturationTimestamp; // Unix timestamp after which the deposit may be withdrawn, in seconds\n        uint256 interestOwed; // Deficit incurred to the pool at time of deposit\n        uint256 initialMoneyMarketIncomeIndex; // Money market's income index at time of deposit\n        bool active; // True if not yet withdrawn, false if withdrawn\n        bool finalSurplusIsNegative;\n        uint256 finalSurplusAmount; // Surplus remaining after withdrawal\n        uint256 mintMPHAmount; // Amount of MPH minted to user\n    }\n    Deposit[] internal deposits;\n    uint256 public latestFundedDepositID; // the ID of the most recently created deposit that was funded\n    uint256 public unfundedUserDepositAmount; // the deposited stablecoin amount whose deficit hasn't been funded\n\n    // Funding data\n    // Each funding has an ID used in the fundingNFT, which is equal to its index in `fundingList` plus 1\n    struct Funding {\n        // deposits with fromDepositID < ID <= toDepositID are funded\n        uint256 fromDepositID;\n        uint256 toDepositID;\n        uint256 recordedFundedDepositAmount;\n        uint256 recordedMoneyMarketIncomeIndex;\n    }\n    Funding[] internal fundingList;\n\n    // Params\n    uint256 public MinDepositPeriod; // Minimum deposit period, in seconds\n    uint256 public MaxDepositPeriod; // Maximum deposit period, in seconds\n    uint256 public MinDepositAmount; // Minimum deposit amount for each deposit, in stablecoins\n    uint256 public MaxDepositAmount; // Maximum deposit amount for each deposit, in stablecoins\n\n    // Instance variables\n    uint256 public totalDeposit;\n    uint256 public totalInterestOwed;\n\n    // External smart contracts\n    IMoneyMarket public moneyMarket;\n    ERC20 public stablecoin;\n    IFeeModel public feeModel;\n    IInterestModel public interestModel;\n    IInterestOracle public interestOracle;\n    NFT public depositNFT;\n    NFT public fundingNFT;\n    MPHMinter public mphMinter;\n\n    // Events\n    event EDeposit(\n        address indexed sender,\n        uint256 indexed depositID,\n        uint256 amount,\n        uint256 maturationTimestamp,\n        uint256 interestAmount,\n        uint256 mintMPHAmount\n    );\n    event EWithdraw(\n        address indexed sender,\n        uint256 indexed depositID,\n        uint256 indexed fundingID,\n        bool early,\n        uint256 takeBackMPHAmount\n    );\n    event EFund(\n        address indexed sender,\n        uint256 indexed fundingID,\n        uint256 deficitAmount,\n        uint256 mintMPHAmount\n    );\n    event ESetParamAddress(\n        address indexed sender,\n        string indexed paramName,\n        address newValue\n    );\n    event ESetParamUint(\n        address indexed sender,\n        string indexed paramName,\n        uint256 newValue\n    );\n\n    struct DepositLimit {\n        uint256 MinDepositPeriod;\n        uint256 MaxDepositPeriod;\n        uint256 MinDepositAmount;\n        uint256 MaxDepositAmount;\n    }\n\n    constructor(\n        DepositLimit memory _depositLimit,\n        address _moneyMarket, // Address of IMoneyMarket that's used for generating interest (owner must be set to this DInterest contract)\n        address _stablecoin, // Address of the stablecoin used to store funds\n        address _feeModel, // Address of the FeeModel contract that determines how fees are charged\n        address _interestModel, // Address of the InterestModel contract that determines how much interest to offer\n        address _interestOracle, // Address of the InterestOracle contract that provides the average interest rate\n        address _depositNFT, // Address of the NFT representing ownership of deposits (owner must be set to this DInterest contract)\n        address _fundingNFT, // Address of the NFT representing ownership of fundings (owner must be set to this DInterest contract)\n        address _mphMinter // Address of the contract for handling minting MPH to users\n    ) public {\n        // Verify input addresses\n        require(\n            _moneyMarket.isContract() &&\n                _stablecoin.isContract() &&\n                _feeModel.isContract() &&\n                _interestModel.isContract() &&\n                _interestOracle.isContract() &&\n                _depositNFT.isContract() &&\n                _fundingNFT.isContract() &&\n                _mphMinter.isContract(),\n            \"DInterest: An input address is not a contract\"\n        );\n\n        moneyMarket = IMoneyMarket(_moneyMarket);\n        stablecoin = ERC20(_stablecoin);\n        feeModel = IFeeModel(_feeModel);\n        interestModel = IInterestModel(_interestModel);\n        interestOracle = IInterestOracle(_interestOracle);\n        depositNFT = NFT(_depositNFT);\n        fundingNFT = NFT(_fundingNFT);\n        mphMinter = MPHMinter(_mphMinter);\n\n        // Ensure moneyMarket uses the same stablecoin\n        require(\n            moneyMarket.stablecoin() == _stablecoin,\n            \"DInterest: moneyMarket.stablecoin() != _stablecoin\"\n        );\n\n        // Ensure interestOracle uses the same moneyMarket\n        require(\n            interestOracle.moneyMarket() == _moneyMarket,\n            \"DInterest: interestOracle.moneyMarket() != _moneyMarket\"\n        );\n\n        // Verify input uint256 parameters\n        require(\n            _depositLimit.MaxDepositPeriod > 0 &&\n                _depositLimit.MaxDepositAmount > 0,\n            \"DInterest: An input uint256 is 0\"\n        );\n        require(\n            _depositLimit.MinDepositPeriod <= _depositLimit.MaxDepositPeriod,\n            \"DInterest: Invalid DepositPeriod range\"\n        );\n        require(\n            _depositLimit.MinDepositAmount <= _depositLimit.MaxDepositAmount,\n            \"DInterest: Invalid DepositAmount range\"\n        );\n\n        MinDepositPeriod = _depositLimit.MinDepositPeriod;\n        MaxDepositPeriod = _depositLimit.MaxDepositPeriod;\n        MinDepositAmount = _depositLimit.MinDepositAmount;\n        MaxDepositAmount = _depositLimit.MaxDepositAmount;\n        totalDeposit = 0;\n    }\n\n    /**\n        Public actions\n     */\n\n    function deposit(uint256 amount, uint256 maturationTimestamp)\n        external\n        nonReentrant\n    {\n        _deposit(amount, maturationTimestamp);\n    }\n\n    function withdraw(uint256 depositID, uint256 fundingID)\n        external\n        nonReentrant\n    {\n        _withdraw(depositID, fundingID, false);\n    }\n\n    function earlyWithdraw(uint256 depositID, uint256 fundingID)\n        external\n        nonReentrant\n    {\n        _withdraw(depositID, fundingID, true);\n    }\n\n    function multiDeposit(\n        uint256[] calldata amountList,\n        uint256[] calldata maturationTimestampList\n    ) external nonReentrant {\n        require(\n            amountList.length == maturationTimestampList.length,\n            \"DInterest: List lengths unequal\"\n        );\n        for (uint256 i = 0; i < amountList.length; i = i.add(1)) {\n            _deposit(amountList[i], maturationTimestampList[i]);\n        }\n    }\n\n    function multiWithdraw(\n        uint256[] calldata depositIDList,\n        uint256[] calldata fundingIDList\n    ) external nonReentrant {\n        require(\n            depositIDList.length == fundingIDList.length,\n            \"DInterest: List lengths unequal\"\n        );\n        for (uint256 i = 0; i < depositIDList.length; i = i.add(1)) {\n            _withdraw(depositIDList[i], fundingIDList[i], false);\n        }\n    }\n\n    function multiEarlyWithdraw(\n        uint256[] calldata depositIDList,\n        uint256[] calldata fundingIDList\n    ) external nonReentrant {\n        require(\n            depositIDList.length == fundingIDList.length,\n            \"DInterest: List lengths unequal\"\n        );\n        for (uint256 i = 0; i < depositIDList.length; i = i.add(1)) {\n            _withdraw(depositIDList[i], fundingIDList[i], true);\n        }\n    }\n\n    /**\n        Deficit funding\n     */\n\n    function fundAll() external nonReentrant {\n        // Calculate current deficit\n        (bool isNegative, uint256 deficit) = surplus();\n        require(isNegative, \"DInterest: No deficit available\");\n        require(\n            !depositIsFunded(deposits.length),\n            \"DInterest: All deposits funded\"\n        );\n\n        // Create funding struct\n        uint256 incomeIndex = moneyMarket.incomeIndex();\n        require(incomeIndex > 0, \"DInterest: incomeIndex == 0\");\n        fundingList.push(\n            Funding({\n                fromDepositID: latestFundedDepositID,\n                toDepositID: deposits.length,\n                recordedFundedDepositAmount: unfundedUserDepositAmount,\n                recordedMoneyMarketIncomeIndex: incomeIndex\n            })\n        );\n\n        // Update relevant values\n        latestFundedDepositID = deposits.length;\n        unfundedUserDepositAmount = 0;\n\n        _fund(deficit);\n    }\n\n    function fundMultiple(uint256 toDepositID) external nonReentrant {\n        require(\n            toDepositID > latestFundedDepositID,\n            \"DInterest: Deposits already funded\"\n        );\n        require(\n            toDepositID <= deposits.length,\n            \"DInterest: Invalid toDepositID\"\n        );\n\n        (bool isNegative, uint256 surplus) = surplus();\n        require(isNegative, \"DInterest: No deficit available\");\n\n        uint256 totalDeficit = 0;\n        uint256 totalSurplus = 0;\n        uint256 totalDepositToFund = 0;\n        // Deposits with ID [latestFundedDepositID+1, toDepositID] will be funded\n        for (\n            uint256 id = latestFundedDepositID.add(1);\n            id <= toDepositID;\n            id = id.add(1)\n        ) {\n            Deposit storage depositEntry = _getDeposit(id);\n            if (depositEntry.active) {\n                // Deposit still active, use current surplus\n                (isNegative, surplus) = surplusOfDeposit(id);\n            } else {\n                // Deposit has been withdrawn, use recorded final surplus\n                (isNegative, surplus) = (\n                    depositEntry.finalSurplusIsNegative,\n                    depositEntry.finalSurplusAmount\n                );\n            }\n\n            if (isNegative) {\n                // Add on deficit to total\n                totalDeficit = totalDeficit.add(surplus);\n            } else {\n                // Has surplus\n                totalSurplus = totalSurplus.add(surplus);\n            }\n\n            if (depositEntry.active) {\n                totalDepositToFund = totalDepositToFund.add(\n                    depositEntry.amount\n                );\n            }\n        }\n        if (totalSurplus >= totalDeficit) {\n            // Deposits selected have a surplus as a whole, revert\n            revert(\"DInterest: Selected deposits in surplus\");\n        } else {\n            // Deduct surplus from totalDeficit\n            totalDeficit = totalDeficit.sub(totalSurplus);\n        }\n\n        // Create funding struct\n        uint256 incomeIndex = moneyMarket.incomeIndex();\n        require(incomeIndex > 0, \"DInterest: incomeIndex == 0\");\n        fundingList.push(\n            Funding({\n                fromDepositID: latestFundedDepositID,\n                toDepositID: toDepositID,\n                recordedFundedDepositAmount: totalDepositToFund,\n                recordedMoneyMarketIncomeIndex: incomeIndex\n            })\n        );\n\n        // Update relevant values\n        latestFundedDepositID = toDepositID;\n        unfundedUserDepositAmount = unfundedUserDepositAmount.sub(\n            totalDepositToFund\n        );\n\n        _fund(totalDeficit);\n    }\n\n    /**\n        Public getters\n     */\n\n    function calculateInterestAmount(\n        uint256 depositAmount,\n        uint256 depositPeriodInSeconds\n    ) public returns (uint256 interestAmount) {\n        (, uint256 moneyMarketInterestRatePerSecond) = interestOracle\n            .updateAndQuery();\n        (bool surplusIsNegative, uint256 surplusAmount) = surplus();\n\n        return\n            interestModel.calculateInterestAmount(\n                depositAmount,\n                depositPeriodInSeconds,\n                moneyMarketInterestRatePerSecond,\n                surplusIsNegative,\n                surplusAmount\n            );\n    }\n\n    function surplus() public returns (bool isNegative, uint256 surplusAmount) {\n        uint256 totalValue = moneyMarket.totalValue();\n        uint256 totalOwed = totalDeposit.add(totalInterestOwed);\n        if (totalValue >= totalOwed) {\n            // Locked value more than owed deposits, positive surplus\n            isNegative = false;\n            surplusAmount = totalValue.sub(totalOwed);\n        } else {\n            // Locked value less than owed deposits, negative surplus\n            isNegative = true;\n            surplusAmount = totalOwed.sub(totalValue);\n        }\n    }\n\n    function surplusOfDeposit(uint256 depositID)\n        public\n        returns (bool isNegative, uint256 surplusAmount)\n    {\n        Deposit storage depositEntry = _getDeposit(depositID);\n        uint256 currentMoneyMarketIncomeIndex = moneyMarket.incomeIndex();\n        uint256 currentDepositValue = depositEntry\n            .amount\n            .mul(currentMoneyMarketIncomeIndex)\n            .div(depositEntry.initialMoneyMarketIncomeIndex);\n        uint256 owed = depositEntry.amount.add(depositEntry.interestOwed);\n        if (currentDepositValue >= owed) {\n            // Locked value more than owed deposits, positive surplus\n            isNegative = false;\n            surplusAmount = currentDepositValue.sub(owed);\n        } else {\n            // Locked value less than owed deposits, negative surplus\n            isNegative = true;\n            surplusAmount = owed.sub(currentDepositValue);\n        }\n    }\n\n    function depositIsFunded(uint256 id) public view returns (bool) {\n        return (id <= latestFundedDepositID);\n    }\n\n    function depositsLength() external view returns (uint256) {\n        return deposits.length;\n    }\n\n    function fundingListLength() external view returns (uint256) {\n        return fundingList.length;\n    }\n\n    function getDeposit(uint256 depositID)\n        external\n        view\n        returns (Deposit memory)\n    {\n        return deposits[depositID.sub(1)];\n    }\n\n    function getFunding(uint256 fundingID)\n        external\n        view\n        returns (Funding memory)\n    {\n        return fundingList[fundingID.sub(1)];\n    }\n\n    function moneyMarketIncomeIndex() external returns (uint256) {\n        return moneyMarket.incomeIndex();\n    }\n\n    /**\n        Param setters\n     */\n    function setFeeModel(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: not contract\");\n        feeModel = IFeeModel(newValue);\n        emit ESetParamAddress(msg.sender, \"feeModel\", newValue);\n    }\n\n    function setInterestModel(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: not contract\");\n        interestModel = IInterestModel(newValue);\n        emit ESetParamAddress(msg.sender, \"interestModel\", newValue);\n    }\n\n    function setInterestOracle(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: not contract\");\n        interestOracle = IInterestOracle(newValue);\n        emit ESetParamAddress(msg.sender, \"interestOracle\", newValue);\n    }\n\n    function setRewards(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"DInterest: not contract\");\n        moneyMarket.setRewards(newValue);\n        emit ESetParamAddress(msg.sender, \"moneyMarket.rewards\", newValue);\n    }\n\n    function setMinDepositPeriod(uint256 newValue) external onlyOwner {\n        require(newValue <= MaxDepositPeriod, \"DInterest: invalid value\");\n        MinDepositPeriod = newValue;\n        emit ESetParamUint(msg.sender, \"MinDepositPeriod\", newValue);\n    }\n\n    function setMaxDepositPeriod(uint256 newValue) external onlyOwner {\n        require(\n            newValue >= MinDepositPeriod && newValue > 0,\n            \"DInterest: invalid value\"\n        );\n        MaxDepositPeriod = newValue;\n        emit ESetParamUint(msg.sender, \"MaxDepositPeriod\", newValue);\n    }\n\n    function setMinDepositAmount(uint256 newValue) external onlyOwner {\n        require(newValue <= MaxDepositAmount, \"DInterest: invalid value\");\n        MinDepositAmount = newValue;\n        emit ESetParamUint(msg.sender, \"MinDepositAmount\", newValue);\n    }\n\n    function setMaxDepositAmount(uint256 newValue) external onlyOwner {\n        require(\n            newValue >= MinDepositAmount && newValue > 0,\n            \"DInterest: invalid value\"\n        );\n        MaxDepositAmount = newValue;\n        emit ESetParamUint(msg.sender, \"MaxDepositAmount\", newValue);\n    }\n\n    function setDepositNFTTokenURI(uint256 tokenId, string calldata newURI)\n        external\n        onlyOwner\n    {\n        depositNFT.setTokenURI(tokenId, newURI);\n    }\n\n    function setDepositNFTBaseURI(string calldata newURI) external onlyOwner {\n        depositNFT.setBaseURI(newURI);\n    }\n\n    function setDepositNFTContractURI(string calldata newURI)\n        external\n        onlyOwner\n    {\n        depositNFT.setContractURI(newURI);\n    }\n\n    function setFundingNFTTokenURI(uint256 tokenId, string calldata newURI)\n        external\n        onlyOwner\n    {\n        fundingNFT.setTokenURI(tokenId, newURI);\n    }\n\n    function setFundingNFTBaseURI(string calldata newURI) external onlyOwner {\n        fundingNFT.setBaseURI(newURI);\n    }\n\n    function setFundingNFTContractURI(string calldata newURI)\n        external\n        onlyOwner\n    {\n        fundingNFT.setContractURI(newURI);\n    }\n\n    /**\n        Internal getters\n     */\n\n    function _getDeposit(uint256 depositID)\n        internal\n        view\n        returns (Deposit storage)\n    {\n        return deposits[depositID.sub(1)];\n    }\n\n    function _getFunding(uint256 fundingID)\n        internal\n        view\n        returns (Funding storage)\n    {\n        return fundingList[fundingID.sub(1)];\n    }\n\n    /**\n        Internals\n     */\n\n    function _deposit(uint256 amount, uint256 maturationTimestamp) internal {\n        // Cannot deposit 0\n        require(amount > 0, \"DInterest: Deposit amount is 0\");\n\n        // Ensure deposit amount is not more than maximum\n        require(\n            amount >= MinDepositAmount && amount <= MaxDepositAmount,\n            \"DInterest: Deposit amount out of range\"\n        );\n\n        // Ensure deposit period is at least MinDepositPeriod\n        uint256 depositPeriod = maturationTimestamp.sub(now);\n        require(\n            depositPeriod >= MinDepositPeriod &&\n                depositPeriod <= MaxDepositPeriod,\n            \"DInterest: Deposit period out of range\"\n        );\n\n        // Update totalDeposit\n        totalDeposit = totalDeposit.add(amount);\n\n        // Update funding related data\n        uint256 id = deposits.length.add(1);\n        unfundedUserDepositAmount = unfundedUserDepositAmount.add(amount);\n\n        // Calculate interest\n        uint256 interestAmount = calculateInterestAmount(amount, depositPeriod);\n        require(interestAmount > 0, \"DInterest: interestAmount == 0\");\n\n        // Update totalInterestOwed\n        totalInterestOwed = totalInterestOwed.add(interestAmount);\n\n        // Mint MPH for msg.sender\n        uint256 mintMPHAmount = mphMinter.mintDepositorReward(\n            msg.sender,\n            interestAmount\n        );\n\n        // Record deposit data for `msg.sender`\n        deposits.push(\n            Deposit({\n                amount: amount,\n                maturationTimestamp: maturationTimestamp,\n                interestOwed: interestAmount,\n                initialMoneyMarketIncomeIndex: moneyMarket.incomeIndex(),\n                active: true,\n                finalSurplusIsNegative: false,\n                finalSurplusAmount: 0,\n                mintMPHAmount: mintMPHAmount\n            })\n        );\n\n        // Transfer `amount` stablecoin to DInterest\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Lend `amount` stablecoin to money market\n        stablecoin.safeIncreaseAllowance(address(moneyMarket), amount);\n        moneyMarket.deposit(amount);\n\n        // Mint depositNFT\n        depositNFT.mint(msg.sender, id);\n\n        // Emit event\n        emit EDeposit(\n            msg.sender,\n            id,\n            amount,\n            maturationTimestamp,\n            interestAmount,\n            mintMPHAmount\n        );\n    }\n\n    function _withdraw(\n        uint256 depositID,\n        uint256 fundingID,\n        bool early\n    ) internal {\n        Deposit storage depositEntry = _getDeposit(depositID);\n\n        // Verify deposit is active and set to inactive\n        require(depositEntry.active, \"DInterest: Deposit not active\");\n        depositEntry.active = false;\n\n        if (early) {\n            // Verify `now < depositEntry.maturationTimestamp`\n            require(\n                now < depositEntry.maturationTimestamp,\n                \"DInterest: Deposit mature, use withdraw() instead\"\n            );\n        } else {\n            // Verify `now >= depositEntry.maturationTimestamp`\n            require(\n                now >= depositEntry.maturationTimestamp,\n                \"DInterest: Deposit not mature\"\n            );\n        }\n\n        // Verify msg.sender owns the depositNFT\n        require(\n            depositNFT.ownerOf(depositID) == msg.sender,\n            \"DInterest: Sender doesn't own depositNFT\"\n        );\n\n        // Take back MPH\n        uint256 takeBackMPHAmount = mphMinter.takeBackDepositorReward(\n            msg.sender,\n            depositEntry.mintMPHAmount,\n            early\n        );\n\n        // Update totalDeposit\n        totalDeposit = totalDeposit.sub(depositEntry.amount);\n\n        // Update totalInterestOwed\n        totalInterestOwed = totalInterestOwed.sub(depositEntry.interestOwed);\n\n        // Burn depositNFT\n        depositNFT.burn(depositID);\n\n        uint256 feeAmount;\n        uint256 withdrawAmount;\n        if (early) {\n            // Withdraw the principal of the deposit from money market\n            withdrawAmount = depositEntry.amount;\n        } else {\n            // Withdraw the principal & the interest from money market\n            feeAmount = feeModel.getFee(depositEntry.interestOwed);\n            withdrawAmount = depositEntry.amount.add(depositEntry.interestOwed);\n        }\n        withdrawAmount = moneyMarket.withdraw(withdrawAmount);\n\n        (bool depositIsNegative, uint256 depositSurplus) = surplusOfDeposit(\n            depositID\n        );\n\n        // If deposit was funded, payout interest to funder\n        if (depositIsFunded(depositID)) {\n            Funding storage f = _getFunding(fundingID);\n            require(\n                depositID > f.fromDepositID && depositID <= f.toDepositID,\n                \"DInterest: Deposit not funded by fundingID\"\n            );\n            uint256 currentMoneyMarketIncomeIndex = moneyMarket.incomeIndex();\n            require(\n                currentMoneyMarketIncomeIndex > 0,\n                \"DInterest: currentMoneyMarketIncomeIndex == 0\"\n            );\n            uint256 interestAmount = f\n                .recordedFundedDepositAmount\n                .mul(currentMoneyMarketIncomeIndex)\n                .div(f.recordedMoneyMarketIncomeIndex)\n                .sub(f.recordedFundedDepositAmount);\n\n            // Update funding values\n            f.recordedFundedDepositAmount = f.recordedFundedDepositAmount.sub(\n                depositEntry.amount\n            );\n            f.recordedMoneyMarketIncomeIndex = currentMoneyMarketIncomeIndex;\n\n            // Send interest to funder\n            uint256 transferToFunderAmount = (early && depositIsNegative)\n                ? interestAmount.add(depositSurplus)\n                : interestAmount;\n            if (transferToFunderAmount > 0) {\n                transferToFunderAmount = moneyMarket.withdraw(\n                    transferToFunderAmount\n                );\n                stablecoin.safeTransfer(\n                    fundingNFT.ownerOf(fundingID),\n                    transferToFunderAmount\n                );\n            }\n        } else {\n            // Remove deposit from future deficit fundings\n            unfundedUserDepositAmount = unfundedUserDepositAmount.sub(\n                depositEntry.amount\n            );\n\n            // Record remaining surplus\n            depositEntry.finalSurplusIsNegative = depositIsNegative;\n            depositEntry.finalSurplusAmount = depositSurplus;\n        }\n\n        // Send `withdrawAmount - feeAmount` stablecoin to `msg.sender`\n        stablecoin.safeTransfer(msg.sender, withdrawAmount.sub(feeAmount));\n\n        // Send `feeAmount` stablecoin to feeModel beneficiary\n        stablecoin.safeTransfer(feeModel.beneficiary(), feeAmount);\n\n        // Emit event\n        emit EWithdraw(\n            msg.sender,\n            depositID,\n            fundingID,\n            early,\n            takeBackMPHAmount\n        );\n    }\n\n    function _fund(uint256 totalDeficit) internal {\n        // Transfer `totalDeficit` stablecoins from msg.sender\n        stablecoin.safeTransferFrom(msg.sender, address(this), totalDeficit);\n\n        // Deposit `totalDeficit` stablecoins into moneyMarket\n        stablecoin.safeIncreaseAllowance(address(moneyMarket), totalDeficit);\n        moneyMarket.deposit(totalDeficit);\n\n        // Mint fundingNFT\n        fundingNFT.mint(msg.sender, fundingList.length);\n\n        // Mint MPH for msg.sender\n        uint256 mintMPHAmount = mphMinter.mintFunderReward(\n            msg.sender,\n            totalDeficit\n        );\n\n        // Emit event\n        uint256 fundingID = fundingList.length;\n        emit EFund(msg.sender, fundingID, totalDeficit, mintMPHAmount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\ncontract ReentrancyGuard {\n    bool private _notEntered;\n\n    constructor () internal {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/libs/DecMath.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n// Decimal math library\nlibrary DecMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n\n    function decmul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(b).div(PRECISION);\n    }\n\n    function decdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(PRECISION).div(b);\n    }\n}\n"
    },
    "contracts/moneymarkets/IMoneyMarket.sol": {
      "content": "pragma solidity 0.5.17;\n\n// Interface for money market protocols (Compound, Aave, bZx, etc.)\ninterface IMoneyMarket {\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        returns (uint256 actualAmountWithdrawn);\n\n    function claimRewards() external; // Claims farmed tokens (e.g. COMP, CRV) and sends it to the rewards pool\n\n    function totalValue() external returns (uint256); // The total value locked in the money market, in terms of the underlying stablecoin\n\n    function incomeIndex() external returns (uint256); // Used for calculating the interest generated (e.g. cDai's price for the Compound market)\n\n    function stablecoin() external view returns (address);\n\n    function setRewards(address newValue) external;\n\n    event ESetParamAddress(\n        address indexed sender,\n        string indexed paramName,\n        address newValue\n    );\n}\n"
    },
    "contracts/models/fee/IFeeModel.sol": {
      "content": "pragma solidity 0.5.17;\n\ninterface IFeeModel {\n    function beneficiary() external view returns (address payable);\n\n    function getFee(uint256 _txAmount)\n        external\n        pure\n        returns (uint256 _feeAmount);\n}\n"
    },
    "contracts/models/interest/IInterestModel.sol": {
      "content": "pragma solidity 0.5.17;\n\ninterface IInterestModel {\n    function calculateInterestAmount(\n        uint256 depositAmount,\n        uint256 depositPeriodInSeconds,\n        uint256 moneyMarketInterestRatePerSecond,\n        bool surplusIsNegative,\n        uint256 surplusAmount\n    ) external view returns (uint256 interestAmount);\n}\n"
    },
    "contracts/NFT.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\n\ncontract NFT is ERC721Metadata, Ownable {\n    string internal _contractURI;\n\n    constructor(string memory name, string memory symbol)\n        public\n        ERC721Metadata(name, symbol)\n    {}\n\n    function contractURI() external view returns (string memory) {\n        return _contractURI;\n    }\n\n    function mint(address to, uint256 tokenId) external onlyOwner {\n        _safeMint(to, tokenId);\n    }\n\n    function burn(uint256 tokenId) external onlyOwner {\n        _burn(tokenId);\n    }\n\n    function setContractURI(string calldata newURI) external onlyOwner {\n        _contractURI = newURI;\n    }\n\n    function setTokenURI(uint256 tokenId, string calldata newURI)\n        external\n        onlyOwner\n    {\n        _setTokenURI(tokenId, newURI);\n    }\n\n    function setBaseURI(string calldata newURI) external onlyOwner {\n        _setBaseURI(newURI);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721Metadata.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./ERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"../../introspection/ERC165.sol\";\n\ncontract ERC721Metadata is Context, ERC165, ERC721, IERC721Metadata {\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Base URI\n    string private _baseURI;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /**\n     * @dev Constructor function\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /**\n     * @dev Gets the token name.\n     * @return string representing the token name\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Gets the token symbol.\n     * @return string representing the token symbol\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the URI for a given token ID. May return an empty string.\n     *\n     * If the token's URI is non-empty and a base URI was set (via\n     * {_setBaseURI}), it will be added to the token ID's URI as a prefix.\n     *\n     * Reverts if the token ID does not exist.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n\n        // Even if there is a base URI, it is only appended to non-empty token-specific URIs\n        if (bytes(_tokenURI).length == 0) {\n            return \"\";\n        } else {\n            // abi.encodePacked is being used to concatenate strings\n            return string(abi.encodePacked(_baseURI, _tokenURI));\n        }\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token.\n     *\n     * Reverts if the token ID does not exist.\n     *\n     * TIP: if all token IDs share a prefix (e.g. if your URIs look like\n     * `http://api.myproject.com/token/<id>`), use {_setBaseURI} to store\n     * it and save gas.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI}.\n     *\n     * _Available since v2.5.0._\n     */\n    function _setBaseURI(string memory baseURI) internal {\n        _baseURI = baseURI;\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a preffix in {tokenURI} to each token's URI, when\n    * they are non-empty.\n    *\n    * _Available since v2.5.0._\n    */\n    function baseURI() external view returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../drafts/Counters.sol\";\nimport \"../../introspection/ERC165.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][to] = approved;\n        emit ApprovalForAll(_msgSender(), to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the _msgSender() to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\n        _transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This is an internal detail of the `ERC721` contract and its use is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ));\n        if (!success) {\n            if (returndata.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n            }\n        } else {\n            bytes4 retval = abi.decode(returndata, (bytes4));\n            return (retval == _ERC721_RECEIVED);\n        }\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC165.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/drafts/Counters.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../math/SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/ERC165.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/rewards/MPHMinter.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../libs/DecMath.sol\";\nimport \"./MPHToken.sol\";\n\ncontract MPHMinter is Ownable {\n    using Address for address;\n    using DecMath for uint256;\n    using SafeMath for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n\n    /**\n        @notice The multiplier applied to the interest generated by a pool when minting MPH\n     */\n    mapping(address => uint256) public poolMintingMultiplier;\n    /**\n        @notice The multiplier applied to the interest generated by a pool when letting depositors keep MPH\n     */\n    mapping(address => uint256) public poolDepositorRewardMultiplier;\n    /**\n        @notice The multiplier applied to the interest generated by a pool when letting deficit funders keep MPH\n     */\n    mapping(address => uint256) public poolFunderRewardMultiplier;\n    /**\n        @notice Multiplier used for calculating dev reward\n     */\n    uint256 public devRewardMultiplier;\n\n    event ESetParamAddress(\n        address indexed sender,\n        string indexed paramName,\n        address newValue\n    );\n    event ESetParamUint(\n        address indexed sender,\n        string indexed paramName,\n        uint256 newValue\n    );\n\n    /**\n        External contracts\n     */\n    MPHToken public mph;\n    address public govTreasury;\n    address public devWallet;\n\n    constructor(\n        address _mph,\n        address _govTreasury,\n        address _devWallet,\n        uint256 _devRewardMultiplier\n    ) public {\n        mph = MPHToken(_mph);\n        govTreasury = _govTreasury;\n        devWallet = _devWallet;\n        devRewardMultiplier = _devRewardMultiplier;\n    }\n\n    function mintDepositorReward(address to, uint256 interestAmount)\n        external\n        returns (uint256)\n    {\n        uint256 multiplier = poolMintingMultiplier[msg.sender];\n        uint256 mintAmount = interestAmount.decmul(multiplier);\n        if (mintAmount == 0) {\n            // sender is not a pool/has been deactivated\n            return 0;\n        }\n\n        mph.ownerMint(to, mintAmount);\n        mph.ownerMint(devWallet, mintAmount.decmul(devRewardMultiplier));\n        return mintAmount;\n    }\n\n    function mintFunderReward(address to, uint256 interestAmount)\n        external\n        returns (uint256)\n    {\n        uint256 multiplier = poolMintingMultiplier[msg.sender].decmul(\n            poolFunderRewardMultiplier[msg.sender]\n        );\n        uint256 mintAmount = interestAmount.decmul(multiplier);\n        if (mintAmount == 0) {\n            // sender is not a pool/has been deactivated\n            return 0;\n        }\n\n        mph.ownerMint(to, mintAmount);\n        mph.ownerMint(devWallet, mintAmount.decmul(devRewardMultiplier));\n        return mintAmount;\n    }\n\n    function takeBackDepositorReward(\n        address from,\n        uint256 mintMPHAmount,\n        bool early\n    ) external returns (uint256) {\n        uint256 takeBackAmount = early\n            ? mintMPHAmount\n            : mintMPHAmount.decmul(\n                PRECISION.sub(poolDepositorRewardMultiplier[msg.sender])\n            );\n        if (takeBackAmount == 0) {\n            // sender is not a pool/has been deactivated\n            return 0;\n        }\n\n        mph.ownerTransfer(from, govTreasury, takeBackAmount);\n        return takeBackAmount;\n    }\n\n    /**\n        Param setters\n     */\n    function setGovTreasury(address newValue) external onlyOwner {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        govTreasury = newValue;\n        emit ESetParamAddress(msg.sender, \"govTreasury\", newValue);\n    }\n\n    function setDevWallet(address newValue) external onlyOwner {\n        require(newValue != address(0), \"MPHMinter: 0 address\");\n        devWallet = newValue;\n        emit ESetParamAddress(msg.sender, \"devWallet\", newValue);\n    }\n\n    function setPoolMintingMultiplier(address pool, uint256 newMultiplier)\n        external\n        onlyOwner\n    {\n        require(pool.isContract(), \"MPHMinter: pool not contract\");\n        poolMintingMultiplier[pool] = newMultiplier;\n        emit ESetParamUint(msg.sender, \"poolMintingMultiplier\", newMultiplier);\n    }\n\n    function setPoolDepositorRewardMultiplier(\n        address pool,\n        uint256 newMultiplier\n    ) external onlyOwner {\n        require(pool.isContract(), \"MPHMinter: pool not contract\");\n        require(newMultiplier <= PRECISION, \"MPHMinter: invalid multiplier\");\n        poolDepositorRewardMultiplier[pool] = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"poolDepositorRewardMultiplier\",\n            newMultiplier\n        );\n    }\n\n    function setPoolFunderRewardMultiplier(address pool, uint256 newMultiplier)\n        external\n        onlyOwner\n    {\n        require(pool.isContract(), \"MPHMinter: pool not contract\");\n        poolFunderRewardMultiplier[pool] = newMultiplier;\n        emit ESetParamUint(\n            msg.sender,\n            \"poolFunderRewardMultiplier\",\n            newMultiplier\n        );\n    }\n}\n"
    },
    "contracts/rewards/MPHToken.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\n\ncontract MPHToken is ERC20, ERC20Detailed, Ownable {\n    constructor() public ERC20Detailed(\"88mph.app\", \"MPH\", 18) {}\n\n    function ownerMint(address account, uint256 amount)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        _mint(account, amount);\n        return true;\n    }\n\n    function ownerTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) public onlyOwner returns (bool) {\n        _transfer(from, to, amount);\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/models/interest-oracle/IInterestOracle.sol": {
      "content": "pragma solidity 0.5.17;\n\ninterface IInterestOracle {\n    function updateAndQuery() external returns (bool updated, uint256 value);\n\n    function query() external view returns (uint256 value);\n\n    function moneyMarket() external view returns (address);\n}\n"
    },
    "contracts/mocks/ATokenMock.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libs/DecMath.sol\";\n\ncontract ATokenMock is ERC20, ERC20Detailed {\n    using SafeMath for uint256;\n    using DecMath for uint256;\n\n    uint256 internal constant YEAR = 31556952; // Number of seconds in one Gregorian calendar year (365.2425 days)\n\n    ERC20 public dai;\n    uint256 public liquidityRate;\n    uint256 public normalizedIncome;\n    address[] public users;\n    mapping(address => bool) public isUser;\n\n    constructor(address _dai)\n        public\n        ERC20Detailed(\"aDAI\", \"aDAI\", 18)\n    {\n        dai = ERC20(_dai);\n\n        liquidityRate = 10 ** 26; // 10% APY\n        normalizedIncome = 10 ** 27;\n    }\n\n    function redeem(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n        dai.transfer(msg.sender, _amount);\n    }\n\n    function mint(address _user, uint256 _amount) external {\n        _mint(_user, _amount);\n        if (!isUser[_user]) {\n            users.push(_user);\n            isUser[_user] = true;\n        }\n    }\n\n    function mintInterest(uint256 _seconds) external {\n        uint256 interest;\n        address user;\n        for (uint256 i = 0; i < users.length; i++) {\n            user = users[i];\n            interest = balanceOf(user).mul(_seconds).mul(liquidityRate).div(YEAR.mul(10**27));\n            _mint(user, interest);\n        }\n        normalizedIncome = normalizedIncome.mul(_seconds).mul(liquidityRate).div(YEAR.mul(10**27)).add(normalizedIncome);\n    }\n\n    function setLiquidityRate(uint256 _liquidityRate) external {\n        liquidityRate = _liquidityRate;\n    }\n}"
    },
    "contracts/mocks/CERC20Mock.sol": {
      "content": "/**\n    Modified from https://github.com/bugduino/idle-contracts/blob/master/contracts/mocks/cDAIMock.sol\n    at commit b85dafa8e55e053cb2d403fc4b28cfe86f2116d4\n\n    Original license:\n    Copyright 2020 Idle Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n */\n\npragma solidity 0.5.17;\n\n// interfaces\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\n\n\ncontract CERC20Mock is ERC20, ERC20Detailed {\n    address public dai;\n\n    uint256 internal _supplyRate;\n    uint256 internal _exchangeRate;\n\n    constructor(address _dai) public ERC20Detailed(\"cDAI\", \"cDAI\", 8) {\n        dai = _dai;\n        uint256 daiDecimals = ERC20Detailed(_dai).decimals();\n        _exchangeRate = 2 * (10**(daiDecimals + 8)); // 1 cDAI = 0.02 DAI\n        _supplyRate = 45290900000; // 10% supply rate per year\n    }\n\n    function mint(uint256 amount) external returns (uint256) {\n        require(\n            ERC20(dai).transferFrom(msg.sender, address(this), amount),\n            \"Error during transferFrom\"\n        ); // 1 DAI\n        _mint(msg.sender, (amount * 10**18) / _exchangeRate);\n        return 0;\n    }\n\n    function redeemUnderlying(uint256 amount) external returns (uint256) {\n        _burn(msg.sender, (amount * 10**18) / _exchangeRate);\n        require(\n            ERC20(dai).transfer(msg.sender, amount),\n            \"Error during transfer\"\n        ); // 1 DAI\n        return 0;\n    }\n\n    function exchangeRateStored() external view returns (uint256) {\n        return _exchangeRate;\n    }\n\n    function exchangeRateCurrent() external view returns (uint256) {\n        return _exchangeRate;\n    }\n\n    function _setExchangeRateStored(uint256 _rate) external returns (uint256) {\n        _exchangeRate = _rate;\n    }\n\n    function supplyRatePerBlock() external view returns (uint256) {\n        return _supplyRate;\n    }\n\n    function _setSupplyRatePerBlock(uint256 _rate) external {\n        _supplyRate = _rate;\n    }\n}\n"
    },
    "contracts/mocks/ComptrollerMock.sol": {
      "content": "pragma solidity 0.5.17;\n\n// interfaces\nimport \"./ERC20Mock.sol\";\n\ncontract ComptrollerMock {\n    uint256 public constant CLAIM_AMOUNT = 10**18;\n    ERC20Mock public comp;\n\n    constructor (address _comp) public {\n        comp = ERC20Mock(_comp);\n    }\n\n    function claimComp(address holder) external {\n        comp.mint(holder, CLAIM_AMOUNT);\n    }\n\n    function getCompAddress() external view returns (address) {\n        return address(comp);\n    }\n}"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\n\ncontract ERC20Mock is ERC20, ERC20Detailed(\"\", \"\", 6) {\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n}"
    },
    "contracts/mocks/LendingPoolAddressesProviderMock.sol": {
      "content": "pragma solidity 0.5.17;\n\ncontract LendingPoolAddressesProviderMock {\n    address internal pool;\n    address internal core;\n\n    function getLendingPool() external view returns (address) {\n        return pool;\n    }\n\n    function setLendingPoolImpl(address _pool) external {\n        pool = _pool;\n    }\n\n    function getLendingPoolCore() external view returns (address) {\n        return core;\n    }\n\n    function setLendingPoolCoreImpl(address _pool) external {\n        core = _pool;\n    }\n}"
    },
    "contracts/mocks/LendingPoolCoreMock.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./ATokenMock.sol\";\nimport \"./LendingPoolMock.sol\";\n\ncontract LendingPoolCoreMock {\n    LendingPoolMock internal lendingPool;\n\n    function setLendingPool(address lendingPoolAddress) public {\n        lendingPool = LendingPoolMock(lendingPoolAddress);\n    }\n\n    function bounceTransfer(address _reserve, address _sender, uint256 _amount)\n        external\n    {\n        ERC20 token = ERC20(_reserve);\n        token.transferFrom(_sender, address(this), _amount);\n\n        token.transfer(msg.sender, _amount);\n    }\n\n    // The equivalent of exchangeRateStored() for Compound cTokens\n    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\n        (, , , , , , , , , , , address aTokenAddress, ) = lendingPool\n            .getReserveData(_reserve);\n        ATokenMock aToken = ATokenMock(aTokenAddress);\n        return aToken.normalizedIncome();\n    }\n}\n"
    },
    "contracts/mocks/LendingPoolMock.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./ATokenMock.sol\";\nimport \"./LendingPoolCoreMock.sol\";\n\ncontract LendingPoolMock {\n    mapping(address => address) internal reserveAToken;\n    LendingPoolCoreMock public core;\n\n    constructor(address _core) public {\n        core = LendingPoolCoreMock(_core);\n    }\n\n    function setReserveAToken(address _reserve, address _aTokenAddress) external {\n        reserveAToken[_reserve] = _aTokenAddress;\n    }\n\n    function deposit(address _reserve, uint256 _amount, uint16)\n        external\n    {\n        ERC20 token = ERC20(_reserve);\n        core.bounceTransfer(_reserve, msg.sender, _amount);\n\n        // Mint aTokens\n        address aTokenAddress = reserveAToken[_reserve];\n        ATokenMock aToken = ATokenMock(aTokenAddress);\n        aToken.mint(msg.sender, _amount);\n        token.transfer(aTokenAddress, _amount);\n    }\n\n    function getReserveData(address _reserve)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256 liquidityRate,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            address aTokenAddress,\n            uint40\n        )\n    {\n        aTokenAddress = reserveAToken[_reserve];\n        ATokenMock aToken = ATokenMock(aTokenAddress);\n        liquidityRate = aToken.liquidityRate();\n    }\n}\n"
    },
    "contracts/mocks/VaultMock.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libs/DecMath.sol\";\n\ncontract VaultMock is ERC20, ERC20Detailed {\n    using SafeMath for uint256;\n    using DecMath for uint256;\n\n    ERC20 public underlying;\n\n    constructor(address _underlying) public ERC20Detailed(\"yUSD\", \"yUSD\", 18) {\n        underlying = ERC20(_underlying);\n    }\n\n    function deposit(uint256 tokenAmount) public {\n        uint256 sharePrice = getPricePerFullShare();\n        _mint(msg.sender, tokenAmount.decdiv(sharePrice));\n\n        underlying.transferFrom(msg.sender, address(this), tokenAmount);\n    }\n\n    function withdraw(uint256 sharesAmount) public {\n        uint256 sharePrice = getPricePerFullShare();\n        uint256 underlyingAmount = sharesAmount.decmul(sharePrice);\n        _burn(msg.sender, sharesAmount);\n\n        underlying.transfer(msg.sender, underlyingAmount);\n    }\n\n    function getPricePerFullShare() public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            return 10**18;\n        }\n        return underlying.balanceOf(address(this)).decdiv(_totalSupply);\n    }\n}\n"
    },
    "contracts/models/fee/PercentageFeeModel.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./IFeeModel.sol\";\n\ncontract PercentageFeeModel is IFeeModel {\n    using SafeMath for uint256;\n\n    address payable public beneficiary;\n\n    constructor(address payable _beneficiary) public {\n        beneficiary = _beneficiary;\n    }\n\n    function getFee(uint256 _txAmount)\n        external\n        pure\n        returns (uint256 _feeAmount)\n    {\n        _feeAmount = _txAmount.div(10); // Precision is decreased by 1 decimal place\n    }\n}\n"
    },
    "contracts/models/interest-oracle/EMAOracle.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../moneymarkets/IMoneyMarket.sol\";\nimport \"../../libs/DecMath.sol\";\nimport \"./IInterestOracle.sol\";\n\ncontract EMAOracle is IInterestOracle {\n    using SafeMath for uint256;\n    using DecMath for uint256;\n\n    uint256 internal constant PRECISION = 10**18;\n\n    /**\n        Immutable parameters\n     */\n    uint256 public UPDATE_INTERVAL;\n    uint256 public UPDATE_MULTIPLIER;\n    uint256 public ONE_MINUS_UPDATE_MULTIPLIER;\n\n    /**\n        Public variables\n     */\n    uint256 public emaStored;\n    uint256 public lastIncomeIndex;\n    uint256 public lastUpdateTimestamp;\n\n    /**\n        External contracts\n     */\n    IMoneyMarket public moneyMarket;\n\n    constructor(\n        uint256 _emaInitial,\n        uint256 _updateInterval,\n        uint256 _smoothingFactor,\n        uint256 _averageWindowInIntervals,\n        address _moneyMarket\n    ) public {\n        emaStored = _emaInitial;\n        UPDATE_INTERVAL = _updateInterval;\n        lastUpdateTimestamp = now;\n\n        uint256 updateMultiplier = _smoothingFactor.div(_averageWindowInIntervals.add(1));\n        UPDATE_MULTIPLIER = updateMultiplier;\n        ONE_MINUS_UPDATE_MULTIPLIER = PRECISION.sub(updateMultiplier);\n\n        moneyMarket = IMoneyMarket(_moneyMarket);\n        lastIncomeIndex = moneyMarket.incomeIndex();\n    }\n\n    function updateAndQuery() public returns (bool updated, uint256 value) {\n        uint256 timeElapsed = now - lastUpdateTimestamp;\n        if (timeElapsed < UPDATE_INTERVAL) {\n            return (false, emaStored);\n        }\n\n        // save gas by loading storage variables to memory\n        uint256 _lastIncomeIndex = lastIncomeIndex;\n        uint256 _emaStored = emaStored;\n\n        uint256 newIncomeIndex = moneyMarket.incomeIndex();\n        uint256 incomingValue = newIncomeIndex.sub(_lastIncomeIndex).decdiv(_lastIncomeIndex).div(timeElapsed);\n\n        updated = true;\n        value = incomingValue.mul(UPDATE_MULTIPLIER).add(_emaStored.mul(ONE_MINUS_UPDATE_MULTIPLIER)).div(PRECISION);\n        emaStored = value;\n        lastIncomeIndex = newIncomeIndex;\n        lastUpdateTimestamp = now;\n    }\n\n    function query() public view returns (uint256 value) {\n        return emaStored;\n    }\n}\n"
    },
    "contracts/models/interest/LinearInterestModel.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../libs/DecMath.sol\";\n\ncontract LinearInterestModel {\n    using SafeMath for uint256;\n    using DecMath for uint256;\n\n    uint256 public constant PRECISION = 10**18;\n    uint256 public IRMultiplier;\n\n    constructor(uint256 _IRMultiplier) public {\n        IRMultiplier = _IRMultiplier;\n    }\n\n    function calculateInterestAmount(\n        uint256 depositAmount,\n        uint256 depositPeriodInSeconds,\n        uint256 moneyMarketInterestRatePerSecond,\n        bool, /*surplusIsNegative*/\n        uint256 /*surplusAmount*/\n    ) external view returns (uint256 interestAmount) {\n        // interestAmount = depositAmount * moneyMarketInterestRatePerSecond * IRMultiplier * depositPeriodInSeconds\n        interestAmount = depositAmount\n            .mul(PRECISION)\n            .decmul(moneyMarketInterestRatePerSecond)\n            .decmul(IRMultiplier)\n            .mul(depositPeriodInSeconds)\n            .div(PRECISION);\n    }\n}\n"
    },
    "contracts/moneymarkets/aave/AaveMarket.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../IMoneyMarket.sol\";\nimport \"./imports/IAToken.sol\";\nimport \"./imports/ILendingPool.sol\";\nimport \"./imports/ILendingPoolAddressesProvider.sol\";\nimport \"./imports/ILendingPoolCore.sol\";\n\ncontract AaveMarket is IMoneyMarket, Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    uint16 internal constant REFERRALCODE = 20; // Aave referral program code\n\n    ILendingPoolAddressesProvider public provider; // Used for fetching the current address of LendingPool\n    ERC20 public stablecoin;\n\n    constructor(address _provider, address _stablecoin) public {\n        // Verify input addresses\n        require(\n            _provider != address(0) && _stablecoin != address(0),\n            \"AaveMarket: An input address is 0\"\n        );\n        require(\n            _provider.isContract() && _stablecoin.isContract(),\n            \"AaveMarket: An input address is not a contract\"\n        );\n\n        provider = ILendingPoolAddressesProvider(_provider);\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external onlyOwner {\n        require(amount > 0, \"AaveMarket: amount is 0\");\n\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n        address lendingPoolCore = provider.getLendingPoolCore();\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve `amount` stablecoin to lendingPool\n        stablecoin.safeIncreaseAllowance(lendingPoolCore, amount);\n\n        // Deposit `amount` stablecoin to lendingPool\n        lendingPool.deposit(address(stablecoin), amount, REFERRALCODE);\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(amountInUnderlying > 0, \"AaveMarket: amountInUnderlying is 0\");\n\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n\n        // Initialize aToken\n        (, , , , , , , , , , , address aTokenAddress, ) = lendingPool\n            .getReserveData(address(stablecoin));\n        IAToken aToken = IAToken(aTokenAddress);\n\n        // Redeem `amountInUnderlying` aToken, since 1 aToken = 1 stablecoin\n        aToken.redeem(amountInUnderlying);\n\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\n        stablecoin.safeTransfer(msg.sender, amountInUnderlying);\n\n        return amountInUnderlying;\n    }\n\n    function claimRewards() external {}\n\n    function totalValue() external returns (uint256) {\n        ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n\n        // Initialize aToken\n        (, , , , , , , , , , , address aTokenAddress, ) = lendingPool\n            .getReserveData(address(stablecoin));\n        IAToken aToken = IAToken(aTokenAddress);\n\n        return aToken.balanceOf(address(this));\n    }\n\n    function incomeIndex() external returns (uint256) {\n        ILendingPoolCore lendingPoolCore = ILendingPoolCore(\n            provider.getLendingPoolCore()\n        );\n        return lendingPoolCore.getReserveNormalizedIncome(address(stablecoin));\n    }\n\n    function setRewards(address newValue) external {}\n}\n"
    },
    "contracts/moneymarkets/aave/imports/IAToken.sol": {
      "content": "pragma solidity 0.5.17;\n\n\n// Aave aToken interface\n// Documentation: https://docs.aave.com/developers/developing-on-aave/the-protocol/atokens\ninterface IAToken {\n    function redeem(uint256 _amount) external;\n\n    function balanceOf(address owner) external view returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/aave/imports/ILendingPool.sol": {
      "content": "pragma solidity 0.5.17;\n\n\n// Aave lending pool interface\n// Documentation: https://docs.aave.com/developers/developing-on-aave/the-protocol/lendingpool\ninterface ILendingPool {\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode)\n        external;\n\n    function getReserveData(address _reserve)\n        external\n        view\n        returns (\n            uint256 totalLiquidity,\n            uint256 availableLiquidity,\n            uint256 totalBorrowsStable,\n            uint256 totalBorrowsVariable,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 utilizationRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            address aTokenAddress,\n            uint40 lastUpdateTimestamp\n        );\n}\n"
    },
    "contracts/moneymarkets/aave/imports/ILendingPoolAddressesProvider.sol": {
      "content": "pragma solidity 0.5.17;\n\n\n// Aave lending pool addresses provider interface\n// Documentation: https://docs.aave.com/developers/developing-on-aave/the-protocol/lendingpooladdressesprovider\ninterface ILendingPoolAddressesProvider {\n    function getLendingPool() external view returns (address);\n\n    function setLendingPoolImpl(address _pool) external;\n\n    function getLendingPoolCore() external view returns (address payable);\n\n    function setLendingPoolCoreImpl(address _lendingPoolCore) external;\n\n    function getLendingPoolConfigurator() external view returns (address);\n\n    function setLendingPoolConfiguratorImpl(address _configurator) external;\n\n    function getLendingPoolDataProvider() external view returns (address);\n\n    function setLendingPoolDataProviderImpl(address _provider) external;\n\n    function getLendingPoolParametersProvider() external view returns (address);\n\n    function setLendingPoolParametersProviderImpl(address _parametersProvider)\n        external;\n\n    function getTokenDistributor() external view returns (address);\n\n    function setTokenDistributor(address _tokenDistributor) external;\n\n    function getFeeProvider() external view returns (address);\n\n    function setFeeProviderImpl(address _feeProvider) external;\n\n    function getLendingPoolLiquidationManager() external view returns (address);\n\n    function setLendingPoolLiquidationManager(address _manager) external;\n\n    function getLendingPoolManager() external view returns (address);\n\n    function setLendingPoolManager(address _lendingPoolManager) external;\n\n    function getPriceOracle() external view returns (address);\n\n    function setPriceOracle(address _priceOracle) external;\n\n    function getLendingRateOracle() external view returns (address);\n\n    function setLendingRateOracle(address _lendingRateOracle) external;\n}\n"
    },
    "contracts/moneymarkets/aave/imports/ILendingPoolCore.sol": {
      "content": "pragma solidity 0.5.17;\n\n\n// Aave lending pool core interface\n// Documentation: https://github.com/aave/aave-protocol/blob/master/contracts/lendingpool/LendingPoolCore.sol#L615\ninterface ILendingPoolCore {\n    // The equivalent of exchangeRateStored() for Compound cTokens\n    function getReserveNormalizedIncome(address _reserve)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/compound/CompoundERC20Market.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../IMoneyMarket.sol\";\nimport \"../../libs/DecMath.sol\";\nimport \"./imports/ICERC20.sol\";\nimport \"./imports/IComptroller.sol\";\n\ncontract CompoundERC20Market is IMoneyMarket, Ownable {\n    using DecMath for uint256;\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    uint256 internal constant ERRCODE_OK = 0;\n\n    ICERC20 public cToken;\n    IComptroller public comptroller;\n    address public rewards;\n    ERC20 public stablecoin;\n\n    constructor(\n        address _cToken,\n        address _comptroller,\n        address _rewards,\n        address _stablecoin\n    ) public {\n        // Verify input addresses\n        require(\n            _cToken != address(0) &&\n                _comptroller != address(0) &&\n                _rewards != address(0) &&\n                _stablecoin != address(0),\n            \"CompoundERC20Market: An input address is 0\"\n        );\n        require(\n            _cToken.isContract() &&\n                _comptroller.isContract() &&\n                _rewards.isContract() &&\n                _stablecoin.isContract(),\n            \"CompoundERC20Market: An input address is not a contract\"\n        );\n\n        cToken = ICERC20(_cToken);\n        comptroller = IComptroller(_comptroller);\n        rewards = _rewards;\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external onlyOwner {\n        require(amount > 0, \"CompoundERC20Market: amount is 0\");\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Deposit `amount` stablecoin into cToken\n        stablecoin.safeIncreaseAllowance(address(cToken), amount);\n        require(\n            cToken.mint(amount) == ERRCODE_OK,\n            \"CompoundERC20Market: Failed to mint cTokens\"\n        );\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(\n            amountInUnderlying > 0,\n            \"CompoundERC20Market: amountInUnderlying is 0\"\n        );\n\n        // Withdraw `amountInUnderlying` stablecoin from cToken\n        require(\n            cToken.redeemUnderlying(amountInUnderlying) == ERRCODE_OK,\n            \"CompoundERC20Market: Failed to redeem\"\n        );\n\n        // Transfer `amountInUnderlying` stablecoin to `msg.sender`\n        stablecoin.safeTransfer(msg.sender, amountInUnderlying);\n\n        return amountInUnderlying;\n    }\n\n    function claimRewards() external {\n        comptroller.claimComp(address(this));\n        ERC20 comp = ERC20(comptroller.getCompAddress());\n        comp.safeTransfer(rewards, comp.balanceOf(address(this)));\n    }\n\n    function totalValue() external returns (uint256) {\n        uint256 cTokenBalance = cToken.balanceOf(address(this));\n        // Amount of stablecoin units that 1 unit of cToken can be exchanged for, scaled by 10^18\n        uint256 cTokenPrice = cToken.exchangeRateCurrent();\n        return cTokenBalance.decmul(cTokenPrice);\n    }\n\n    function incomeIndex() external returns (uint256) {\n        return cToken.exchangeRateCurrent();\n    }\n\n    /**\n        Param setters\n     */\n    function setRewards(address newValue) external onlyOwner {\n        require(newValue.isContract(), \"CompoundERC20Market: not contract\");\n        rewards = newValue;\n        emit ESetParamAddress(msg.sender, \"rewards\", newValue);\n    }\n}\n"
    },
    "contracts/moneymarkets/compound/imports/ICERC20.sol": {
      "content": "pragma solidity 0.5.17;\n\n\n// Compound finance ERC20 market interface\n// Documentation: https://compound.finance/docs/ctokens\ninterface ICERC20 {\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    function transferFrom(address src, address dst, uint256 amount)\n        external\n        returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (uint256, uint256, uint256, uint256);\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account)\n        external\n        view\n        returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    function accrueInterest() external returns (uint256);\n\n    function seize(address liquidator, address borrower, uint256 seizeTokens)\n        external\n        returns (uint256);\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\n        external\n        returns (uint256);\n\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        address cTokenCollateral\n    ) external returns (uint256);\n}\n"
    },
    "contracts/moneymarkets/compound/imports/IComptroller.sol": {
      "content": "pragma solidity 0.5.17;\n\n\n// Compound finance Comptroller interface\n// Documentation: https://compound.finance/docs/comptroller\ninterface IComptroller {\n    function claimComp(address holder) external;\n    function getCompAddress() external view returns (address);\n}"
    },
    "contracts/moneymarkets/yvault/imports/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.17;\n\ninterface Vault {\n    function deposit(uint256) external;\n\n    function withdraw(uint256) external;\n\n    function getPricePerFullShare() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/moneymarkets/yvault/YVaultMarket.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../IMoneyMarket.sol\";\nimport \"../../libs/DecMath.sol\";\nimport \"./imports/Vault.sol\";\n\ncontract YVaultMarket is IMoneyMarket, Ownable {\n    using SafeMath for uint256;\n    using DecMath for uint256;\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    Vault public vault;\n    ERC20 public stablecoin;\n\n    constructor(address _vault, address _stablecoin) public {\n        // Verify input addresses\n        require(\n            _vault != address(0) && _stablecoin != address(0),\n            \"YVaultMarket: An input address is 0\"\n        );\n        require(\n            _vault.isContract() && _stablecoin.isContract(),\n            \"YVaultMarket: An input address is not a contract\"\n        );\n\n        vault = Vault(_vault);\n        stablecoin = ERC20(_stablecoin);\n    }\n\n    function deposit(uint256 amount) external onlyOwner {\n        require(amount > 0, \"YVaultMarket: amount is 0\");\n\n        // Transfer `amount` stablecoin from `msg.sender`\n        stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve `amount` stablecoin to vault\n        stablecoin.safeIncreaseAllowance(address(vault), amount);\n\n        // Deposit `amount` stablecoin to vault\n        vault.deposit(amount);\n    }\n\n    function withdraw(uint256 amountInUnderlying)\n        external\n        onlyOwner\n        returns (uint256 actualAmountWithdrawn)\n    {\n        require(\n            amountInUnderlying > 0,\n            \"YVaultMarket: amountInUnderlying is 0\"\n        );\n\n        // Withdraw `amountInShares` shares from vault\n        uint256 sharePrice = vault.getPricePerFullShare();\n        uint256 amountInShares = amountInUnderlying.decdiv(sharePrice);\n        vault.withdraw(amountInShares);\n\n        // Transfer stablecoin to `msg.sender`\n        actualAmountWithdrawn = stablecoin.balanceOf(address(this));\n        stablecoin.safeTransfer(msg.sender, actualAmountWithdrawn);\n    }\n\n    function claimRewards() external {}\n\n    function totalValue() external returns (uint256) {\n        uint256 sharePrice = vault.getPricePerFullShare();\n        uint256 shareBalance = vault.balanceOf(address(this));\n        return shareBalance.decmul(sharePrice);\n    }\n\n    function incomeIndex() external returns (uint256) {\n        return vault.getPricePerFullShare();\n    }\n\n    function setRewards(address newValue) external {}\n}\n"
    },
    "contracts/rewards/dumpers/Dumper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.5.17;\n\nimport \"./OneSplitDumper.sol\";\nimport \"./withdrawers/CurveLPWithdrawer.sol\";\nimport \"./withdrawers/YearnWithdrawer.sol\";\n\ncontract Dumper is OneSplitDumper, CurveLPWithdrawer, YearnWithdrawer {\n    constructor(\n        address _oneSplit,\n        address _rewards,\n        address _rewardToken\n    ) public OneSplitDumper(_oneSplit, _rewards, _rewardToken) {}\n}\n"
    },
    "contracts/rewards/dumpers/OneSplitDumper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/access/roles/SignerRole.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./imports/OneSplitAudit.sol\";\nimport \"../IRewards.sol\";\n\ncontract OneSplitDumper is SignerRole {\n    using SafeERC20 for IERC20;\n\n    OneSplitAudit public oneSplit;\n    IRewards public rewards;\n    IERC20 public rewardToken;\n\n    constructor(\n        address _oneSplit,\n        address _rewards,\n        address _rewardToken\n    ) public {\n        oneSplit = OneSplitAudit(_oneSplit);\n        rewards = IRewards(_rewards);\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    function getDumpParams(address tokenAddress, uint256 parts)\n        external\n        view\n        returns (uint256 returnAmount, uint256[] memory distribution)\n    {\n        IERC20 token = IERC20(tokenAddress);\n        uint256 tokenBalance = token.balanceOf(address(this));\n        (returnAmount, distribution) = oneSplit.getExpectedReturn(\n            tokenAddress,\n            address(rewardToken),\n            tokenBalance,\n            parts,\n            0\n        );\n    }\n\n    function dump(\n        address tokenAddress,\n        uint256 returnAmount,\n        uint256[] calldata distribution\n    ) external onlySigner {\n        // dump token for rewardToken\n        IERC20 token = IERC20(tokenAddress);\n        uint256 tokenBalance = token.balanceOf(address(this));\n        token.safeIncreaseAllowance(address(oneSplit), tokenBalance);\n\n        uint256 receivedRewardTokenAmount = oneSplit.swap(\n            tokenAddress,\n            address(rewardToken),\n            tokenBalance,\n            returnAmount,\n            distribution,\n            0\n        );\n        require(\n            receivedRewardTokenAmount > 0,\n            \"OneSplitDumper: receivedRewardTokenAmount == 0\"\n        );\n    }\n\n    function notify() external onlySigner {\n        uint256 balance = rewardToken.balanceOf(address(this));\n        rewardToken.safeTransfer(address(rewards), balance);\n        rewards.notifyRewardAmount(balance);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/roles/SignerRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"../Roles.sol\";\n\ncontract SignerRole is Context {\n    using Roles for Roles.Role;\n\n    event SignerAdded(address indexed account);\n    event SignerRemoved(address indexed account);\n\n    Roles.Role private _signers;\n\n    constructor () internal {\n        _addSigner(_msgSender());\n    }\n\n    modifier onlySigner() {\n        require(isSigner(_msgSender()), \"SignerRole: caller does not have the Signer role\");\n        _;\n    }\n\n    function isSigner(address account) public view returns (bool) {\n        return _signers.has(account);\n    }\n\n    function addSigner(address account) public onlySigner {\n        _addSigner(account);\n    }\n\n    function renounceSigner() public {\n        _removeSigner(_msgSender());\n    }\n\n    function _addSigner(address account) internal {\n        _signers.add(account);\n        emit SignerAdded(account);\n    }\n\n    function _removeSigner(address account) internal {\n        _signers.remove(account);\n        emit SignerRemoved(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Roles.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "contracts/rewards/dumpers/imports/OneSplitAudit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.17;\n\ninterface OneSplitAudit {\n    function swap(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata distribution,\n        uint256 flags\n    ) external payable returns (uint256 returnAmount);\n\n    function getExpectedReturn(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 parts,\n        uint256 flags // See constants in IOneSplit.sol\n    )\n        external\n        view\n        returns (uint256 returnAmount, uint256[] memory distribution);\n}\n"
    },
    "contracts/rewards/IRewards.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.5.17;\n\ninterface IRewards {\n    function notifyRewardAmount(uint256 reward) external;\n}\n"
    },
    "contracts/rewards/dumpers/withdrawers/CurveLPWithdrawer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/access/roles/SignerRole.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../imports/Curve.sol\";\nimport \"../../IRewards.sol\";\n\ncontract CurveLPWithdrawer is SignerRole {\n    function curveWithdraw2(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        uint256[2] calldata minAmounts\n    ) external onlySigner {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        ICurveFi curvePool = ICurveFi(curvePoolAddress);\n        curvePool.remove_liquidity(lpTokenBalance, minAmounts);\n    }\n\n    function curveWithdraw3(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        uint256[3] calldata minAmounts\n    ) external onlySigner {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        ICurveFi curvePool = ICurveFi(curvePoolAddress);\n        curvePool.remove_liquidity(lpTokenBalance, minAmounts);\n    }\n\n    function curveWithdraw4(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        uint256[4] calldata minAmounts\n    ) external onlySigner {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        ICurveFi curvePool = ICurveFi(curvePoolAddress);\n        curvePool.remove_liquidity(lpTokenBalance, minAmounts);\n    }\n\n    function curveWithdraw5(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        uint256[5] calldata minAmounts\n    ) external onlySigner {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        ICurveFi curvePool = ICurveFi(curvePoolAddress);\n        curvePool.remove_liquidity(lpTokenBalance, minAmounts);\n    }\n\n    function curveWithdrawOneCoin(\n        address lpTokenAddress,\n        address curvePoolAddress,\n        int128 coinIndex,\n        uint256 minAmount\n    ) external onlySigner {\n        IERC20 lpToken = IERC20(lpTokenAddress);\n        uint256 lpTokenBalance = lpToken.balanceOf(address(this));\n        Zap curvePool = Zap(curvePoolAddress);\n        curvePool.remove_liquidity_one_coin(\n            lpTokenBalance,\n            coinIndex,\n            minAmount\n        );\n    }\n}\n"
    },
    "contracts/rewards/dumpers/imports/Curve.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.17;\n\ninterface ICurveFi {\n    function remove_liquidity_imbalance(\n        uint256[2] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity_imbalance(\n        uint256[3] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity_imbalance(\n        uint256[4] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity_imbalance(\n        uint256[5] calldata amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function remove_liquidity(uint256 _amount, uint256[2] calldata amounts)\n        external;\n\n    function remove_liquidity(uint256 _amount, uint256[3] calldata amounts)\n        external;\n\n    function remove_liquidity(uint256 _amount, uint256[4] calldata amounts)\n        external;\n\n    function remove_liquidity(uint256 _amount, uint256[5] calldata amounts)\n        external;\n}\n\ninterface Zap {\n    function remove_liquidity_one_coin(\n        uint256,\n        int128,\n        uint256\n    ) external;\n}\n"
    },
    "contracts/rewards/dumpers/withdrawers/YearnWithdrawer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/access/roles/SignerRole.sol\";\nimport \"../imports/yERC20.sol\";\n\ncontract YearnWithdrawer is SignerRole {\n    function yearnWithdraw(address yTokenAddress) external onlySigner {\n        yERC20 yToken = yERC20(yTokenAddress);\n        uint256 balance = yToken.balanceOf(address(this));\n        yToken.withdraw(balance);\n    }\n}\n"
    },
    "contracts/rewards/dumpers/imports/yERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.17;\n\n// NOTE: Basically an alias for Vaults\ninterface yERC20 {\n    function balanceOf(address owner) external view returns (uint256);\n\n    function deposit(uint256 _amount) external;\n\n    function withdraw(uint256 _amount) external;\n\n    function getPricePerFullShare() external view returns (uint256);\n}\n"
    },
    "contracts/rewards/Rewards.sol": {
      "content": "/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n* Synthetix: Rewards.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\npragma solidity 0.5.17;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract IRewardDistributionRecipient is Ownable {\n    mapping(address => bool) public isRewardDistribution;\n\n    function notifyRewardAmount(uint256 reward) external;\n\n    modifier onlyRewardDistribution() {\n        require(\n            isRewardDistribution[_msgSender()],\n            \"Caller is not reward distribution\"\n        );\n        _;\n    }\n\n    function setRewardDistribution(\n        address _rewardDistribution,\n        bool _isRewardDistribution\n    ) external onlyOwner {\n        isRewardDistribution[_rewardDistribution] = _isRewardDistribution;\n    }\n}\n\ncontract LPTokenWrapper {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public stakeToken;\n\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) private _balances;\n\n    constructor(address _stakeToken) public {\n        stakeToken = IERC20(_stakeToken);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakeToken.safeTransfer(msg.sender, amount);\n    }\n}\n\ncontract Rewards is LPTokenWrapper, IRewardDistributionRecipient {\n    IERC20 public rewardToken;\n    uint256 public constant DURATION = 7 days;\n\n    uint256 public starttime;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    modifier checkStart {\n        require(block.timestamp >= starttime, \"Rewards: not start\");\n        _;\n    }\n\n    constructor(\n        address _stakeToken,\n        address _rewardToken,\n        uint256 _starttime\n    ) public LPTokenWrapper(_stakeToken) {\n        rewardToken = IERC20(_rewardToken);\n        starttime = _starttime;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    function stake(uint256 amount) public updateReward(msg.sender) checkStart {\n        require(amount > 0, \"Rewards: cannot stake 0\");\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        updateReward(msg.sender)\n        checkStart\n    {\n        require(amount > 0, \"Rewards: cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender) checkStart {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        onlyRewardDistribution\n        updateReward(address(0))\n    {\n        // https://sips.synthetix.io/sips/sip-77\n        require(reward > 0, \"Rewards: reward == 0\");\n        require(\n            reward < uint256(-1) / 10**18,\n            \"Rewards: rewards too large, would lock\"\n        );\n        if (block.timestamp > starttime) {\n            if (block.timestamp >= periodFinish) {\n                rewardRate = reward.div(DURATION);\n            } else {\n                uint256 remaining = periodFinish.sub(block.timestamp);\n                uint256 leftover = remaining.mul(rewardRate);\n                rewardRate = reward.add(leftover).div(DURATION);\n            }\n            lastUpdateTime = block.timestamp;\n            periodFinish = block.timestamp.add(DURATION);\n            emit RewardAdded(reward);\n        } else {\n            rewardRate = reward.div(DURATION);\n            lastUpdateTime = starttime;\n            periodFinish = starttime.add(DURATION);\n            emit RewardAdded(reward);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}