{{
  "language": "Solidity",
  "sources": {
    "solidity/contracts/deposit/DepositRedemption.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {BTCUtils} from \"@summa-tx/bitcoin-spv-sol/contracts/BTCUtils.sol\";\nimport {BytesLib} from \"@summa-tx/bitcoin-spv-sol/contracts/BytesLib.sol\";\nimport {ValidateSPV} from \"@summa-tx/bitcoin-spv-sol/contracts/ValidateSPV.sol\";\nimport {CheckBitcoinSigs} from \"@summa-tx/bitcoin-spv-sol/contracts/CheckBitcoinSigs.sol\";\nimport {IERC721} from \"openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\";\nimport {SafeMath} from \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport {IBondedECDSAKeep} from \"@keep-network/keep-ecdsa/contracts/api/IBondedECDSAKeep.sol\";\nimport {DepositUtils} from \"./DepositUtils.sol\";\nimport {DepositStates} from \"./DepositStates.sol\";\nimport {OutsourceDepositLogging} from \"./OutsourceDepositLogging.sol\";\nimport {TBTCConstants} from \"../system/TBTCConstants.sol\";\nimport {TBTCToken} from \"../system/TBTCToken.sol\";\nimport {DepositLiquidation} from \"./DepositLiquidation.sol\";\n\nlibrary DepositRedemption {\n\n    using SafeMath for uint256;\n    using CheckBitcoinSigs for bytes;\n    using BytesLib for bytes;\n    using BTCUtils for bytes;\n    using ValidateSPV for bytes;\n    using ValidateSPV for bytes32;\n\n    using DepositUtils for DepositUtils.Deposit;\n    using DepositStates for DepositUtils.Deposit;\n    using DepositLiquidation for DepositUtils.Deposit;\n    using OutsourceDepositLogging for DepositUtils.Deposit;\n\n    /// @notice     Pushes signer fee to the Keep group by transferring it to the Keep address.\n    /// @dev        Approves the keep contract, then expects it to call transferFrom.\n    function distributeSignerFee(DepositUtils.Deposit storage _d) internal {\n        IBondedECDSAKeep _keep = IBondedECDSAKeep(_d.keepAddress);\n\n        _d.tbtcToken.approve(_d.keepAddress, _d.signerFeeTbtc());\n        _keep.distributeERC20Reward(address(_d.tbtcToken), _d.signerFeeTbtc());\n    }\n\n    /// @notice Approves digest for signing by a keep.\n    /// @dev Calls given keep to sign the digest. Records a current timestamp\n    /// for given digest.\n    /// @param _digest Digest to approve.\n    function approveDigest(DepositUtils.Deposit storage _d, bytes32 _digest) internal {\n        IBondedECDSAKeep(_d.keepAddress).sign(_digest);\n\n        _d.approvedDigests[_digest] = block.timestamp;\n    }\n\n    /// @notice Handles TBTC requirements for redemption.\n    /// @dev Burns or transfers depending on term and supply-peg impact.\n    ///      Once these transfers complete, the deposit balance should be\n    ///      sufficient to pay out signer fees once the redemption transaction\n    ///      is proven on the Bitcoin side.\n    function performRedemptionTbtcTransfers(DepositUtils.Deposit storage _d) internal {\n        address tdtHolder = _d.depositOwner();\n        address frtHolder = _d.feeRebateTokenHolder();\n        address vendingMachineAddress = _d.vendingMachineAddress;\n\n        (\n            uint256 tbtcOwedToDeposit,\n            uint256 tbtcOwedToTdtHolder,\n            uint256 tbtcOwedToFrtHolder\n        ) = _d.calculateRedemptionTbtcAmounts(_d.redeemerAddress, false);\n\n        if(tbtcOwedToDeposit > 0){\n            _d.tbtcToken.transferFrom(msg.sender, address(this), tbtcOwedToDeposit);\n        }\n        if(tbtcOwedToTdtHolder > 0){\n            if(tdtHolder == vendingMachineAddress){\n                _d.tbtcToken.burn(tbtcOwedToTdtHolder);\n            } else {\n                _d.tbtcToken.transfer(tdtHolder, tbtcOwedToTdtHolder);\n            }\n        }\n        if(tbtcOwedToFrtHolder > 0){\n            _d.tbtcToken.transfer(frtHolder, tbtcOwedToFrtHolder);\n        }\n    }\n\n    function _requestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript,\n        address payable _redeemer\n    ) internal {\n        require(_d.inRedeemableState(), \"Redemption only available from Active or Courtesy state\");\n        bytes memory _output = abi.encodePacked(_outputValueBytes, _redeemerOutputScript);\n        require(_output.extractHash().length > 0, \"Output script must be a standard type\");\n\n        // set redeemerAddress early to enable direct access by other functions\n        _d.redeemerAddress = _redeemer;\n\n        performRedemptionTbtcTransfers(_d);\n\n        // Convert the 8-byte LE ints to uint256\n        uint256 _outputValue = abi.encodePacked(_outputValueBytes).reverseEndianness().bytesToUint();\n        uint256 _requestedFee = _d.utxoValue().sub(_outputValue);\n\n        require(_requestedFee >= TBTCConstants.getMinimumRedemptionFee(), \"Fee is too low\");\n        require(\n            _requestedFee < _d.utxoValue() / 2,\n            \"Initial fee cannot exceed half of the deposit's value\"\n        );\n\n        // Calculate the sighash\n        bytes32 _sighash = CheckBitcoinSigs.wpkhSpendSighash(\n            _d.utxoOutpoint,\n            _d.signerPKH(),\n            _d.utxoValueBytes,\n            _outputValueBytes,\n            _redeemerOutputScript);\n\n        // write all request details\n        _d.redeemerOutputScript = _redeemerOutputScript;\n        _d.initialRedemptionFee = _requestedFee;\n        _d.latestRedemptionFee = _requestedFee;\n        _d.withdrawalRequestTime = block.timestamp;\n        _d.lastRequestedDigest = _sighash;\n\n        approveDigest(_d, _sighash);\n\n        _d.setAwaitingWithdrawalSignature();\n        _d.logRedemptionRequested(\n            _redeemer,\n            _sighash,\n            _d.utxoValue(),\n            _redeemerOutputScript,\n            _requestedFee,\n            _d.utxoOutpoint);\n    }\n\n    /// @notice                     Anyone can request redemption as long as they can.\n    ///                             approve the TDT transfer to the final recipient.\n    /// @dev                        The redeemer specifies details about the Bitcoin redemption tx and pays for the redemption\n    ///                             on behalf of _finalRecipient.\n    /// @param  _d                  Deposit storage pointer.\n    /// @param  _outputValueBytes   The 8-byte LE output size.\n    /// @param  _redeemerOutputScript The redeemer's length-prefixed output script.\n    /// @param  _finalRecipient     The address to receive the TDT and later be recorded as deposit redeemer.\n    function transferAndRequestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public { // not external to allow bytes memory parameters\n        _d.tbtcDepositToken.transferFrom(msg.sender, _finalRecipient, uint256(address(this)));\n\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, _finalRecipient);\n    }\n\n    /// @notice                     Only TDT holder can request redemption,\n    ///                             unless Deposit is expired or in COURTESY_CALL.\n    /// @dev                        The redeemer specifies details about the Bitcoin redemption transaction.\n    /// @param  _d                  Deposit storage pointer.\n    /// @param  _outputValueBytes   The 8-byte LE output size.\n    /// @param  _redeemerOutputScript The redeemer's length-prefixed output script.\n    function requestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript\n    ) public { // not external to allow bytes memory parameters\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, msg.sender);\n    }\n\n    /// @notice     Anyone may provide a withdrawal signature if it was requested.\n    /// @dev        The signers will be penalized if this (or provideRedemptionProof) is not called.\n    /// @param  _d  Deposit storage pointer.\n    /// @param  _v  Signature recovery value.\n    /// @param  _r  Signature R value.\n    /// @param  _s  Signature S value. Should be in the low half of secp256k1 curve's order.\n    function provideRedemptionSignature(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        require(_d.inAwaitingWithdrawalSignature(), \"Not currently awaiting a signature\");\n\n        // If we're outside of the signature window, we COULD punish signers here\n        // Instead, we consider this a no-harm-no-foul situation.\n        // The signers have not stolen funds. Most likely they've just inconvenienced someone\n\n        // Validate `s` value for a malleability concern described in EIP-2.\n        // Only signatures with `s` value in the lower half of the secp256k1\n        // curve's order are considered valid.\n        require(\n            uint256(_s) <=\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"Malleable signature - s should be in the low half of secp256k1 curve's order\"\n        );\n\n        // The signature must be valid on the pubkey\n        require(\n            _d.signerPubkey().checkSig(\n                _d.lastRequestedDigest,\n                _v, _r, _s\n            ),\n            \"Invalid signature\"\n        );\n\n        // A signature has been provided, now we wait for fee bump or redemption\n        _d.setAwaitingWithdrawalProof();\n        _d.logGotRedemptionSignature(\n            _d.lastRequestedDigest,\n            _r,\n            _s);\n\n    }\n\n    /// @notice                             Anyone may notify the contract that a fee bump is needed.\n    /// @dev                                This sends us back to AWAITING_WITHDRAWAL_SIGNATURE.\n    /// @param  _d                          Deposit storage pointer.\n    /// @param  _previousOutputValueBytes   The previous output's value.\n    /// @param  _newOutputValueBytes        The new output's value.\n    function increaseRedemptionFee(\n        DepositUtils.Deposit storage _d,\n        bytes8 _previousOutputValueBytes,\n        bytes8 _newOutputValueBytes\n    ) public {\n        require(_d.inAwaitingWithdrawalProof(), \"Fee increase only available after signature provided\");\n        require(block.timestamp >= _d.withdrawalRequestTime.add(TBTCConstants.getIncreaseFeeTimer()), \"Fee increase not yet permitted\");\n\n        uint256 _newOutputValue = checkRelationshipToPrevious(_d, _previousOutputValueBytes, _newOutputValueBytes);\n\n        // If the fee bump shrinks the UTXO value below the minimum allowed\n        // value, clamp it to that minimum. Further fee bumps will be disallowed\n        // by checkRelationshipToPrevious.\n        if (_newOutputValue < TBTCConstants.getMinimumUtxoValue()) {\n            _newOutputValue = TBTCConstants.getMinimumUtxoValue();\n        }\n\n        _d.latestRedemptionFee = _d.utxoValue().sub(_newOutputValue);\n\n        // Calculate the next sighash\n        bytes32 _sighash = CheckBitcoinSigs.wpkhSpendSighash(\n            _d.utxoOutpoint,\n            _d.signerPKH(),\n            _d.utxoValueBytes,\n            _newOutputValueBytes,\n            _d.redeemerOutputScript);\n\n        // Ratchet the signature and redemption proof timeouts\n        _d.withdrawalRequestTime = block.timestamp;\n        _d.lastRequestedDigest = _sighash;\n\n        approveDigest(_d, _sighash);\n\n        // Go back to waiting for a signature\n        _d.setAwaitingWithdrawalSignature();\n        _d.logRedemptionRequested(\n            msg.sender,\n            _sighash,\n            _d.utxoValue(),\n            _d.redeemerOutputScript,\n            _d.latestRedemptionFee,\n            _d.utxoOutpoint);\n    }\n\n    function checkRelationshipToPrevious(\n        DepositUtils.Deposit storage _d,\n        bytes8 _previousOutputValueBytes,\n        bytes8 _newOutputValueBytes\n    ) public view returns (uint256 _newOutputValue){\n\n        // Check that we're incrementing the fee by exactly the redeemer's initial fee\n        uint256 _previousOutputValue = DepositUtils.bytes8LEToUint(_previousOutputValueBytes);\n        _newOutputValue = DepositUtils.bytes8LEToUint(_newOutputValueBytes);\n        require(_previousOutputValue.sub(_newOutputValue) == _d.initialRedemptionFee, \"Not an allowed fee step\");\n\n        // Calculate the previous one so we can check that it really is the previous one\n        bytes32 _previousSighash = CheckBitcoinSigs.wpkhSpendSighash(\n            _d.utxoOutpoint,\n            _d.signerPKH(),\n            _d.utxoValueBytes,\n            _previousOutputValueBytes,\n            _d.redeemerOutputScript);\n        require(\n            _d.wasDigestApprovedForSigning(_previousSighash) == _d.withdrawalRequestTime,\n            \"Provided previous value does not yield previous sighash\"\n        );\n    }\n\n    /// @notice                 Anyone may provide a withdrawal proof to prove redemption.\n    /// @dev                    The signers will be penalized if this is not called.\n    /// @param  _d              Deposit storage pointer.\n    /// @param  _txVersion      Transaction version number (4-byte LE).\n    /// @param  _txInputVector  All transaction inputs prepended by the number of inputs encoded as a VarInt, max 0xFC(252) inputs.\n    /// @param  _txOutputVector All transaction outputs prepended by the number of outputs encoded as a VarInt, max 0xFC(252) outputs.\n    /// @param  _txLocktime     Final 4 bytes of the transaction.\n    /// @param  _merkleProof    The merkle proof of inclusion of the tx in the bitcoin block.\n    /// @param  _txIndexInBlock The index of the tx in the Bitcoin block (0-indexed).\n    /// @param  _bitcoinHeaders An array of tightly-packed bitcoin headers.\n    function provideRedemptionProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public { // not external to allow bytes memory parameters\n        bytes32 _txid;\n        uint256 _fundingOutputValue;\n\n        require(_d.inRedemption(), \"Redemption proof only allowed from redemption flow\");\n\n        _fundingOutputValue = redemptionTransactionChecks(_d, _txInputVector, _txOutputVector);\n\n        _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n        _d.checkProofFromTxId(_txid, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        require((_d.utxoValue().sub(_fundingOutputValue)) <= _d.latestRedemptionFee, \"Incorrect fee amount\");\n\n        // Transfer TBTC to signers and close the keep.\n        distributeSignerFee(_d);\n        _d.closeKeep();\n\n        _d.distributeFeeRebate();\n\n        // We're done yey!\n        _d.setRedeemed();\n        _d.redemptionTeardown();\n        _d.logRedeemed(_txid);\n    }\n\n    /// @notice                 Check the redemption transaction input and output vector to ensure the transaction spends\n    ///                         the correct UTXO and sends value to the appropriate public key hash.\n    /// @dev                    We only look at the first input and first output. Revert if we find the wrong UTXO or value recipient.\n    ///                         It's safe to look at only the first input/output as anything that breaks this can be considered fraud\n    ///                         and can be caught by ECDSAFraudProof.\n    /// @param  _d              Deposit storage pointer.\n    /// @param _txInputVector   All transaction inputs prepended by the number of inputs encoded as a VarInt, max 0xFC(252) inputs.\n    /// @param _txOutputVector  All transaction outputs prepended by the number of outputs encoded as a VarInt, max 0xFC(252) outputs.\n    /// @return                 The value sent to the redeemer's public key hash.\n    function redemptionTransactionChecks(\n        DepositUtils.Deposit storage _d,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector\n    ) public view returns (uint256) {\n        require(_txInputVector.validateVin(), \"invalid input vector provided\");\n        require(_txOutputVector.validateVout(), \"invalid output vector provided\");\n        bytes memory _input = _txInputVector.slice(1, _txInputVector.length-1);\n\n        require(\n            keccak256(_input.extractOutpoint()) == keccak256(_d.utxoOutpoint),\n            \"Tx spends the wrong UTXO\"\n        );\n\n        bytes memory _output = _txOutputVector.slice(1, _txOutputVector.length-1);\n        bytes memory _expectedOutputScript = _d.redeemerOutputScript;\n        require(_output.length - 8 >= _d.redeemerOutputScript.length, \"Output script is too short to extract the expected script\");\n        require(\n            keccak256(_output.slice(8, _expectedOutputScript.length)) == keccak256(_expectedOutputScript),\n            \"Tx sends value to wrong output script\"\n        );\n        return (uint256(_output.extractValue()));\n    }\n\n    /// @notice     Anyone may notify the contract that the signers have failed to produce a signature.\n    /// @dev        This is considered fraud, and is punished.\n    /// @param  _d  Deposit storage pointer.\n    function notifyRedemptionSignatureTimedOut(DepositUtils.Deposit storage _d) external {\n        require(_d.inAwaitingWithdrawalSignature(), \"Not currently awaiting a signature\");\n        require(block.timestamp > _d.withdrawalRequestTime.add(TBTCConstants.getSignatureTimeout()), \"Signature timer has not elapsed\");\n        _d.startLiquidation(false);  // not fraud, just failure\n    }\n\n    /// @notice     Anyone may notify the contract that the signers have failed to produce a redemption proof.\n    /// @dev        This is considered fraud, and is punished.\n    /// @param  _d  Deposit storage pointer.\n    function notifyRedemptionProofTimedOut(DepositUtils.Deposit storage _d) external {\n        require(_d.inAwaitingWithdrawalProof(), \"Not currently awaiting a redemption proof\");\n        require(block.timestamp > _d.withdrawalRequestTime.add(TBTCConstants.getRedemptionProofTimeout()), \"Proof timer has not elapsed\");\n        _d.startLiquidation(false);  // not fraud, just failure\n    }\n}\n"
    },
    "solidity/contracts/deposit/DepositLiquidation.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {BTCUtils} from \"@summa-tx/bitcoin-spv-sol/contracts/BTCUtils.sol\";\nimport {BytesLib} from \"@summa-tx/bitcoin-spv-sol/contracts/BytesLib.sol\";\nimport {IBondedECDSAKeep} from \"@keep-network/keep-ecdsa/contracts/api/IBondedECDSAKeep.sol\";\nimport {SafeMath} from \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport {DepositStates} from \"./DepositStates.sol\";\nimport {DepositUtils} from \"./DepositUtils.sol\";\nimport {TBTCConstants} from \"../system/TBTCConstants.sol\";\nimport {OutsourceDepositLogging} from \"./OutsourceDepositLogging.sol\";\nimport {TBTCToken} from \"../system/TBTCToken.sol\";\nimport {ITBTCSystem} from \"../interfaces/ITBTCSystem.sol\";\n\nlibrary DepositLiquidation {\n\n    using BTCUtils for bytes;\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n    using SafeMath for uint64;\n\n    using DepositUtils for DepositUtils.Deposit;\n    using DepositStates for DepositUtils.Deposit;\n    using OutsourceDepositLogging for DepositUtils.Deposit;\n\n    /// @notice Notifies the keep contract of fraud. Reverts if not fraud.\n    /// @dev Calls out to the keep contract. this could get expensive if preimage\n    ///      is large.\n    /// @param  _d Deposit storage pointer.\n    /// @param  _v Signature recovery value.\n    /// @param  _r Signature R value.\n    /// @param  _s Signature S value.\n    /// @param _signedDigest The digest signed by the signature vrs tuple.\n    /// @param _preimage The sha256 preimage of the digest.\n    function submitSignatureFraud(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public {\n        IBondedECDSAKeep _keep = IBondedECDSAKeep(_d.keepAddress);\n        _keep.submitSignatureFraud(_v, _r, _s, _signedDigest, _preimage);\n    }\n\n    /// @notice     Determines the collateralization percentage of the signing group.\n    /// @dev        Compares the bond value and lot value.\n    /// @param _d   Deposit storage pointer.\n    /// @return     Collateralization percentage as uint.\n    function collateralizationPercentage(DepositUtils.Deposit storage _d) public view returns (uint256) {\n\n        // Determine value of the lot in wei\n        uint256 _satoshiPrice = _d.fetchBitcoinPrice();\n        uint64 _lotSizeSatoshis = _d.lotSizeSatoshis;\n        uint256 _lotValue = _lotSizeSatoshis.mul(_satoshiPrice);\n\n        // Amount of wei the signers have\n        uint256 _bondValue = _d.fetchBondAmount();\n\n        // This converts into a percentage\n        return (_bondValue.mul(100).div(_lotValue));\n    }\n\n    /// @dev              Starts signer liquidation by seizing signer bonds.\n    ///                   If the deposit is currently being redeemed, the redeemer\n    ///                   receives the full bond value; otherwise, a falling price auction\n    ///                   begins to buy 1 TBTC in exchange for a portion of the seized bonds;\n    ///                   see purchaseSignerBondsAtAuction().\n    /// @param _wasFraud  True if liquidation is being started due to fraud, false if for any other reason.\n    /// @param _d         Deposit storage pointer.\n    function startLiquidation(DepositUtils.Deposit storage _d, bool _wasFraud) internal {\n        _d.logStartedLiquidation(_wasFraud);\n\n        uint256 seized = _d.seizeSignerBonds();\n        address redeemerAddress = _d.redeemerAddress;\n\n        // Reclaim used state for gas savings\n        _d.redemptionTeardown();\n\n        // If we see fraud in the redemption flow, we shouldn't go to auction.\n        // Instead give the full signer bond directly to the redeemer.\n        if (_d.inRedemption() && _wasFraud) {\n            _d.setLiquidated();\n            _d.enableWithdrawal(redeemerAddress, seized);\n            _d.logLiquidated();\n            return;\n        }\n\n        _d.liquidationInitiator = msg.sender;\n        _d.liquidationInitiated = block.timestamp;  // Store the timestamp for auction\n\n        if(_wasFraud){\n            _d.setFraudLiquidationInProgress();\n        }\n        else{\n            _d.setLiquidationInProgress();\n        }\n    }\n\n    /// @notice                 Anyone can provide a signature that was not requested to prove fraud.\n    /// @dev                    Calls out to the keep to verify if there was fraud.\n    /// @param  _d              Deposit storage pointer.\n    /// @param  _v              Signature recovery value.\n    /// @param  _r              Signature R value.\n    /// @param  _s              Signature S value.\n    /// @param _signedDigest    The digest signed by the signature vrs tuple.\n    /// @param _preimage        The sha256 preimage of the digest.\n    function provideECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public { // not external to allow bytes memory parameters\n        require(\n            !_d.inFunding(),\n            \"Use provideFundingECDSAFraudProof instead\"\n        );\n        require(\n            !_d.inSignerLiquidation(),\n            \"Signer liquidation already in progress\"\n        );\n        require(!_d.inEndState(), \"Contract has halted\");\n        submitSignatureFraud(_d, _v, _r, _s, _signedDigest, _preimage);\n\n        startLiquidation(_d, true);\n    }\n\n\n    /// @notice     Closes an auction and purchases the signer bonds. Payout to buyer, funder, then signers if not fraud.\n    /// @dev        For interface, reading auctionValue will give a past value. the current is better.\n    /// @param  _d  Deposit storage pointer.\n    function purchaseSignerBondsAtAuction(DepositUtils.Deposit storage _d) external {\n        bool _wasFraud = _d.inFraudLiquidationInProgress();\n        require(_d.inSignerLiquidation(), \"No active auction\");\n\n        _d.setLiquidated();\n        _d.logLiquidated();\n\n        // Send the TBTC to the redeemer if they exist, otherwise to the TDT\n        // holder. If the TDT holder is the Vending Machine, burn it to maintain\n        // the peg. This is because, if there is a redeemer set here, the TDT\n        // holder has already been made whole at redemption request time.\n        address tbtcRecipient = _d.redeemerAddress;\n        if (tbtcRecipient == address(0)) {\n            tbtcRecipient = _d.depositOwner();\n        }\n        uint256 lotSizeTbtc = _d.lotSizeTbtc();\n\n        require(_d.tbtcToken.balanceOf(msg.sender) >= lotSizeTbtc, \"Not enough TBTC to cover outstanding debt\");\n\n        if(tbtcRecipient == _d.vendingMachineAddress){\n            _d.tbtcToken.burnFrom(msg.sender, lotSizeTbtc);  // burn minimal amount to cover size\n        }\n        else{\n            _d.tbtcToken.transferFrom(msg.sender, tbtcRecipient, lotSizeTbtc);\n        }\n\n        // Distribute funds to auction buyer\n        uint256 valueToDistribute = _d.auctionValue();\n        _d.enableWithdrawal(msg.sender, valueToDistribute);\n\n        // Send any TBTC left to the Fee Rebate Token holder\n        _d.distributeFeeRebate();\n\n        // For fraud, pay remainder to the liquidation initiator.\n        // For non-fraud, split 50-50 between initiator and signers. if the transfer amount is 1,\n        // division will yield a 0 value which causes a revert; instead,\n        // we simply ignore such a tiny amount and leave some wei dust in escrow\n        uint256 contractEthBalance = address(this).balance;\n        address payable initiator = _d.liquidationInitiator;\n\n        if (initiator == address(0)){\n            initiator = address(0xdead);\n        }\n        if (contractEthBalance > valueToDistribute + 1) {\n            uint256 remainingUnallocated = contractEthBalance.sub(valueToDistribute);\n            if (_wasFraud) {\n                _d.enableWithdrawal(initiator, remainingUnallocated);\n            } else {\n                // There will always be a liquidation initiator.\n                uint256 split = remainingUnallocated.div(2);\n                _d.pushFundsToKeepGroup(split);\n                _d.enableWithdrawal(initiator, remainingUnallocated.sub(split));\n            }\n        }\n    }\n\n    /// @notice     Notify the contract that the signers are undercollateralized.\n    /// @dev        Calls out to the system for oracle info.\n    /// @param  _d  Deposit storage pointer.\n    function notifyCourtesyCall(DepositUtils.Deposit storage _d) external  {\n        require(_d.inActive(), \"Can only courtesy call from active state\");\n        require(collateralizationPercentage(_d) < _d.undercollateralizedThresholdPercent, \"Signers have sufficient collateral\");\n        _d.courtesyCallInitiated = block.timestamp;\n        _d.setCourtesyCall();\n        _d.logCourtesyCalled();\n    }\n\n    /// @notice     Goes from courtesy call to active.\n    /// @dev        Only callable if collateral is sufficient and the deposit is not expiring.\n    /// @param  _d  Deposit storage pointer.\n    function exitCourtesyCall(DepositUtils.Deposit storage _d) external {\n        require(_d.inCourtesyCall(), \"Not currently in courtesy call\");\n        require(collateralizationPercentage(_d) >= _d.undercollateralizedThresholdPercent, \"Deposit is still undercollateralized\");\n        _d.setActive();\n        _d.logExitedCourtesyCall();\n    }\n\n    /// @notice     Notify the contract that the signers are undercollateralized.\n    /// @dev        Calls out to the system for oracle info.\n    /// @param  _d  Deposit storage pointer.\n    function notifyUndercollateralizedLiquidation(DepositUtils.Deposit storage _d) external {\n        require(_d.inRedeemableState(), \"Deposit not in active or courtesy call\");\n        require(collateralizationPercentage(_d) < _d.severelyUndercollateralizedThresholdPercent, \"Deposit has sufficient collateral\");\n        startLiquidation(_d, false);\n    }\n\n    /// @notice     Notifies the contract that the courtesy period has elapsed.\n    /// @dev        This is treated as an abort, rather than fraud.\n    /// @param  _d  Deposit storage pointer.\n    function notifyCourtesyCallExpired(DepositUtils.Deposit storage _d) external {\n        require(_d.inCourtesyCall(), \"Not in a courtesy call period\");\n        require(block.timestamp >= _d.courtesyCallInitiated.add(TBTCConstants.getCourtesyCallTimeout()), \"Courtesy period has not elapsed\");\n        startLiquidation(_d, false);\n    }\n}\n"
    },
    "solidity/contracts/deposit/DepositUtils.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {ValidateSPV} from \"@summa-tx/bitcoin-spv-sol/contracts/ValidateSPV.sol\";\nimport {BTCUtils} from \"@summa-tx/bitcoin-spv-sol/contracts/BTCUtils.sol\";\nimport {BytesLib} from \"@summa-tx/bitcoin-spv-sol/contracts/BytesLib.sol\";\nimport {IBondedECDSAKeep} from \"@keep-network/keep-ecdsa/contracts/api/IBondedECDSAKeep.sol\";\nimport {IERC721} from \"openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\";\nimport {SafeMath} from \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport {DepositStates} from \"./DepositStates.sol\";\nimport {TBTCConstants} from \"../system/TBTCConstants.sol\";\nimport {ITBTCSystem} from \"../interfaces/ITBTCSystem.sol\";\nimport {TBTCToken} from \"../system/TBTCToken.sol\";\nimport {FeeRebateToken} from \"../system/FeeRebateToken.sol\";\n\nlibrary DepositUtils {\n\n    using SafeMath for uint256;\n    using SafeMath for uint64;\n    using BytesLib for bytes;\n    using BTCUtils for bytes;\n    using BTCUtils for uint256;\n    using ValidateSPV for bytes;\n    using ValidateSPV for bytes32;\n    using DepositStates for DepositUtils.Deposit;\n\n    struct Deposit {\n\n        // SET DURING CONSTRUCTION\n        ITBTCSystem tbtcSystem;\n        TBTCToken tbtcToken;\n        IERC721 tbtcDepositToken;\n        FeeRebateToken feeRebateToken;\n        address vendingMachineAddress;\n        uint64 lotSizeSatoshis;\n        uint8 currentState;\n        uint16 signerFeeDivisor;\n        uint16 initialCollateralizedPercent;\n        uint16 undercollateralizedThresholdPercent;\n        uint16 severelyUndercollateralizedThresholdPercent;\n        uint256 keepSetupFee;\n\n        // SET ON FRAUD\n        uint256 liquidationInitiated;  // Timestamp of when liquidation starts\n        uint256 courtesyCallInitiated; // When the courtesy call is issued\n        address payable liquidationInitiator;\n\n        // written when we request a keep\n        address keepAddress;  // The address of our keep contract\n        uint256 signingGroupRequestedAt;  // timestamp of signing group request\n\n        // written when we get a keep result\n        uint256 fundingProofTimerStart;  // start of the funding proof period. reused for funding fraud proof period\n        bytes32 signingGroupPubkeyX;  // The X coordinate of the signing group's pubkey\n        bytes32 signingGroupPubkeyY;  // The Y coordinate of the signing group's pubkey\n\n        // INITIALLY WRITTEN BY REDEMPTION FLOW\n        address payable redeemerAddress;  // The redeemer's address, used as fallback for fraud in redemption\n        bytes redeemerOutputScript;  // The redeemer output script\n        uint256 initialRedemptionFee;  // the initial fee as requested\n        uint256 latestRedemptionFee; // the fee currently required by a redemption transaction\n        uint256 withdrawalRequestTime;  // the most recent withdrawal request timestamp\n        bytes32 lastRequestedDigest;  // the digest most recently requested for signing\n\n        // written when we get funded\n        bytes8 utxoValueBytes;  // LE uint. the size of the deposit UTXO in satoshis\n        uint256 fundedAt; // timestamp when funding proof was received\n        bytes utxoOutpoint;  // the 36-byte outpoint of the custodied UTXO\n\n        /// @dev Map of ETH balances an address can withdraw after contract reaches ends-state.\n        mapping(address => uint256) withdrawableAmounts;\n\n        /// @dev Map of timestamps representing when transaction digests were approved for signing\n        mapping (bytes32 => uint256) approvedDigests;\n    }\n\n    /// @notice Closes keep associated with the deposit.\n    /// @dev Should be called when the keep is no longer needed and the signing\n    /// group can disband.\n    function closeKeep(DepositUtils.Deposit storage _d) internal {\n        IBondedECDSAKeep _keep = IBondedECDSAKeep(_d.keepAddress);\n        _keep.closeKeep();\n    }\n\n    /// @notice         Gets the current block difficulty.\n    /// @dev            Calls the light relay and gets the current block difficulty.\n    /// @return         The difficulty.\n    function currentBlockDifficulty(Deposit storage _d) public view returns (uint256) {\n        return _d.tbtcSystem.fetchRelayCurrentDifficulty();\n    }\n\n    /// @notice         Gets the previous block difficulty.\n    /// @dev            Calls the light relay and gets the previous block difficulty.\n    /// @return         The difficulty.\n    function previousBlockDifficulty(Deposit storage _d) public view returns (uint256) {\n        return _d.tbtcSystem.fetchRelayPreviousDifficulty();\n    }\n\n    /// @notice                     Evaluates the header difficulties in a proof.\n    /// @dev                        Uses the light oracle to source recent difficulty.\n    /// @param  _bitcoinHeaders     The header chain to evaluate.\n    /// @return                     True if acceptable, otherwise revert.\n    function evaluateProofDifficulty(Deposit storage _d, bytes memory _bitcoinHeaders) public view {\n        uint256 _reqDiff;\n        uint256 _current = currentBlockDifficulty(_d);\n        uint256 _previous = previousBlockDifficulty(_d);\n        uint256 _firstHeaderDiff = _bitcoinHeaders.extractTarget().calculateDifficulty();\n\n        if (_firstHeaderDiff == _current) {\n            _reqDiff = _current;\n        } else if (_firstHeaderDiff == _previous) {\n            _reqDiff = _previous;\n        } else {\n            revert(\"not at current or previous difficulty\");\n        }\n\n        uint256 _observedDiff = _bitcoinHeaders.validateHeaderChain();\n\n        require(_observedDiff != ValidateSPV.getErrBadLength(), \"Invalid length of the headers chain\");\n        require(_observedDiff != ValidateSPV.getErrInvalidChain(), \"Invalid headers chain\");\n        require(_observedDiff != ValidateSPV.getErrLowWork(), \"Insufficient work in a header\");\n\n        require(\n            _observedDiff >= _reqDiff.mul(TBTCConstants.getTxProofDifficultyFactor()),\n            \"Insufficient accumulated difficulty in header chain\"\n        );\n    }\n\n    /// @notice                 Syntactically check an SPV proof for a bitcoin transaction with its hash (ID).\n    /// @dev                    Stateless SPV Proof verification documented elsewhere (see https://github.com/summa-tx/bitcoin-spv).\n    /// @param _d               Deposit storage pointer.\n    /// @param _txId            The bitcoin txid of the tx that is purportedly included in the header chain.\n    /// @param _merkleProof     The merkle proof of inclusion of the tx in the bitcoin block.\n    /// @param _txIndexInBlock  The index of the tx in the Bitcoin block (0-indexed).\n    /// @param _bitcoinHeaders  An array of tightly-packed bitcoin headers.\n    function checkProofFromTxId(\n        Deposit storage _d,\n        bytes32 _txId,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public view{\n        require(\n            _txId.prove(\n                _bitcoinHeaders.extractMerkleRootLE().toBytes32(),\n                _merkleProof,\n                _txIndexInBlock\n            ),\n            \"Tx merkle proof is not valid for provided header and txId\");\n        evaluateProofDifficulty(_d, _bitcoinHeaders);\n    }\n\n    /// @notice                     Find and validate funding output in transaction output vector using the index.\n    /// @dev                        Gets `_fundingOutputIndex` output from the output vector and validates if it is\n    ///                             a p2wpkh output with public key hash matching this deposit's public key hash.\n    /// @param _d                   Deposit storage pointer.\n    /// @param _txOutputVector      All transaction outputs prepended by the number of outputs encoded as a VarInt, max 0xFC outputs.\n    /// @param _fundingOutputIndex  Index of funding output in _txOutputVector.\n    /// @return                     Funding value.\n    function findAndParseFundingOutput(\n        DepositUtils.Deposit storage _d,\n        bytes memory _txOutputVector,\n        uint8 _fundingOutputIndex\n    ) public view returns (bytes8) {\n        bytes8 _valueBytes;\n        bytes memory _output;\n\n        // Find the output paying the signer PKH\n        _output = _txOutputVector.extractOutputAtIndex(_fundingOutputIndex);\n\n        require(\n            keccak256(_output.extractHash()) == keccak256(abi.encodePacked(signerPKH(_d))),\n            \"Could not identify output funding the required public key hash\"\n        );\n        require(\n            _output.length == 31 &&\n                _output.keccak256Slice(8, 23) == keccak256(abi.encodePacked(hex\"160014\", signerPKH(_d))),\n            \"Funding transaction output type unsupported: only p2wpkh outputs are supported\"\n        );\n\n        _valueBytes = bytes8(_output.slice(0, 8).toBytes32());\n        return _valueBytes;\n    }\n\n    /// @notice                     Validates the funding tx and parses information from it.\n    /// @dev                        Takes a pre-parsed transaction and calculates values needed to verify funding.\n    /// @param  _d                  Deposit storage pointer.\n    /// @param _txVersion           Transaction version number (4-byte LE).\n    /// @param _txInputVector       All transaction inputs prepended by the number of inputs encoded as a VarInt, max 0xFC(252) inputs.\n    /// @param _txOutputVector      All transaction outputs prepended by the number of outputs encoded as a VarInt, max 0xFC(252) outputs.\n    /// @param _txLocktime          Final 4 bytes of the transaction.\n    /// @param _fundingOutputIndex  Index of funding output in _txOutputVector (0-indexed).\n    /// @param _merkleProof         The merkle proof of transaction inclusion in a block.\n    /// @param _txIndexInBlock      Transaction index in the block (0-indexed).\n    /// @param _bitcoinHeaders      Single bytestring of 80-byte bitcoin headers, lowest height first.\n    /// @return                     The 8-byte LE UTXO size in satoshi, the 36byte outpoint.\n    function validateAndParseFundingSPVProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public view returns (bytes8 _valueBytes, bytes memory _utxoOutpoint){ // not external to allow bytes memory parameters\n        require(_txInputVector.validateVin(), \"invalid input vector provided\");\n        require(_txOutputVector.validateVout(), \"invalid output vector provided\");\n\n        bytes32 txID = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        _valueBytes = findAndParseFundingOutput(_d, _txOutputVector, _fundingOutputIndex);\n\n        require(bytes8LEToUint(_valueBytes) >= _d.lotSizeSatoshis, \"Deposit too small\");\n\n        checkProofFromTxId(_d, txID, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        // The utxoOutpoint is the LE txID plus the index of the output as a 4-byte LE int\n        // _fundingOutputIndex is a uint8, so we know it is only 1 byte\n        // Therefore, pad with 3 more bytes\n        _utxoOutpoint = abi.encodePacked(txID, _fundingOutputIndex, hex\"000000\");\n    }\n\n    /// @notice Retreive the remaining term of the deposit\n    /// @dev    The return value is not guaranteed since block.timestmap can be lightly manipulated by miners.\n    /// @return The remaining term of the deposit in seconds. 0 if already at term\n    function remainingTerm(DepositUtils.Deposit storage _d) public view returns(uint256){\n        uint256 endOfTerm = _d.fundedAt.add(TBTCConstants.getDepositTerm());\n        if(block.timestamp < endOfTerm ) {\n            return endOfTerm.sub(block.timestamp);\n        }\n        return 0;\n    }\n\n    /// @notice     Calculates the amount of value at auction right now.\n    /// @dev        We calculate the % of the auction that has elapsed, then scale the value up.\n    /// @param _d   Deposit storage pointer.\n    /// @return     The value in wei to distribute in the auction at the current time.\n    function auctionValue(Deposit storage _d) external view returns (uint256) {\n        uint256 _elapsed = block.timestamp.sub(_d.liquidationInitiated);\n        uint256 _available = address(this).balance;\n        if (_elapsed > TBTCConstants.getAuctionDuration()) {\n            return _available;\n        }\n\n        // This should make a smooth flow from base% to 100%\n        uint256 _basePercentage = getAuctionBasePercentage(_d);\n        uint256 _elapsedPercentage = uint256(100).sub(_basePercentage).mul(_elapsed).div(TBTCConstants.getAuctionDuration());\n        uint256 _percentage = _basePercentage.add(_elapsedPercentage);\n\n        return _available.mul(_percentage).div(100);\n    }\n\n    /// @notice         Gets the lot size in erc20 decimal places (max 18)\n    /// @return         uint256 lot size in 10**18 decimals.\n    function lotSizeTbtc(Deposit storage _d) public view returns (uint256){\n        return _d.lotSizeSatoshis.mul(TBTCConstants.getSatoshiMultiplier());\n    }\n\n    /// @notice         Determines the fees due to the signers for work performed.\n    /// @dev            Signers are paid based on the TBTC issued.\n    /// @return         Accumulated fees in 10**18 decimals.\n    function signerFeeTbtc(Deposit storage _d) public view returns (uint256) {\n        return lotSizeTbtc(_d).div(_d.signerFeeDivisor);\n    }\n\n    /// @notice             Determines the prefix to the compressed public key.\n    /// @dev                The prefix encodes the parity of the Y coordinate.\n    /// @param  _pubkeyY    The Y coordinate of the public key.\n    /// @return             The 1-byte prefix for the compressed key.\n    function determineCompressionPrefix(bytes32 _pubkeyY) public pure returns (bytes memory) {\n        if(uint256(_pubkeyY) & 1 == 1) {\n            return hex\"03\";  // Odd Y\n        } else {\n            return hex\"02\";  // Even Y\n        }\n    }\n\n    /// @notice             Compresses a public key.\n    /// @dev                Converts the 64-byte key to a 33-byte key, bitcoin-style.\n    /// @param  _pubkeyX    The X coordinate of the public key.\n    /// @param  _pubkeyY    The Y coordinate of the public key.\n    /// @return             The 33-byte compressed pubkey.\n    function compressPubkey(bytes32 _pubkeyX, bytes32 _pubkeyY) public pure returns (bytes memory) {\n        return abi.encodePacked(determineCompressionPrefix(_pubkeyY), _pubkeyX);\n    }\n\n    /// @notice    Returns the packed public key (64 bytes) for the signing group.\n    /// @dev       We store it as 2 bytes32, (2 slots) then repack it on demand.\n    /// @return    64 byte public key.\n    function signerPubkey(Deposit storage _d) external view returns (bytes memory) {\n        return abi.encodePacked(_d.signingGroupPubkeyX, _d.signingGroupPubkeyY);\n    }\n\n    /// @notice    Returns the Bitcoin pubkeyhash (hash160) for the signing group.\n    /// @dev       This is used in bitcoin output scripts for the signers.\n    /// @return    20-bytes public key hash.\n    function signerPKH(Deposit storage _d) public view returns (bytes20) {\n        bytes memory _pubkey = compressPubkey(_d.signingGroupPubkeyX, _d.signingGroupPubkeyY);\n        bytes memory _digest = _pubkey.hash160();\n        return bytes20(_digest.toAddress(0));  // dirty solidity hack\n    }\n\n    /// @notice    Returns the size of the deposit UTXO in satoshi.\n    /// @dev       We store the deposit as bytes8 to make signature checking easier.\n    /// @return    UTXO value in satoshi.\n    function utxoValue(Deposit storage _d) external view returns (uint256) {\n        return bytes8LEToUint(_d.utxoValueBytes);\n    }\n\n    /// @notice     Gets the current price of Bitcoin in Ether.\n    /// @dev        Polls the price feed via the system contract.\n    /// @return     The current price of 1 sat in wei.\n    function fetchBitcoinPrice(Deposit storage _d) external view returns (uint256) {\n        return _d.tbtcSystem.fetchBitcoinPrice();\n    }\n\n    /// @notice     Fetches the Keep's bond amount in wei.\n    /// @dev        Calls the keep contract to do so.\n    /// @return     The amount of bonded ETH in wei.\n    function fetchBondAmount(Deposit storage _d) external view returns (uint256) {\n        IBondedECDSAKeep _keep = IBondedECDSAKeep(_d.keepAddress);\n        return _keep.checkBondAmount();\n    }\n\n    /// @notice         Convert a LE bytes8 to a uint256.\n    /// @dev            Do this by converting to bytes, then reversing endianness, then converting to int.\n    /// @return         The uint256 represented in LE by the bytes8.\n    function bytes8LEToUint(bytes8 _b) public pure returns (uint256) {\n        return abi.encodePacked(_b).reverseEndianness().bytesToUint();\n    }\n\n    /// @notice         Gets timestamp of digest approval for signing.\n    /// @dev            Identifies entry in the recorded approvals by keep ID and digest pair.\n    /// @param _digest  Digest to check approval for.\n    /// @return         Timestamp from the moment of recording the digest for signing.\n    ///                 Returns 0 if the digest was not approved for signing.\n    function wasDigestApprovedForSigning(Deposit storage _d, bytes32 _digest) external view returns (uint256) {\n        return _d.approvedDigests[_digest];\n    }\n\n    /// @notice         Looks up the Fee Rebate Token holder.\n    /// @return         The current token holder if the Token exists.\n    ///                 address(0) if the token does not exist.\n    function feeRebateTokenHolder(Deposit storage _d) public view returns (address payable) {\n        address tokenHolder = address(0);\n        if(_d.feeRebateToken.exists(uint256(address(this)))){\n            tokenHolder = address(uint160(_d.feeRebateToken.ownerOf(uint256(address(this)))));\n        }\n        return address(uint160(tokenHolder));\n    }\n\n    /// @notice         Looks up the deposit beneficiary by calling the tBTC system.\n    /// @dev            We cast the address to a uint256 to match the 721 standard.\n    /// @return         The current deposit beneficiary.\n    function depositOwner(Deposit storage _d) public view returns (address payable) {\n        return address(uint160(_d.tbtcDepositToken.ownerOf(uint256(address(this)))));\n    }\n\n    /// @notice     Deletes state after termination of redemption process.\n    /// @dev        We keep around the redeemer address so we can pay them out.\n    function redemptionTeardown(Deposit storage _d) public {\n        _d.redeemerOutputScript = \"\";\n        _d.initialRedemptionFee = 0;\n        _d.withdrawalRequestTime = 0;\n        _d.lastRequestedDigest = bytes32(0);\n    }\n\n\n    /// @notice     Get the starting percentage of the bond at auction.\n    /// @dev        This will return the same value regardless of collateral price.\n    /// @return     The percentage of the InitialCollateralizationPercent that will result\n    ///             in a 100% bond value base auction given perfect collateralization.\n    function getAuctionBasePercentage(Deposit storage _d) internal view returns (uint256) {\n        return uint256(10000).div(_d.initialCollateralizedPercent);\n    }\n\n    /// @notice     Seize the signer bond from the keep contract.\n    /// @dev        we check our balance before and after.\n    /// @return     The amount seized in wei.\n    function seizeSignerBonds(Deposit storage _d) internal returns (uint256) {\n        uint256 _preCallBalance = address(this).balance;\n\n        IBondedECDSAKeep _keep = IBondedECDSAKeep(_d.keepAddress);\n        _keep.seizeSignerBonds();\n\n        uint256 _postCallBalance = address(this).balance;\n        require(_postCallBalance > _preCallBalance, \"No funds received, unexpected\");\n        return _postCallBalance.sub(_preCallBalance);\n    }\n\n    /// @notice     Adds a given amount to the withdraw allowance for the address.\n    /// @dev        Withdrawals can only happen when a contract is in an end-state.\n    function enableWithdrawal(DepositUtils.Deposit storage _d, address _withdrawer, uint256 _amount) internal {\n        _d.withdrawableAmounts[_withdrawer] = _d.withdrawableAmounts[_withdrawer].add(_amount);\n    }\n\n    /// @notice     Withdraw caller's allowance.\n    /// @dev        Withdrawals can only happen when a contract is in an end-state.\n    function withdrawFunds(DepositUtils.Deposit storage _d) internal {\n        uint256 available = _d.withdrawableAmounts[msg.sender];\n\n        require(_d.inEndState(), \"Contract not yet terminated\");\n        require(available > 0, \"Nothing to withdraw\");\n        require(address(this).balance >= available, \"Insufficient contract balance\");\n\n        // zero-out to prevent reentrancy\n        _d.withdrawableAmounts[msg.sender] = 0;\n\n        /* solium-disable-next-line security/no-call-value */\n        (bool ok,) = msg.sender.call.value(available)(\"\");\n        require(\n            ok,\n            \"Failed to send withdrawable amount to sender\"\n        );\n    }\n\n    /// @notice     Get the caller's withdraw allowance.\n    /// @return     The caller's withdraw allowance in wei.\n    function getWithdrawableAmount(DepositUtils.Deposit storage _d) internal view returns (uint256) {\n        return _d.withdrawableAmounts[msg.sender];\n    }\n\n    /// @notice     Distributes the fee rebate to the Fee Rebate Token owner.\n    /// @dev        Whenever this is called we are shutting down.\n    function distributeFeeRebate(Deposit storage _d) internal {\n        address rebateTokenHolder = feeRebateTokenHolder(_d);\n\n        // exit the function if there is nobody to send the rebate to\n        if(rebateTokenHolder == address(0)){\n            return;\n        }\n\n        // pay out the rebate if it is available\n        if(_d.tbtcToken.balanceOf(address(this)) >= signerFeeTbtc(_d)) {\n            _d.tbtcToken.transfer(rebateTokenHolder, signerFeeTbtc(_d));\n        }\n    }\n\n    /// @notice             Pushes ether held by the deposit to the signer group.\n    /// @dev                Ether is returned to signing group members bonds.\n    /// @param  _ethValue   The amount of ether to send.\n    function pushFundsToKeepGroup(Deposit storage _d, uint256 _ethValue) internal {\n        require(address(this).balance >= _ethValue, \"Not enough funds to send\");\n        if(_ethValue > 0){\n            IBondedECDSAKeep _keep = IBondedECDSAKeep(_d.keepAddress);\n            _keep.returnPartialSignerBonds.value(_ethValue)();\n        }\n    }\n\n    /// @notice Calculate TBTC amount required for redemption by a specified\n    ///         _redeemer. If _assumeRedeemerHoldTdt is true, return the\n    ///         requirement as if the redeemer holds this deposit's TDT.\n    /// @dev Will revert if redemption is not possible by the current owner and\n    ///      _assumeRedeemerHoldsTdt was not set. Setting\n    ///      _assumeRedeemerHoldsTdt only when appropriate is the responsibility\n    ///      of the caller; as such, this function should NEVER be publicly\n    ///      exposed.\n    /// @param _redeemer The account that should be treated as redeeming this\n    ///        deposit  for the purposes of this calculation.\n    /// @param _assumeRedeemerHoldsTdt If true, the calculation assumes that the\n    ///        specified redeemer holds the TDT. If false, the calculation\n    ///        checks the deposit owner against the specified _redeemer. Note\n    ///        that this parameter should be false for all mutating calls to\n    ///        preserve system correctness.\n    /// @return A tuple of the amount the redeemer owes to the deposit to\n    ///         initiate redemption, the amount that is owed to the TDT holder\n    ///         when redemption is initiated, and the amount that is owed to the\n    ///         FRT holder when redemption is initiated.\n    function calculateRedemptionTbtcAmounts(\n        DepositUtils.Deposit storage _d,\n        address _redeemer,\n        bool _assumeRedeemerHoldsTdt\n    ) internal view returns (\n        uint256 owedToDeposit,\n        uint256 owedToTdtHolder,\n        uint256 owedToFrtHolder\n    ) {\n        bool redeemerHoldsTdt =\n            _assumeRedeemerHoldsTdt || depositOwner(_d) == _redeemer;\n        bool preTerm = remainingTerm(_d) > 0 &&  !_d.inCourtesyCall();\n\n        require(\n            redeemerHoldsTdt || !preTerm,\n            \"Only TDT holder can redeem unless deposit is at-term or in COURTESY_CALL\"\n        );\n\n        bool frtExists = feeRebateTokenHolder(_d) != address(0);\n        bool redeemerHoldsFrt = feeRebateTokenHolder(_d) == _redeemer;\n        uint256 signerFee = signerFeeTbtc(_d);\n\n        uint256 feeEscrow = calculateRedemptionFeeEscrow(\n            signerFee,\n            preTerm,\n            frtExists,\n            redeemerHoldsTdt,\n            redeemerHoldsFrt\n        );\n\n        // Base redemption + fee = total we need to have escrowed to start\n        // redemption.\n        owedToDeposit =\n            calculateBaseRedemptionCharge(\n                lotSizeTbtc(_d),\n                redeemerHoldsTdt\n            ).add(feeEscrow);\n\n        // Adjust the amount owed to the deposit based on any balance the\n        // deposit already has.\n        uint256 balance = _d.tbtcToken.balanceOf(address(this));\n        if (owedToDeposit > balance) {\n            owedToDeposit = owedToDeposit.sub(balance);\n        } else {\n            owedToDeposit = 0;\n        }\n\n        // Pre-term, the FRT rebate is payed out, but if the redeemer holds the\n        // FRT, the amount has already been subtracted from what is owed to the\n        // deposit at this point (by calculateRedemptionFeeEscrow). This allows\n        // the redeemer to simply *not pay* the fee rebate, rather than having\n        // them pay it only to have it immediately returned.\n        if (preTerm && frtExists && !redeemerHoldsFrt) {\n            owedToFrtHolder = signerFee;\n        }\n\n        // The TDT holder gets any leftover balance.\n        owedToTdtHolder =\n            balance.add(owedToDeposit).sub(signerFee).sub(owedToFrtHolder);\n\n        return (owedToDeposit, owedToTdtHolder, owedToFrtHolder);\n    }\n\n    /// @notice                    Get the base TBTC amount needed to redeem.\n    /// @param _lotSize   The lot size to use for the base redemption charge.\n    /// @param _redeemerHoldsTdt   True if the redeemer is the TDT holder.\n    /// @return                    The amount in TBTC.\n    function calculateBaseRedemptionCharge(\n        uint256 _lotSize,\n        bool _redeemerHoldsTdt\n    ) internal pure returns (uint256){\n        if (_redeemerHoldsTdt) {\n            return 0;\n        }\n        return _lotSize;\n    }\n\n    /// @notice  Get fees owed for redemption\n    /// @param signerFee The value of the signer fee for fee calculations.\n    /// @param _preTerm               True if the Deposit is at-term or in courtesy_call.\n    /// @param _frtExists     True if the FRT exists.\n    /// @param _redeemerHoldsTdt     True if the the redeemer holds the TDT.\n    /// @param _redeemerHoldsFrt     True if the redeemer holds the FRT.\n    /// @return                      The fees owed in TBTC.\n    function calculateRedemptionFeeEscrow(\n        uint256 signerFee,\n        bool _preTerm,\n        bool _frtExists,\n        bool _redeemerHoldsTdt,\n        bool _redeemerHoldsFrt\n    ) internal pure returns (uint256) {\n        // Escrow the fee rebate so the FRT holder can be repaids, unless the\n        // redeemer holds the FRT, in which case we simply don't require the\n        // rebate from them.\n        bool escrowRequiresFeeRebate =\n            _preTerm && _frtExists && ! _redeemerHoldsFrt;\n\n        bool escrowRequiresFee =\n            _preTerm ||\n            // If the FRT exists at term/courtesy call, the fee is\n            // \"required\", but should already be escrowed before redemption.\n            _frtExists ||\n            // The TDT holder always owes fees if there is no FRT.\n            _redeemerHoldsTdt;\n\n        uint256 feeEscrow = 0;\n        if (escrowRequiresFee) {\n            feeEscrow += signerFee;\n        }\n        if (escrowRequiresFeeRebate) {\n            feeEscrow += signerFee;\n        }\n\n        return feeEscrow;\n    }\n}\n"
    },
    "solidity/contracts/system/TBTCSystem.sol": {
      "content": "/* solium-disable function-order */\npragma solidity 0.5.17;\n\nimport {IBondedECDSAKeepFactory} from \"@keep-network/keep-ecdsa/contracts/api/IBondedECDSAKeepFactory.sol\";\n\nimport {VendingMachine} from \"./VendingMachine.sol\";\nimport {DepositFactory} from \"../proxy/DepositFactory.sol\";\n\nimport {IRelay} from \"@summa-tx/relay-sol/contracts/Relay.sol\";\nimport \"../external/IMedianizer.sol\";\n\nimport {ITBTCSystem} from \"../interfaces/ITBTCSystem.sol\";\nimport {ISatWeiPriceFeed} from \"../interfaces/ISatWeiPriceFeed.sol\";\nimport {DepositLog} from \"../DepositLog.sol\";\n\nimport {TBTCDepositToken} from \"./TBTCDepositToken.sol\";\nimport \"./TBTCToken.sol\";\nimport \"./FeeRebateToken.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./KeepFactorySelection.sol\";\n\n/// @title TBTC System.\n/// @notice This contract acts as a central point for access control,\n///         value governance, and price feed.\n/// @dev    Governable values should only affect new deposit creation.\ncontract TBTCSystem is Ownable, ITBTCSystem, DepositLog {\n\n    using SafeMath for uint256;\n    using KeepFactorySelection for KeepFactorySelection.Storage;\n\n    event EthBtcPriceFeedAdditionStarted(address _priceFeed, uint256 _timestamp);\n    event LotSizesUpdateStarted(uint64[] _lotSizes, uint256 _timestamp);\n    event SignerFeeDivisorUpdateStarted(uint16 _signerFeeDivisor, uint256 _timestamp);\n    event CollateralizationThresholdsUpdateStarted(\n        uint16 _initialCollateralizedPercent,\n        uint16 _undercollateralizedThresholdPercent,\n        uint16 _severelyUndercollateralizedThresholdPercent,\n        uint256 _timestamp\n    );\n    event KeepFactoriesUpdateStarted(\n        address _keepStakedFactory,\n        address _fullyBackedFactory,\n        address _factorySelector,\n        uint256 _timestamp\n    );\n\n    event EthBtcPriceFeedAdded(address _priceFeed);\n    event LotSizesUpdated(uint64[] _lotSizes);\n    event AllowNewDepositsUpdated(bool _allowNewDeposits);\n    event SignerFeeDivisorUpdated(uint16 _signerFeeDivisor);\n    event CollateralizationThresholdsUpdated(\n        uint16 _initialCollateralizedPercent,\n        uint16 _undercollateralizedThresholdPercent,\n        uint16 _severelyUndercollateralizedThresholdPercent\n    );\n    event KeepFactoriesUpdated(\n        address _keepStakedFactory,\n        address _fullyBackedFactory,\n        address _factorySelector\n    );\n\n    uint256 initializedTimestamp = 0;\n    uint256 pausedTimestamp;\n    uint256 constant pausedDuration = 10 days;\n\n    ISatWeiPriceFeed public priceFeed;\n    IRelay public relay;\n\n    KeepFactorySelection.Storage keepFactorySelection;\n\n    uint16 public keepSize;\n    uint16 public keepThreshold;\n\n    // Parameters governed by the TBTCSystem owner\n    bool private allowNewDeposits = false;\n    uint16 private signerFeeDivisor = 2000; // 1/2000 == 5bps == 0.05% == 0.0005\n    uint16 private initialCollateralizedPercent = 150; // percent\n    uint16 private undercollateralizedThresholdPercent = 125;  // percent\n    uint16 private severelyUndercollateralizedThresholdPercent = 110; // percent\n    uint64[] lotSizesSatoshis = [10**6, 10**7, 2 * 10**7, 5 * 10**7, 10**8]; // [0.01, 0.1, 0.2, 0.5, 1.0] BTC\n\n    uint256 constant governanceTimeDelay = 48 hours;\n    uint256 constant keepFactoriesUpgradeabilityPeriod = 180 days;\n\n    uint256 private signerFeeDivisorChangeInitiated;\n    uint256 private lotSizesChangeInitiated;\n    uint256 private collateralizationThresholdsChangeInitiated;\n    uint256 private keepFactoriesUpdateInitiated;\n\n    uint16 private newSignerFeeDivisor;\n    uint64[] newLotSizesSatoshis;\n    uint16 private newInitialCollateralizedPercent;\n    uint16 private newUndercollateralizedThresholdPercent;\n    uint16 private newSeverelyUndercollateralizedThresholdPercent;\n    address private newKeepStakedFactory;\n    address private newFullyBackedFactory;\n    address private newFactorySelector;\n\n    // price feed\n    uint256 constant priceFeedGovernanceTimeDelay = 90 days;\n    uint256 ethBtcPriceFeedAdditionInitiated;\n    IMedianizer nextEthBtcPriceFeed;\n\n    constructor(address _priceFeed, address _relay) public {\n        priceFeed = ISatWeiPriceFeed(_priceFeed);\n        relay = IRelay(_relay);\n    }\n\n    /// @notice        Initialize contracts\n    /// @dev           Only the Deposit factory should call this, and only once.\n    /// @param _defaultKeepFactory       ECDSA keep factory backed by KEEP stake.\n    /// @param _depositFactory    Deposit Factory. More info in `DepositFactory`.\n    /// @param _masterDepositAddress  Master Deposit address. More info in `Deposit`.\n    /// @param _tbtcToken         TBTCToken. More info in `TBTCToken`.\n    /// @param _tbtcDepositToken  TBTCDepositToken (TDT). More info in `TBTCDepositToken`.\n    /// @param _feeRebateToken    FeeRebateToken (FRT). More info in `FeeRebateToken`.\n    /// @param _keepThreshold     Signing group honesty threshold.\n    /// @param _keepSize          Signing group size.\n    function initialize(\n        IBondedECDSAKeepFactory _defaultKeepFactory,\n        DepositFactory _depositFactory,\n        address payable _masterDepositAddress,\n        TBTCToken _tbtcToken,\n        TBTCDepositToken _tbtcDepositToken,\n        FeeRebateToken _feeRebateToken,\n        VendingMachine _vendingMachine,\n        uint16 _keepThreshold,\n        uint16 _keepSize\n    ) external onlyOwner {\n        require(initializedTimestamp == 0, \"already initialized\");\n\n        keepFactorySelection.initialize(_defaultKeepFactory);\n        keepThreshold = _keepThreshold;\n        keepSize = _keepSize;\n        initializedTimestamp = block.timestamp;\n        allowNewDeposits = true;\n\n        setTbtcDepositToken(_tbtcDepositToken);\n\n        _vendingMachine.setExternalAddresses(\n            _tbtcToken,\n            _tbtcDepositToken,\n            _feeRebateToken\n        );\n        _depositFactory.setExternalDependencies(\n            _masterDepositAddress,\n            this,\n            _tbtcToken,\n            _tbtcDepositToken,\n            _feeRebateToken,\n            address(_vendingMachine)\n        );\n    }\n\n    /// @notice Returns whether new deposits should be allowed.\n    /// @return True if new deposits should be allowed by the emergency pause button\n    function getAllowNewDeposits() external view returns (bool) {\n        return allowNewDeposits;\n    }\n\n    /// @notice Return the lowest lot size currently enabled for deposits.\n    /// @return The lowest lot size, in satoshis.\n    function getMinimumLotSize() public view returns (uint256) {\n        return lotSizesSatoshis[0];\n    }\n\n    /// @notice Return the largest lot size currently enabled for deposits.\n    /// @return The largest lot size, in satoshis.\n    function getMaximumLotSize() external view returns (uint256) {\n        return lotSizesSatoshis[lotSizesSatoshis.length - 1];\n    }\n\n    /// @notice One-time-use emergency function to disallow future deposit creation for 10 days.\n    function emergencyPauseNewDeposits() external onlyOwner {\n        require(pausedTimestamp == 0, \"emergencyPauseNewDeposits can only be called once\");\n        uint256 sinceInit = block.timestamp - initializedTimestamp;\n        require(sinceInit < 180 days, \"emergencyPauseNewDeposits can only be called within 180 days of initialization\");\n        pausedTimestamp = block.timestamp;\n        allowNewDeposits = false;\n        emit AllowNewDepositsUpdated(false);\n    }\n\n    /// @notice Anyone can reactivate deposit creations after the pause duration is over.\n    function resumeNewDeposits() external {\n        require(! allowNewDeposits, \"New deposits are currently allowed\");\n        require(pausedTimestamp != 0, \"Deposit has not been paused\");\n        require(block.timestamp.sub(pausedTimestamp) >= pausedDuration, \"Deposits are still paused\");\n        allowNewDeposits = true;\n        emit AllowNewDepositsUpdated(true);\n    }\n\n    function getRemainingPauseTerm() external view returns (uint256) {\n        require(! allowNewDeposits, \"New deposits are currently allowed\");\n        return (block.timestamp.sub(pausedTimestamp) >= pausedDuration)?\n            0:\n            pausedDuration.sub(block.timestamp.sub(pausedTimestamp));\n    }\n\n    /// @notice Set the system signer fee divisor.\n    /// @dev    This can be finalized by calling `finalizeSignerFeeDivisorUpdate`\n    ///         Anytime after `governanceTimeDelay` has elapsed.\n    /// @param _signerFeeDivisor The signer fee divisor.\n    function beginSignerFeeDivisorUpdate(uint16 _signerFeeDivisor)\n        external onlyOwner\n    {\n        require(\n            _signerFeeDivisor > 9,\n            \"Signer fee divisor must be greater than 9, for a signer fee that is <= 10%\"\n        );\n        require(\n            _signerFeeDivisor < 5000,\n            \"Signer fee divisor must be less than 5000, for a signer fee that is > 0.02%\"\n        );\n\n        newSignerFeeDivisor = _signerFeeDivisor;\n        signerFeeDivisorChangeInitiated = block.timestamp;\n        emit SignerFeeDivisorUpdateStarted(_signerFeeDivisor, block.timestamp);\n    }\n\n    /// @notice Set the allowed deposit lot sizes.\n    /// @dev    Lot size array should always contain 10**8 satoshis (1 BTC) and\n    ///         cannot contain values less than 50000 satoshis (0.0005 BTC) or\n    ///         greater than 10**10 satoshis (100 BTC). Lot size array must not\n    ///         have duplicates and it must be sorted.\n    ///         This can be finalized by calling `finalizeLotSizesUpdate`\n    ///         anytime after `governanceTimeDelay` has elapsed.\n    /// @param _lotSizes Array of allowed lot sizes.\n    function beginLotSizesUpdate(uint64[] calldata _lotSizes)\n        external onlyOwner\n    {\n        bool hasSingleBitcoin = false;\n        for (uint i = 0; i < _lotSizes.length; i++) {\n            if (_lotSizes[i] == 10**8) {\n                hasSingleBitcoin = true;\n            } else if (_lotSizes[i] < 50 * 10**3) {\n                // Failed the minimum requirement, break on out.\n                revert(\"Lot sizes less than 0.0005 BTC are not allowed\");\n            } else if (_lotSizes[i] > 10 * 10**9) {\n                // Failed the maximum requirement, break on out.\n                revert(\"Lot sizes greater than 100 BTC are not allowed\");\n            } else if (i > 0 && _lotSizes[i] == _lotSizes[i-1]) {\n                revert(\"Lot size array must not have duplicates\");\n            } else if (i > 0 && _lotSizes[i] < _lotSizes[i-1]) {\n                revert(\"Lot size array must be sorted\");\n            }\n        }\n\n        require(hasSingleBitcoin, \"Lot size array must always contain 1 BTC\");\n\n        emit LotSizesUpdateStarted(_lotSizes, block.timestamp);\n        newLotSizesSatoshis = _lotSizes;\n        lotSizesChangeInitiated = block.timestamp;\n    }\n\n    /// @notice Set the system collateralization levels\n    /// @dev    This can be finalized by calling `finalizeCollateralizationThresholdsUpdate`\n    ///         Anytime after `governanceTimeDelay` has elapsed.\n    /// @param _initialCollateralizedPercent default signing bond percent for new deposits\n    /// @param _undercollateralizedThresholdPercent first undercollateralization trigger\n    /// @param _severelyUndercollateralizedThresholdPercent second undercollateralization trigger\n    function beginCollateralizationThresholdsUpdate(\n        uint16 _initialCollateralizedPercent,\n        uint16 _undercollateralizedThresholdPercent,\n        uint16 _severelyUndercollateralizedThresholdPercent\n    ) external onlyOwner {\n        require(\n            _initialCollateralizedPercent <= 300,\n            \"Initial collateralized percent must be <= 300%\"\n        );\n        require(\n            _initialCollateralizedPercent > 100,\n            \"Initial collateralized percent must be >= 100%\"\n        );\n        require(\n            _initialCollateralizedPercent > _undercollateralizedThresholdPercent,\n            \"Undercollateralized threshold must be < initial collateralized percent\"\n        );\n        require(\n            _undercollateralizedThresholdPercent > _severelyUndercollateralizedThresholdPercent,\n            \"Severe undercollateralized threshold must be < undercollateralized threshold\"\n        );\n\n        newInitialCollateralizedPercent = _initialCollateralizedPercent;\n        newUndercollateralizedThresholdPercent = _undercollateralizedThresholdPercent;\n        newSeverelyUndercollateralizedThresholdPercent = _severelyUndercollateralizedThresholdPercent;\n        collateralizationThresholdsChangeInitiated = block.timestamp;\n        emit CollateralizationThresholdsUpdateStarted(\n            _initialCollateralizedPercent,\n            _undercollateralizedThresholdPercent,\n            _severelyUndercollateralizedThresholdPercent,\n            block.timestamp\n        );\n    }\n\n    /// @notice Sets the addresses of the KEEP-staked ECDSA keep factory,\n    ///         ETH-only-backed ECDSA keep factory and the selection strategy\n    ///         that will choose between the two factories for new deposits.\n    ///         When the ETH-only-backed factory and strategy are not set TBTCSystem\n    ///         will use KEEP-staked factory. When both factories and strategy\n    ///         are set, TBTCSystem load balances between two factories based on\n    ///         the selection strategy.\n    /// @dev It can be finalized by calling `finalizeKeepFactoriesUpdate`\n    ///      any time after `governanceTimeDelay` has elapsed. This can be\n    ///      called more than once until finalized to reset the values and\n    ///      timer. An update can only be initialized before\n    ///      `keepFactoriesUpgradeabilityPeriod` elapses after system initialization;\n    ///      after that, no further updates can be initialized, though any pending\n    ///      update can be finalized. All calls must set all three properties to\n    ///      their desired value; leaving a value as 0, even if it was previously\n    ///      set, will update that value to be 0. ETH-bond-only factory or the\n    ///      strategy are allowed to be set as zero addresses.\n    /// @param _keepStakedFactory Address of the KEEP staked based factory.\n    /// @param _fullyBackedFactory Address of the ETH-bond-only-based factory.\n    /// @param _factorySelector Address of the keep factory selection strategy.\n    function beginKeepFactoriesUpdate(\n        address _keepStakedFactory,\n        address _fullyBackedFactory,\n        address _factorySelector\n    )\n        external onlyOwner\n    {\n        uint256 sinceInit = block.timestamp - initializedTimestamp;\n        require(\n            sinceInit < keepFactoriesUpgradeabilityPeriod,\n            \"beginKeepFactoriesUpdate can only be called within 180 days of initialization\"\n        );\n\n        // It is required that KEEP staked factory address is configured as this is\n        // a default choice factory. Fully backed factory and factory selector\n        // are optional for the system to work, hence they don't have to be provided.\n        require(\n            _keepStakedFactory != address(0),\n            \"KEEP staked factory must be a nonzero address\"\n        );\n\n        newKeepStakedFactory = _keepStakedFactory;\n        newFullyBackedFactory = _fullyBackedFactory;\n        newFactorySelector = _factorySelector;\n        keepFactoriesUpdateInitiated = block.timestamp;\n\n        emit KeepFactoriesUpdateStarted(\n            _keepStakedFactory,\n            _fullyBackedFactory,\n            _factorySelector,\n            block.timestamp\n        );\n    }\n\n    /// @notice Add a new ETH/BTC price feed contract to the priecFeed.\n    /// @dev This can be finalized by calling `finalizeEthBtcPriceFeedAddition`\n    ///      anytime after `priceFeedGovernanceTimeDelay` has elapsed.\n    function beginEthBtcPriceFeedAddition(IMedianizer _ethBtcPriceFeed) external onlyOwner {\n        bool ethBtcActive;\n        (, ethBtcActive) = _ethBtcPriceFeed.peek();\n        require(ethBtcActive, \"Cannot add inactive feed\");\n\n        nextEthBtcPriceFeed = _ethBtcPriceFeed;\n        ethBtcPriceFeedAdditionInitiated = block.timestamp;\n        emit EthBtcPriceFeedAdditionStarted(address(_ethBtcPriceFeed), block.timestamp);\n    }\n\n    modifier onlyAfterGovernanceDelay(\n        uint256 _changeInitializedTimestamp,\n        uint256 _delay\n    ) {\n        require(_changeInitializedTimestamp > 0, \"Change not initiated\");\n        require(\n            block.timestamp.sub(_changeInitializedTimestamp) >= _delay,\n            \"Governance delay has not elapsed\"\n        );\n        _;\n    }\n\n    /// @notice Finish setting the system signer fee divisor.\n    /// @dev `beginSignerFeeDivisorUpdate` must be called first, once `governanceTimeDelay`\n    ///       has passed, this function can be called to set the signer fee divisor to the\n    ///       value set in `beginSignerFeeDivisorUpdate`\n    function finalizeSignerFeeDivisorUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(signerFeeDivisorChangeInitiated, governanceTimeDelay)\n    {\n        signerFeeDivisor = newSignerFeeDivisor;\n        emit SignerFeeDivisorUpdated(newSignerFeeDivisor);\n        newSignerFeeDivisor = 0;\n        signerFeeDivisorChangeInitiated = 0;\n    }\n    /// @notice Finish setting the accepted system lot sizes.\n    /// @dev `beginLotSizesUpdate` must be called first, once `governanceTimeDelay`\n    ///       has passed, this function can be called to set the lot sizes to the\n    ///       value set in `beginLotSizesUpdate`\n    function finalizeLotSizesUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(lotSizesChangeInitiated, governanceTimeDelay) {\n\n        lotSizesSatoshis = newLotSizesSatoshis;\n        emit LotSizesUpdated(newLotSizesSatoshis);\n        lotSizesChangeInitiated = 0;\n        newLotSizesSatoshis.length = 0;\n\n        refreshMinimumBondableValue();\n    }\n\n    /// @notice Finish setting the system collateralization levels\n    /// @dev `beginCollateralizationThresholdsUpdate` must be called first, once `governanceTimeDelay`\n    ///       has passed, this function can be called to set the collateralization thresholds to the\n    ///       value set in `beginCollateralizationThresholdsUpdate`\n    function finalizeCollateralizationThresholdsUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(\n            collateralizationThresholdsChangeInitiated,\n            governanceTimeDelay\n        ) {\n\n        initialCollateralizedPercent = newInitialCollateralizedPercent;\n        undercollateralizedThresholdPercent = newUndercollateralizedThresholdPercent;\n        severelyUndercollateralizedThresholdPercent = newSeverelyUndercollateralizedThresholdPercent;\n\n        emit CollateralizationThresholdsUpdated(\n            newInitialCollateralizedPercent,\n            newUndercollateralizedThresholdPercent,\n            newSeverelyUndercollateralizedThresholdPercent\n        );\n\n        newInitialCollateralizedPercent = 0;\n        newUndercollateralizedThresholdPercent = 0;\n        newSeverelyUndercollateralizedThresholdPercent = 0;\n        collateralizationThresholdsChangeInitiated = 0;\n    }\n\n    /// @notice Finish setting addresses of the KEEP-staked ECDSA keep factory,\n    ///         ETH-only-backed ECDSA keep factory, and the selection strategy\n    ///         that will choose between the two factories for new deposits.\n    /// @dev `beginKeepFactoriesUpdate` must be called first; once\n    ///      `governanceTimeDelay` has passed, this function can be called to\n    ///      set factories addresses to the values set in `beginKeepFactoriesUpdate`.\n    function finalizeKeepFactoriesUpdate()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(\n            keepFactoriesUpdateInitiated,\n            governanceTimeDelay\n        ) {\n\n        keepFactorySelection.setFactories(\n            newKeepStakedFactory,\n            newFullyBackedFactory,\n            newFactorySelector\n        );\n\n        emit KeepFactoriesUpdated(\n            newKeepStakedFactory,\n            newFullyBackedFactory,\n            newFactorySelector\n        );\n\n        keepFactoriesUpdateInitiated = 0;\n        newKeepStakedFactory = address(0);\n        newFullyBackedFactory = address(0);\n        newFactorySelector = address(0);\n    }\n\n    /// @notice Finish adding a new price feed contract to the priceFeed.\n    /// @dev `beginEthBtcPriceFeedAddition` must be called first; once\n    ///      `ethBtcPriceFeedAdditionInitiated` has passed, this function can be\n    ///      called to append a new price feed.\n    function finalizeEthBtcPriceFeedAddition()\n            external\n            onlyOwner\n            onlyAfterGovernanceDelay(\n                ethBtcPriceFeedAdditionInitiated,\n                priceFeedGovernanceTimeDelay\n            ) {\n        // This process interacts with external contracts, so\n        // Checks-Effects-Interactions it.\n        IMedianizer _nextEthBtcPriceFeed = nextEthBtcPriceFeed;\n        nextEthBtcPriceFeed = IMedianizer(0);\n        ethBtcPriceFeedAdditionInitiated = 0;\n\n        emit EthBtcPriceFeedAdded(address(_nextEthBtcPriceFeed));\n\n        priceFeed.addEthBtcFeed(_nextEthBtcPriceFeed);\n    }\n\n    /// @notice Gets the system signer fee divisor.\n    /// @return The signer fee divisor.\n    function getSignerFeeDivisor() external view returns (uint16) { return signerFeeDivisor; }\n\n    /// @notice Gets the allowed lot sizes\n    /// @return Uint64 array of allowed lot sizes\n    function getAllowedLotSizes() external view returns (uint64[] memory){\n        return lotSizesSatoshis;\n    }\n\n    /// @notice Get the system undercollateralization level for new deposits\n    function getUndercollateralizedThresholdPercent() external view returns (uint16) {\n        return undercollateralizedThresholdPercent;\n    }\n\n    /// @notice Get the system severe undercollateralization level for new deposits\n    function getSeverelyUndercollateralizedThresholdPercent() external view returns (uint16) {\n        return severelyUndercollateralizedThresholdPercent;\n    }\n\n    /// @notice Get the system initial collateralized level for new deposits.\n    function getInitialCollateralizedPercent() external view returns (uint16) {\n        return initialCollateralizedPercent;\n    }\n\n    /// @notice Get the price of one satoshi in wei.\n    /// @dev Reverts if the price of one satoshi is 0 wei, or if the price of\n    ///      one satoshi is 1 ether. Can only be called by a deposit with minted\n    ///      TDT.\n    /// @return The price of one satoshi in wei.\n    function fetchBitcoinPrice() external view returns (uint256) {\n        require(\n            tbtcDepositToken.exists(uint256(msg.sender)),\n            \"Caller must be a Deposit contract\"\n        );\n\n        return _fetchBitcoinPrice();\n    }\n\n    // Difficulty Oracle\n    function fetchRelayCurrentDifficulty() external view returns (uint256) {\n        return relay.getCurrentEpochDifficulty();\n    }\n\n    function fetchRelayPreviousDifficulty() external view returns (uint256) {\n        return relay.getPrevEpochDifficulty();\n    }\n\n    /// @notice Get the time remaining until the signer fee divisor can be updated.\n    function getRemainingSignerFeeDivisorUpdateTime() external view returns (uint256) {\n        return getRemainingChangeTime(\n            signerFeeDivisorChangeInitiated,\n            governanceTimeDelay\n        );\n    }\n\n    /// @notice Get the time remaining until the lot sizes can be updated.\n    function getRemainingLotSizesUpdateTime() external view returns (uint256) {\n        return getRemainingChangeTime(\n            lotSizesChangeInitiated,\n            governanceTimeDelay\n        );\n    }\n\n    /// @notice Get the time remaining until the collateralization thresholds can be updated.\n    function getRemainingCollateralizationThresholdsUpdateTime() external view returns (uint256) {\n        return getRemainingChangeTime(\n            collateralizationThresholdsChangeInitiated,\n            governanceTimeDelay\n        );\n    }\n\n    /// @notice Get the time remaining until the Keep ETH-only-backed ECDSA keep\n    ///         factory and the selection strategy that will choose between it\n    ///         and the KEEP-backed factory can be updated.\n    function getRemainingKeepFactoriesUpdateTime() external view returns (uint256) {\n        return getRemainingChangeTime(\n            keepFactoriesUpdateInitiated,\n            governanceTimeDelay\n        );\n    }\n\n    /// @notice Get the time remaining until the signer fee divisor can be updated.\n    function getRemainingEthBtcPriceFeedAdditionTime() external view returns (uint256) {\n        return getRemainingChangeTime(\n            ethBtcPriceFeedAdditionInitiated,\n            priceFeedGovernanceTimeDelay\n        );\n    }\n\n    /// @notice Get the time remaining until Keep factories can no longer be updated.\n    function getRemainingKeepFactoriesUpgradeabilityTime() external view returns (uint256) {\n        return getRemainingChangeTime(\n            initializedTimestamp,\n            keepFactoriesUpgradeabilityPeriod\n        );\n    }\n\n    /// @notice Refreshes the minimum bondable value required from the operator\n    /// to join the sortition pool for tBTC. The minimum bondable value is\n    /// equal to the current minimum lot size collateralized 150% multiplied by\n    /// the current BTC price.\n    /// @dev It is recommended to call this function on tBTC initialization and\n    /// after minimum lot size update.\n    function refreshMinimumBondableValue() public {\n        keepFactorySelection.setMinimumBondableValue(\n            calculateBondRequirementWei(getMinimumLotSize()),\n            keepSize,\n            keepThreshold\n        );\n    }\n\n    /// @notice Returns the time delay used for governance actions except for\n    ///         price feed additions.\n    function getGovernanceTimeDelay() external pure returns (uint256) {\n        return governanceTimeDelay;\n    }\n\n    /// @notice Returns the time period when keep factories upgrades are allowed.\n    function getKeepFactoriesUpgradeabilityPeriod() public pure returns (uint256) {\n        return keepFactoriesUpgradeabilityPeriod;\n    }\n\n    /// @notice Returns the time delay used for price feed addition governance\n    ///         actions.\n    function getPriceFeedGovernanceTimeDelay() external pure returns (uint256) {\n        return priceFeedGovernanceTimeDelay;\n    }\n\n    /// @notice Gets a fee estimate for creating a new Deposit.\n    /// @return Uint256 estimate.\n    function getNewDepositFeeEstimate()\n        external\n        view\n        returns (uint256)\n    {\n        IBondedECDSAKeepFactory _keepFactory = keepFactorySelection.selectFactory();\n        return _keepFactory.openKeepFeeEstimate();\n    }\n\n    /// @notice Request a new keep opening.\n    /// @param _requestedLotSizeSatoshis Lot size in satoshis.\n    /// @param _maxSecuredLifetime Duration of stake lock in seconds.\n    /// @return Address of a new keep.\n    function requestNewKeep(\n        uint64 _requestedLotSizeSatoshis,\n        uint256 _maxSecuredLifetime\n    )\n        external\n        payable\n        returns (address)\n    {\n        require(tbtcDepositToken.exists(uint256(msg.sender)), \"Caller must be a Deposit contract\");\n        require(isAllowedLotSize(_requestedLotSizeSatoshis), \"provided lot size not supported\");\n\n        IBondedECDSAKeepFactory _keepFactory = keepFactorySelection.selectFactoryAndRefresh();\n        uint256 bond = calculateBondRequirementWei(_requestedLotSizeSatoshis);\n        return _keepFactory.openKeep.value(msg.value)(keepSize, keepThreshold, msg.sender, bond, _maxSecuredLifetime);\n    }\n\n    /// @notice Check if a lot size is allowed.\n    /// @param _requestedLotSizeSatoshis Lot size to check.\n    /// @return True if lot size is allowed, false otherwise.\n    function isAllowedLotSize(uint64 _requestedLotSizeSatoshis) public view returns (bool){\n        for( uint i = 0; i < lotSizesSatoshis.length; i++){\n            if (lotSizesSatoshis[i] == _requestedLotSizeSatoshis){\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice Calculates bond requirement in wei for the given lot size in\n    ///         satoshis based on the current ETHBTC price.\n    /// @param _requestedLotSizeSatoshis Lot size in satoshis.\n    /// @return Bond requirement in wei.\n    function calculateBondRequirementWei(\n        uint256 _requestedLotSizeSatoshis\n    ) internal view returns (uint256) {\n        uint256 lotSizeInWei = _fetchBitcoinPrice().mul(_requestedLotSizeSatoshis);\n        return lotSizeInWei.mul(initialCollateralizedPercent).div(100);\n    }\n\n    function _fetchBitcoinPrice() internal view returns (uint256) {\n        uint256 price = priceFeed.getPrice();\n        if (price == 0 || price > 10 ** 18) {\n            // This is if a sat is worth 0 wei, or is worth >1 ether. Revert at\n            // once.\n            revert(\"System returned a bad price\");\n        }\n        return price;\n    }\n\n    /// @notice Get the time remaining until the function parameter timer value can be updated.\n    function getRemainingChangeTime(\n        uint256 _changeTimestamp,\n        uint256 _delayAmount\n    ) internal view returns (uint256){\n        require(_changeTimestamp > 0, \"Update not initiated\");\n        uint256 elapsed = block.timestamp.sub(_changeTimestamp);\n        if (elapsed >= _delayAmount) {\n            return 0;\n        } else {\n            return _delayAmount.sub(elapsed);\n        }\n    }\n}\n"
    },
    "solidity/contracts/interfaces/ITBTCSystem.sol": {
      "content": "pragma solidity 0.5.17;\n\n/**\n * @title Keep interface\n */\n\ninterface ITBTCSystem {\n\n    // expected behavior:\n    // return the price of 1 sat in wei\n    // these are the native units of the deposit contract\n    function fetchBitcoinPrice() external view returns (uint256);\n\n    // passthrough requests for the oracle\n    function fetchRelayCurrentDifficulty() external view returns (uint256);\n    function fetchRelayPreviousDifficulty() external view returns (uint256);\n    function getNewDepositFeeEstimate() external view returns (uint256);\n    function getAllowNewDeposits() external view returns (bool);\n    function isAllowedLotSize(uint64 _requestedLotSizeSatoshis) external view returns (bool);\n    function requestNewKeep(uint64 _requestedLotSizeSatoshis, uint256 _maxSecuredLifetime) external payable returns (address);\n    function getSignerFeeDivisor() external view returns (uint16);\n    function getInitialCollateralizedPercent() external view returns (uint16);\n    function getUndercollateralizedThresholdPercent() external view returns (uint16);\n    function getSeverelyUndercollateralizedThresholdPercent() external view returns (uint16);\n}\n"
    },
    "solidity/contracts/deposit/Deposit.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {DepositLiquidation} from \"./DepositLiquidation.sol\";\nimport {DepositUtils} from \"./DepositUtils.sol\";\nimport {DepositFunding} from \"./DepositFunding.sol\";\nimport {DepositRedemption} from \"./DepositRedemption.sol\";\nimport {DepositStates} from \"./DepositStates.sol\";\nimport {ITBTCSystem} from \"../interfaces/ITBTCSystem.sol\";\nimport {IERC721} from \"openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\";\nimport {TBTCToken} from \"../system/TBTCToken.sol\";\nimport {FeeRebateToken} from \"../system/FeeRebateToken.sol\";\n\nimport \"../system/DepositFactoryAuthority.sol\";\n\n// solium-disable function-order\n// Below, a few functions must be public to allow bytes memory parameters, but\n// their being so triggers errors because public functions should be grouped\n// below external functions. Since these would be external if it were possible,\n// we ignore the issue.\n\n/// @title  tBTC Deposit\n/// @notice This is the main contract for tBTC. It is the state machine that\n///         (through various libraries) handles bitcoin funding, bitcoin-spv\n///         proofs, redemption, liquidation, and fraud logic.\n/// @dev This contract presents a public API that exposes the following\n///      libraries:\n///\n///       - `DepositFunding`\n///       - `DepositLiquidaton`\n///       - `DepositRedemption`,\n///       - `DepositStates`\n///       - `DepositUtils`\n///       - `OutsourceDepositLogging`\n///       - `TBTCConstants`\n///\n///      Where these libraries require deposit state, this contract's state\n///      variable `self` is used. `self` is a struct of type\n///      `DepositUtils.Deposit` that contains all aspects of the deposit state\n///      itself.\ncontract Deposit is DepositFactoryAuthority {\n\n    using DepositRedemption for DepositUtils.Deposit;\n    using DepositFunding for DepositUtils.Deposit;\n    using DepositLiquidation for DepositUtils.Deposit;\n    using DepositUtils for DepositUtils.Deposit;\n    using DepositStates for DepositUtils.Deposit;\n\n    DepositUtils.Deposit self;\n\n    /// @dev Deposit should only be _constructed_ once. New deposits are created\n    ///      using the `DepositFactory.createDeposit` method, and are clones of\n    ///      the constructed deposit. The factory will set the initial values\n    ///      for a new clone using `initializeDeposit`.\n    constructor () public {\n        // The constructed Deposit will never be used, so the deposit factory\n        // address can be anything. Clones are updated as per above.\n        initialize(address(0xdeadbeef));\n    }\n\n    /// @notice Deposits do not accept arbitrary ETH.\n    function () external payable {\n        require(msg.data.length == 0, \"Deposit contract was called with unknown function selector.\");\n    }\n\n//----------------------------- METADATA LOOKUP ------------------------------//\n\n    /// @notice Get this deposit's BTC lot size in satoshis.\n    /// @return uint64 lot size in satoshis.\n    function lotSizeSatoshis() external view returns (uint64){\n        return self.lotSizeSatoshis;\n    }\n\n    /// @notice Get this deposit's lot size in TBTC.\n    /// @dev This is the same as lotSizeSatoshis(), but is multiplied to scale\n    ///      to 18 decimal places.\n    /// @return uint256 lot size in TBTC precision (max 18 decimal places).\n    function lotSizeTbtc() external view returns (uint256){\n        return self.lotSizeTbtc();\n    }\n\n    /// @notice Get the signer fee for this deposit, in TBTC.\n    /// @dev This is the one-time fee required by the signers to perform the\n    ///      tasks needed to maintain a decentralized and trustless model for\n    ///      tBTC. It is a percentage of the deposit's lot size.\n    /// @return Fee amount in TBTC.\n    function signerFeeTbtc() external view returns (uint256) {\n        return self.signerFeeTbtc();\n    }\n\n    /// @notice Get the integer representing the current state.\n    /// @dev We implement this because contracts don't handle foreign enums\n    ///      well. See `DepositStates` for more info on states.\n    /// @return The 0-indexed state from the DepositStates enum.\n    function currentState() external view returns (uint256) {\n        return uint256(self.currentState);\n    }\n\n    /// @notice Check if the Deposit is in ACTIVE state.\n    /// @return True if state is ACTIVE, false otherwise.\n    function inActive() external view returns (bool) {\n        return self.inActive();\n    }\n\n    /// @notice Get the contract address of the BondedECDSAKeep associated with\n    ///         this Deposit.\n    /// @dev The keep contract address is saved on Deposit initialization.\n    /// @return Address of the Keep contract.\n    function keepAddress() external view returns (address) {\n        return self.keepAddress;\n    }\n\n    /// @notice Retrieve the remaining term of the deposit in seconds.\n    /// @dev The value accuracy is not guaranteed since block.timestmap can be\n    ///      lightly manipulated by miners.\n    /// @return The remaining term of the deposit in seconds. 0 if already at\n    ///         term.\n    function remainingTerm() external view returns(uint256){\n        return self.remainingTerm();\n    }\n\n    /// @notice Get the current collateralization level for this Deposit.\n    /// @dev This value represents the percentage of the backing BTC value the\n    ///      signers currently must hold as bond.\n    /// @return The current collateralization level for this deposit.\n    function collateralizationPercentage() external view returns (uint256) {\n        return self.collateralizationPercentage();\n    }\n\n    /// @notice Get the initial collateralization level for this Deposit.\n    /// @dev This value represents the percentage of the backing BTC value\n    ///      the signers hold initially. It is set at creation time.\n    /// @return The initial collateralization level for this deposit.\n    function initialCollateralizedPercent() external view returns (uint16) {\n        return self.initialCollateralizedPercent;\n    }\n\n    /// @notice Get the undercollateralization level for this Deposit.\n    /// @dev This collateralization level is semi-critical. If the\n    ///      collateralization level falls below this percentage the Deposit can\n    ///      be courtesy-called by calling `notifyCourtesyCall`. This value\n    ///      represents the percentage of the backing BTC value the signers must\n    ///      hold as bond in order to not be undercollateralized. It is set at\n    ///      creation time. Note that the value for new deposits in TBTCSystem\n    ///      can be changed by governance, but the value for a particular\n    ///      deposit is static once the deposit is created.\n    /// @return The undercollateralized level for this deposit.\n    function undercollateralizedThresholdPercent() external view returns (uint16) {\n        return self.undercollateralizedThresholdPercent;\n    }\n\n    /// @notice Get the severe undercollateralization level for this Deposit.\n    /// @dev This collateralization level is critical. If the collateralization\n    ///      level falls below this percentage the Deposit can get liquidated.\n    ///      This value represents the percentage of the backing BTC value the\n    ///      signers must hold as bond in order to not be severely\n    ///      undercollateralized. It is set at creation time. Note that the\n    ///      value for new deposits in TBTCSystem can be changed by governance,\n    ///      but the value for a particular deposit is static once the deposit\n    ///      is created.\n    /// @return The severely undercollateralized level for this deposit.\n    function severelyUndercollateralizedThresholdPercent() external view returns (uint16) {\n        return self.severelyUndercollateralizedThresholdPercent;\n    }\n\n    /// @notice Get the value of the funding UTXO.\n    /// @dev This call will revert if the deposit is not in a state where the\n    ///      UTXO info should be valid. In particular, before funding proof is\n    ///      successfully submitted (i.e. in states START,\n    ///      AWAITING_SIGNER_SETUP, and AWAITING_BTC_FUNDING_PROOF), this value\n    ///      would not be valid.\n    /// @return The value of the funding UTXO in satoshis.\n    function utxoValue() external view returns (uint256){\n        require(\n            ! self.inFunding(),\n            \"Deposit has not yet been funded and has no available funding info\"\n        );\n\n        return self.utxoValue();\n    }\n\n    /// @notice Returns information associated with the funding UXTO.\n    /// @dev This call will revert if the deposit is not in a state where the\n    ///      funding info should be valid. In particular, before funding proof\n    ///      is successfully submitted (i.e. in states START,\n    ///      AWAITING_SIGNER_SETUP, and AWAITING_BTC_FUNDING_PROOF), none of\n    ///      these values are set or valid.\n    /// @return A tuple of (uxtoValueBytes, fundedAt, uxtoOutpoint).\n    function fundingInfo() external view returns (bytes8 utxoValueBytes, uint256 fundedAt, bytes memory utxoOutpoint) {\n        require(\n            ! self.inFunding(),\n            \"Deposit has not yet been funded and has no available funding info\"\n        );\n\n        return (self.utxoValueBytes, self.fundedAt, self.utxoOutpoint);\n    }\n\n    /// @notice Calculates the amount of value at auction right now.\n    /// @dev This call will revert if the deposit is not in a state where an\n    ///      auction is currently in progress.\n    /// @return The value in wei that would be received in exchange for the\n    ///         deposit's lot size in TBTC if `purchaseSignerBondsAtAuction`\n    ///         were called at the time this function is called.\n    function auctionValue() external view returns (uint256) {\n        require(\n            self.inSignerLiquidation(),\n            \"Deposit has no funds currently at auction\"\n        );\n\n        return self.auctionValue();\n    }\n\n    /// @notice Get caller's ETH withdraw allowance.\n    /// @dev Generally ETH is only available to withdraw after the deposit\n    ///      reaches a closed state. The amount reported is for the sender, and\n    ///      can be withdrawn using `withdrawFunds` if the deposit is in an end\n    ///      state.\n    /// @return The withdraw allowance in wei.\n    function withdrawableAmount() external view returns (uint256) {\n        return self.getWithdrawableAmount();\n    }\n\n//------------------------------ FUNDING FLOW --------------------------------//\n\n    /// @notice Notify the contract that signing group setup has timed out if\n    ///         retrieveSignerPubkey is not successfully called within the\n    ///         allotted time.\n    /// @dev This is considered a signer fault, and the signers' bonds are used\n    ///      to make the deposit setup fee available for withdrawal by the TDT\n    ///      holder as a refund. The remainder of the signers' bonds are\n    ///      returned to the bonding pool and the signers are released from any\n    ///      further responsibilities. Reverts if the deposit is not awaiting\n    ///      signer setup or if the signing group formation timeout has not\n    ///      elapsed.\n    function notifySignerSetupFailed() external {\n        self.notifySignerSetupFailed();\n    }\n\n    /// @notice Notify the contract that the ECDSA keep has generated a public\n    ///         key so the deposit contract can pull it in.\n    /// @dev Stores the pubkey as 2 bytestrings, X and Y. Emits a\n    ///      RegisteredPubkey event with the two components. Reverts if the\n    ///      deposit is not awaiting signer setup, if the generated public key\n    ///      is unset or has incorrect length, or if the public key has a 0\n    ///      X or Y value.\n    function retrieveSignerPubkey() external {\n        self.retrieveSignerPubkey();\n    }\n\n    /// @notice Notify the contract that the funding phase of the deposit has\n    ///         timed out if `provideBTCFundingProof` is not successfully called\n    ///         within the allotted time. Any sent BTC is left under control of\n    ///         the signer group, and the funder can use `requestFunderAbort` to\n    ///         request an at-signer-discretion return of any BTC sent to a\n    ///         deposit that has been notified of a funding timeout.\n    /// @dev This is considered a funder fault, and the funder's payment for\n    ///      opening the deposit is not refunded. Emits a SetupFailed event.\n    ///      Reverts if the funding timeout has not yet elapsed, or if the\n    ///      deposit is not currently awaiting funding proof.\n    function notifyFundingTimedOut() external {\n        self.notifyFundingTimedOut();\n    }\n\n    /// @notice Requests a funder abort for a failed-funding deposit; that is,\n    ///         requests the return of a sent UTXO to _abortOutputScript. It\n    ///         imposes no requirements on the signing group. Signers should\n    ///         send their UTXO to the requested output script, but do so at\n    ///         their discretion and with no penalty for failing to do so. This\n    ///         can be used for example when a UTXO is sent that is the wrong\n    ///         size for the lot.\n    /// @dev This is a self-admitted funder fault, and is only be callable by\n    ///      the TDT holder. This function emits the FunderAbortRequested event,\n    ///      but stores no additional state.\n    /// @param _abortOutputScript The output script the funder wishes to request\n    ///        a return of their UTXO to.\n    function requestFunderAbort(bytes memory _abortOutputScript) public { // not external to allow bytes memory parameters\n        require(\n            self.depositOwner() == msg.sender,\n            \"Only TDT holder can request funder abort\"\n        );\n\n        self.requestFunderAbort(_abortOutputScript);\n    }\n\n    /// @notice Anyone can provide a signature corresponding to the signers'\n    ///         public key to prove fraud during funding. Note that during\n    ///         funding no signature has been requested from the signers, so\n    ///         any signature is effectively fraud.\n    /// @dev Calls out to the keep to verify if there was fraud.\n    /// @param _v Signature recovery value.\n    /// @param _r Signature R value.\n    /// @param _s Signature S value.\n    /// @param _signedDigest The digest signed by the signature (v,r,s) tuple.\n    /// @param _preimage The sha256 preimage of the digest.\n    function provideFundingECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public { // not external to allow bytes memory parameters\n        self.provideFundingECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n    }\n\n    /// @notice Anyone may submit a funding proof to the deposit showing that\n    ///         a transaction was submitted and sufficiently confirmed on the\n    ///         Bitcoin chain transferring the deposit lot size's amount of BTC\n    ///         to the signer-controlled private key corresopnding to this\n    ///         deposit. This will move the deposit into an active state.\n    /// @dev Takes a pre-parsed transaction and calculates values needed to\n    ///      verify funding.\n    /// @param _txVersion Transaction version number (4-byte little-endian).\n    /// @param _txInputVector All transaction inputs prepended by the number of\n    ///        inputs encoded as a VarInt, max 0xFC(252) inputs.\n    /// @param _txOutputVector All transaction outputs prepended by the number\n    ///         of outputs encoded as a VarInt, max 0xFC(252) outputs.\n    /// @param _txLocktime Final 4 bytes of the transaction.\n    /// @param _fundingOutputIndex Index of funding output in _txOutputVector\n    ///        (0-indexed).\n    /// @param _merkleProof The merkle proof of transaction inclusion in a\n    ///        block.\n    /// @param _txIndexInBlock Transaction index in the block (0-indexed).\n    /// @param _bitcoinHeaders Single bytestring of 80-byte bitcoin headers,\n    ///        lowest height first.\n    function provideBTCFundingProof(\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public { // not external to allow bytes memory parameters\n        self.provideBTCFundingProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n    }\n\n//---------------------------- LIQUIDATION FLOW ------------------------------//\n\n    /// @notice Notify the contract that the signers are undercollateralized.\n    /// @dev This call will revert if the signers are not in fact\n    ///      undercollateralized according to the price feed. After\n    ///      TBTCConstants.COURTESY_CALL_DURATION, courtesy call times out and\n    ///      regular abort liquidation occurs; see\n    ///      `notifyCourtesyTimedOut`.\n    function notifyCourtesyCall() external {\n        self.notifyCourtesyCall();\n    }\n\n    /// @notice Notify the contract that the signers' bond value has recovered\n    ///         enough to be considered sufficiently collateralized.\n    /// @dev This call will revert if collateral is still below the\n    ///      undercollateralized threshold according to the price feed.\n    function exitCourtesyCall() external {\n        self.exitCourtesyCall();\n    }\n\n    /// @notice Notify the contract that the courtesy period has expired and the\n    ///         deposit should move into liquidation.\n    /// @dev This call will revert if the courtesy call period has not in fact\n    ///      expired or is not in the courtesy call state. Courtesy call\n    ///      expiration is treated as an abort, and is handled by seizing signer\n    ///      bonds and putting them up for auction for the lot size amount in\n    ///      TBTC (see `purchaseSignerBondsAtAuction`). Emits a\n    ///      LiquidationStarted event. The caller is captured as the liquidation\n    ///      initiator, and is eligible for 50% of any bond left after the\n    ///      auction is completed.\n    function notifyCourtesyCallExpired() external {\n        self.notifyCourtesyCallExpired();\n    }\n\n    /// @notice Notify the contract that the signers are undercollateralized.\n    /// @dev Calls out to the system for oracle info.\n    /// @dev This call will revert if the signers are not in fact severely\n    ///      undercollateralized according to the price feed. Severe\n    ///      undercollateralization is treated as an abort, and is handled by\n    ///      seizing signer bonds and putting them up for auction in exchange\n    ///      for the lot size amount in TBTC (see\n    ///      `purchaseSignerBondsAtAuction`). Emits a LiquidationStarted event.\n    ///      The caller is captured as the liquidation initiator, and is\n    ///      eligible for 50% of any bond left after the auction is completed.\n    function notifyUndercollateralizedLiquidation() external {\n        self.notifyUndercollateralizedLiquidation();\n    }\n\n    /// @notice Anyone can provide a signature corresponding to the signers'\n    ///         public key that was not requested to prove fraud. A redemption\n    ///         request and a redemption fee increase are the only ways to\n    ///         request a signature from the signers.\n    /// @dev This call will revert if the underlying keep cannot verify that\n    ///      there was fraud. Fraud is handled by seizing signer bonds and\n    ///      putting them up for auction in exchange for the lot size amount in\n    ///      TBTC (see `purchaseSignerBondsAtAuction`). Emits a\n    ///      LiquidationStarted event. The caller is captured as the liquidation\n    ///      initiator, and is eligible for any bond left after the auction is\n    ///      completed.\n    /// @param  _v Signature recovery value.\n    /// @param  _r Signature R value.\n    /// @param  _s Signature S value.\n    /// @param _signedDigest The digest signed by the signature (v,r,s) tuple.\n    /// @param _preimage The sha256 preimage of the digest.\n    function provideECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public { // not external to allow bytes memory parameters\n        self.provideECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n    }\n\n    /// @notice Notify the contract that the signers have failed to produce a\n    ///         signature for a redemption request in the allotted time.\n    /// @dev This is considered an abort, and is punished by seizing signer\n    ///      bonds and putting them up for auction. Emits a LiquidationStarted\n    ///      event and a Liquidated event and sends the full signer bond to the\n    ///      redeemer. Reverts if the deposit is not currently awaiting a\n    ///      signature or if the allotted time has not yet elapsed. The caller\n    ///      is captured as the liquidation initiator, and is eligible for 50%\n    ///      of any bond left after the auction is completed.\n    function notifyRedemptionSignatureTimedOut() external {\n        self.notifyRedemptionSignatureTimedOut();\n    }\n\n    /// @notice Notify the contract that the deposit has failed to receive a\n    ///         redemption proof in the allotted time.\n    /// @dev This call will revert if the deposit is not currently awaiting a\n    ///      signature or if the allotted time has not yet elapsed. This is\n    ///      considered an abort, and is punished by seizing signer bonds and\n    ///      putting them up for auction for the lot size amount in TBTC (see\n    ///      `purchaseSignerBondsAtAuction`). Emits a LiquidationStarted event.\n    ///      The caller is captured as the liquidation initiator, and\n    ///      is eligible for 50% of any bond left after the auction is\n    ///     completed.\n    function notifyRedemptionProofTimedOut() external {\n        self.notifyRedemptionProofTimedOut();\n    }\n\n    /// @notice Closes an auction and purchases the signer bonds by transferring\n    ///         the lot size in TBTC to the redeemer, if there is one, or to the\n    ///         TDT holder if not. Any bond amount that is not currently up for\n    ///         auction is either made available for the liquidation initiator\n    ///         to withdraw (for fraud) or split 50-50 between the initiator and\n    ///         the signers (for abort or collateralization issues).\n    /// @dev The amount of ETH given for the transferred TBTC can be read using\n    ///      the `auctionValue` function; note, however, that the function's\n    ///      value is only static during the specific block it is queried, as it\n    ///      varies by block timestamp.\n    function purchaseSignerBondsAtAuction() external {\n        self.purchaseSignerBondsAtAuction();\n    }\n\n//---------------------------- REDEMPTION FLOW -------------------------------//\n\n    /// @notice Get TBTC amount required for redemption by a specified\n    ///         _redeemer.\n    /// @dev This call will revert if redemption is not possible by _redeemer.\n    /// @param _redeemer The deposit redeemer whose TBTC requirement is being\n    ///        requested.\n    /// @return The amount in TBTC needed by the `_redeemer` to redeem the\n    ///         deposit.\n    function getRedemptionTbtcRequirement(address _redeemer) external view returns (uint256){\n        (uint256 tbtcPayment,,) = self.calculateRedemptionTbtcAmounts(_redeemer, false);\n        return tbtcPayment;\n    }\n\n    /// @notice Get TBTC amount required for redemption assuming _redeemer\n    ///         is this deposit's owner (TDT holder).\n    /// @param _redeemer The assumed owner of the deposit's TDT .\n    /// @return The amount in TBTC needed to redeem the deposit.\n    function getOwnerRedemptionTbtcRequirement(address _redeemer) external view returns (uint256){\n        (uint256 tbtcPayment,,) = self.calculateRedemptionTbtcAmounts(_redeemer, true);\n        return tbtcPayment;\n    }\n\n    /// @notice Requests redemption of this deposit, meaning the transmission,\n    ///         by the signers, of the deposit's UTXO to the specified Bitocin\n    ///         output script. Requires approving the deposit to spend the\n    ///         amount of TBTC needed to redeem.\n    /// @dev The amount of TBTC needed to redeem can be looked up using the\n    ///      `getRedemptionTbtcRequirement` or `getOwnerRedemptionTbtcRequirement`\n    ///      functions.\n    /// @param  _outputValueBytes The 8-byte little-endian output size. The\n    ///         difference between this value and the lot size of the deposit\n    ///         will be paid as a fee to the Bitcoin miners when the signed\n    ///         transaction is broadcast.\n    /// @param  _redeemerOutputScript The redeemer's length-prefixed output\n    ///         script.\n    function requestRedemption(\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript\n    ) public { // not external to allow bytes memory parameters\n        self.requestRedemption(_outputValueBytes, _redeemerOutputScript);\n    }\n\n    /// @notice Anyone may provide a withdrawal signature if it was requested.\n    /// @dev The signers will be penalized if this function is not called\n    ///      correctly within `TBTCConstants.REDEMPTION_SIGNATURE_TIMEOUT`\n    ///      seconds of a redemption request or fee increase being received.\n    /// @param _v Signature recovery value.\n    /// @param _r Signature R value.\n    /// @param _s Signature S value. Should be in the low half of secp256k1\n    ///        curve's order.\n    function provideRedemptionSignature(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        self.provideRedemptionSignature(_v, _r, _s);\n    }\n\n    /// @notice Anyone may request a signature for a transaction with an\n    ///         increased Bitcoin transaction fee.\n    /// @dev This call will revert if the fee is already at its maximum, or if\n    ///      the new requested fee is not a multiple of the initial requested\n    ///      fee. Transaction fees can only be bumped by the amount of the\n    ///      initial requested fee. Calling this sends the deposit back to\n    ///      the `AWAITING_WITHDRAWAL_SIGNATURE` state and requires the signers\n    ///      to `provideRedemptionSignature` for the new output value in a\n    ///      timely fashion.\n    /// @param _previousOutputValueBytes The previous output's value.\n    /// @param _newOutputValueBytes The new output's value.\n    function increaseRedemptionFee(\n        bytes8 _previousOutputValueBytes,\n        bytes8 _newOutputValueBytes\n    ) external {\n        self.increaseRedemptionFee(_previousOutputValueBytes, _newOutputValueBytes);\n    }\n\n    /// @notice Anyone may submit a redemption proof to the deposit showing that\n    ///         a transaction was submitted and sufficiently confirmed on the\n    ///         Bitcoin chain transferring the deposit lot size's amount of BTC\n    ///         from the signer-controlled private key corresponding to this\n    ///         deposit to the requested redemption output script. This will\n    ///         move the deposit into a redeemed state.\n    /// @dev Takes a pre-parsed transaction and calculates values needed to\n    ///      verify funding. Signers can have their bonds seized if this is not\n    ///      called within `TBTCConstants.REDEMPTION_PROOF_TIMEOUT` seconds of\n    ///      a redemption signature being provided.\n    /// @param _txVersion Transaction version number (4-byte little-endian).\n    /// @param _txInputVector All transaction inputs prepended by the number of\n    ///        inputs encoded as a VarInt, max 0xFC(252) inputs.\n    /// @param _txOutputVector All transaction outputs prepended by the number\n    ///         of outputs encoded as a VarInt, max 0xFC(252) outputs.\n    /// @param _txLocktime Final 4 bytes of the transaction.\n    /// @param _merkleProof The merkle proof of transaction inclusion in a\n    ///        block.\n    /// @param _txIndexInBlock Transaction index in the block (0-indexed).\n    /// @param _bitcoinHeaders Single bytestring of 80-byte bitcoin headers,\n    ///        lowest height first.\n    function provideRedemptionProof(\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public { // not external to allow bytes memory parameters\n        self.provideRedemptionProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n    }\n\n//--------------------------- MUTATING HELPERS -------------------------------//\n\n    /// @notice This function can only be called by the deposit factory; use\n    ///         `DepositFactory.createDeposit` to create a new deposit.\n    /// @dev Initializes a new deposit clone with the base state for the\n    ///      deposit.\n    /// @param _tbtcSystem `TBTCSystem` contract. More info in `TBTCSystem`.\n    /// @param _tbtcToken `TBTCToken` contract. More info in TBTCToken`.\n    /// @param _tbtcDepositToken `TBTCDepositToken` (TDT) contract. More info in\n    ///        `TBTCDepositToken`.\n    /// @param _feeRebateToken `FeeRebateToken` (FRT) contract. More info in\n    ///        `FeeRebateToken`.\n    /// @param _vendingMachineAddress `VendingMachine` address. More info in\n    ///        `VendingMachine`.\n    /// @param _lotSizeSatoshis The minimum amount of satoshi the funder is\n    ///                         required to send. This is also the amount of\n    ///                         TBTC the TDT holder will be eligible to mint:\n    ///                         (10**7 satoshi == 0.1 BTC == 0.1 TBTC).\n    function initializeDeposit(\n        ITBTCSystem _tbtcSystem,\n        TBTCToken _tbtcToken,\n        IERC721 _tbtcDepositToken,\n        FeeRebateToken _feeRebateToken,\n        address _vendingMachineAddress,\n        uint64 _lotSizeSatoshis\n    ) public onlyFactory payable {\n        self.tbtcSystem = _tbtcSystem;\n        self.tbtcToken = _tbtcToken;\n        self.tbtcDepositToken = _tbtcDepositToken;\n        self.feeRebateToken = _feeRebateToken;\n        self.vendingMachineAddress = _vendingMachineAddress;\n        self.initialize(_lotSizeSatoshis);\n    }\n\n    /// @notice This function can only be called by the vending machine.\n    /// @dev Performs the same action as requestRedemption, but transfers\n    ///      ownership of the deposit to the specified _finalRecipient. Used as\n    ///      a utility helper for the vending machine's shortcut\n    ///      TBTC->redemption path.\n    /// @param  _outputValueBytes The 8-byte little-endian output size.\n    /// @param  _redeemerOutputScript The redeemer's length-prefixed output script.\n    /// @param  _finalRecipient     The address to receive the TDT and later be recorded as deposit redeemer.\n    function transferAndRequestRedemption(\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public { // not external to allow bytes memory parameters\n        require(\n            msg.sender == self.vendingMachineAddress,\n            \"Only the vending machine can call transferAndRequestRedemption\"\n        );\n        self.transferAndRequestRedemption(\n            _outputValueBytes,\n            _redeemerOutputScript,\n            _finalRecipient\n        );\n    }\n\n    /// @notice Withdraw the ETH balance of the deposit allotted to the caller.\n    /// @dev Withdrawals can only happen when a contract is in an end-state.\n    function withdrawFunds() external {\n        self.withdrawFunds();\n    }\n}\n"
    },
    "@summa-tx/bitcoin-spv-sol/contracts/BTCUtils.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/** @title BitcoinSPV */\n/** @author Summa (https://summa.one) */\n\nimport {BytesLib} from \"./BytesLib.sol\";\nimport {SafeMath} from \"./SafeMath.sol\";\n\nlibrary BTCUtils {\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n\n    // The target at minimum Difficulty. Also the target of the genesis block\n    uint256 public constant DIFF1_TARGET = 0xffff0000000000000000000000000000000000000000000000000000;\n\n    uint256 public constant RETARGET_PERIOD = 2 * 7 * 24 * 60 * 60;  // 2 weeks in seconds\n    uint256 public constant RETARGET_PERIOD_BLOCKS = 2016;  // 2 weeks in blocks\n\n    uint256 public constant ERR_BAD_ARG = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /* ***** */\n    /* UTILS */\n    /* ***** */\n\n    /// @notice         Determines the length of a VarInt in bytes\n    /// @dev            A VarInt of >1 byte is prefixed with a flag indicating its length\n    /// @param _flag    The first byte of a VarInt\n    /// @return         The number of non-flag bytes in the VarInt\n    function determineVarIntDataLength(bytes memory _flag) internal pure returns (uint8) {\n        if (uint8(_flag[0]) == 0xff) {\n            return 8;  // one-byte flag, 8 bytes data\n        }\n        if (uint8(_flag[0]) == 0xfe) {\n            return 4;  // one-byte flag, 4 bytes data\n        }\n        if (uint8(_flag[0]) == 0xfd) {\n            return 2;  // one-byte flag, 2 bytes data\n        }\n\n        return 0;  // flag is data\n    }\n\n    /// @notice     Parse a VarInt into its data length and the number it represents\n    /// @dev        Useful for Parsing Vins and Vouts. Returns ERR_BAD_ARG if insufficient bytes.\n    ///             Caller SHOULD explicitly handle this case (or bubble it up)\n    /// @param _b   A byte-string starting with a VarInt\n    /// @return     number of bytes in the encoding (not counting the tag), the encoded int\n    function parseVarInt(bytes memory _b) internal pure returns (uint256, uint256) {\n        uint8 _dataLen = determineVarIntDataLength(_b);\n\n        if (_dataLen == 0) {\n            return (0, uint8(_b[0]));\n        }\n        if (_b.length < 1 + _dataLen) {\n            return (ERR_BAD_ARG, 0);\n        }\n        uint256 _number = bytesToUint(reverseEndianness(_b.slice(1, _dataLen)));\n        return (_dataLen, _number);\n    }\n\n    /// @notice          Changes the endianness of a byte array\n    /// @dev             Returns a new, backwards, bytes\n    /// @param _b        The bytes to reverse\n    /// @return          The reversed bytes\n    function reverseEndianness(bytes memory _b) internal pure returns (bytes memory) {\n        bytes memory _newValue = new bytes(_b.length);\n\n        for (uint i = 0; i < _b.length; i++) {\n            _newValue[_b.length - i - 1] = _b[i];\n        }\n\n        return _newValue;\n    }\n\n    /// @notice          Changes the endianness of a uint256\n    /// @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n    /// @param _b        The unsigned integer to reverse\n    /// @return          The reversed value\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v = ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n        // swap 2-byte long pairs\n        v = ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n        // swap 4-byte long pairs\n        v = ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n        // swap 8-byte long pairs\n        v = ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    /// @notice          Converts big-endian bytes to a uint\n    /// @dev             Traverses the byte array and sums the bytes\n    /// @param _b        The big-endian bytes-encoded integer\n    /// @return          The integer representation\n    function bytesToUint(bytes memory _b) internal pure returns (uint256) {\n        uint256 _number;\n\n        for (uint i = 0; i < _b.length; i++) {\n            _number = _number + uint8(_b[i]) * (2 ** (8 * (_b.length - (i + 1))));\n        }\n\n        return _number;\n    }\n\n    /// @notice          Get the last _num bytes from a byte array\n    /// @param _b        The byte array to slice\n    /// @param _num      The number of bytes to extract from the end\n    /// @return          The last _num bytes of _b\n    function lastBytes(bytes memory _b, uint256 _num) internal pure returns (bytes memory) {\n        uint256 _start = _b.length.sub(_num);\n\n        return _b.slice(_start, _num);\n    }\n\n    /// @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n    /// @dev             abi.encodePacked changes the return to bytes instead of bytes32\n    /// @param _b        The pre-image\n    /// @return          The digest\n    function hash160(bytes memory _b) internal pure returns (bytes memory) {\n        return abi.encodePacked(ripemd160(abi.encodePacked(sha256(_b))));\n    }\n\n    /// @notice          Implements bitcoin's hash256 (double sha2)\n    /// @dev             abi.encodePacked changes the return to bytes instead of bytes32\n    /// @param _b        The pre-image\n    /// @return          The digest\n    function hash256(bytes memory _b) internal pure returns (bytes32) {\n        return sha256(abi.encodePacked(sha256(_b)));\n    }\n\n    /// @notice          Implements bitcoin's hash256 (double sha2)\n    /// @dev             sha2 is precompiled smart contract located at address(2)\n    /// @param _b        The pre-image\n    /// @return          The digest\n    function hash256View(bytes memory _b) internal view returns (bytes32 res) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            pop(staticcall(gas, 2, add(_b, 32), mload(_b), ptr, 32))\n            pop(staticcall(gas, 2, ptr, 32, ptr, 32))\n            res := mload(ptr)\n        }\n    }\n\n    /* ************ */\n    /* Legacy Input */\n    /* ************ */\n\n    /// @notice          Extracts the nth input from the vin (0-indexed)\n    /// @dev             Iterates over the vin. If you need to extract several, write a custom function\n    /// @param _vin      The vin as a tightly-packed byte array\n    /// @param _index    The 0-indexed location of the input to extract\n    /// @return          The input as a byte array\n    function extractInputAtIndex(bytes memory _vin, uint256 _index) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _nIns;\n\n        (_varIntDataLen, _nIns) = parseVarInt(_vin);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Read overrun during VarInt parsing\");\n        require(_index < _nIns, \"Vin read overrun\");\n\n        bytes memory _remaining;\n\n        uint256 _len = 0;\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 _i = 0; _i < _index; _i ++) {\n            _remaining = _vin.slice(_offset, _vin.length - _offset);\n            _len = determineInputLength(_remaining);\n            require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n            _offset = _offset + _len;\n        }\n\n        _remaining = _vin.slice(_offset, _vin.length - _offset);\n        _len = determineInputLength(_remaining);\n        require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n        return _vin.slice(_offset, _len);\n    }\n\n    /// @notice          Determines whether an input is legacy\n    /// @dev             False if no scriptSig, otherwise True\n    /// @param _input    The input\n    /// @return          True for legacy, False for witness\n    function isLegacyInput(bytes memory _input) internal pure returns (bool) {\n        return _input.keccak256Slice(36, 1) != keccak256(hex\"00\");\n    }\n\n    /// @notice          Determines the length of a scriptSig in an input\n    /// @dev             Will return 0 if passed a witness input.\n    /// @param _input    The LEGACY input\n    /// @return          The length of the script sig\n    function extractScriptSigLen(bytes memory _input) internal pure returns (uint256, uint256) {\n        if (_input.length < 37) {\n            return (ERR_BAD_ARG, 0);\n        }\n        bytes memory _afterOutpoint = _input.slice(36, _input.length - 36);\n\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = parseVarInt(_afterOutpoint);\n\n        return (_varIntDataLen, _scriptSigLen);\n    }\n\n    /// @notice          Determines the length of an input from its scriptSig\n    /// @dev             36 for outpoint, 1 for scriptSig length, 4 for sequence\n    /// @param _input    The input\n    /// @return          The length of the input in bytes\n    function determineInputLength(bytes memory _input) internal pure returns (uint256) {\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\n        if (_varIntDataLen == ERR_BAD_ARG) {\n            return ERR_BAD_ARG;\n        }\n\n        return 36 + 1 + _varIntDataLen + _scriptSigLen + 4;\n    }\n\n    /// @notice          Extracts the LE sequence bytes from an input\n    /// @dev             Sequence is used for relative time locks\n    /// @param _input    The LEGACY input\n    /// @return          The sequence bytes (LE uint)\n    function extractSequenceLELegacy(bytes memory _input) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n        return _input.slice(36 + 1 + _varIntDataLen + _scriptSigLen, 4);\n    }\n\n    /// @notice          Extracts the sequence from the input\n    /// @dev             Sequence is a 4-byte little-endian number\n    /// @param _input    The LEGACY input\n    /// @return          The sequence number (big-endian uint)\n    function extractSequenceLegacy(bytes memory _input) internal pure returns (uint32) {\n        bytes memory _leSeqence = extractSequenceLELegacy(_input);\n        bytes memory _beSequence = reverseEndianness(_leSeqence);\n        return uint32(bytesToUint(_beSequence));\n    }\n    /// @notice          Extracts the VarInt-prepended scriptSig from the input in a tx\n    /// @dev             Will return hex\"00\" if passed a witness input\n    /// @param _input    The LEGACY input\n    /// @return          The length-prepended scriptSig\n    function extractScriptSig(bytes memory _input) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n        return _input.slice(36, 1 + _varIntDataLen + _scriptSigLen);\n    }\n\n\n    /* ************* */\n    /* Witness Input */\n    /* ************* */\n\n    /// @notice          Extracts the LE sequence bytes from an input\n    /// @dev             Sequence is used for relative time locks\n    /// @param _input    The WITNESS input\n    /// @return          The sequence bytes (LE uint)\n    function extractSequenceLEWitness(bytes memory _input) internal pure returns (bytes memory) {\n        return _input.slice(37, 4);\n    }\n\n    /// @notice          Extracts the sequence from the input in a tx\n    /// @dev             Sequence is a 4-byte little-endian number\n    /// @param _input    The WITNESS input\n    /// @return          The sequence number (big-endian uint)\n    function extractSequenceWitness(bytes memory _input) internal pure returns (uint32) {\n        bytes memory _leSeqence = extractSequenceLEWitness(_input);\n        bytes memory _inputeSequence = reverseEndianness(_leSeqence);\n        return uint32(bytesToUint(_inputeSequence));\n    }\n\n    /// @notice          Extracts the outpoint from the input in a tx\n    /// @dev             32-byte tx id with 4-byte index\n    /// @param _input    The input\n    /// @return          The outpoint (LE bytes of prev tx hash + LE bytes of prev tx index)\n    function extractOutpoint(bytes memory _input) internal pure returns (bytes memory) {\n        return _input.slice(0, 36);\n    }\n\n    /// @notice          Extracts the outpoint tx id from an input\n    /// @dev             32-byte tx id\n    /// @param _input    The input\n    /// @return          The tx id (little-endian bytes)\n    function extractInputTxIdLE(bytes memory _input) internal pure returns (bytes32) {\n        return _input.slice(0, 32).toBytes32();\n    }\n\n    /// @notice          Extracts the LE tx input index from the input in a tx\n    /// @dev             4-byte tx index\n    /// @param _input    The input\n    /// @return          The tx index (little-endian bytes)\n    function extractTxIndexLE(bytes memory _input) internal pure returns (bytes memory) {\n        return _input.slice(32, 4);\n    }\n\n    /* ****** */\n    /* Output */\n    /* ****** */\n\n    /// @notice          Determines the length of an output\n    /// @dev             Works with any properly formatted output\n    /// @param _output   The output\n    /// @return          The length indicated by the prefix, error if invalid length\n    function determineOutputLength(bytes memory _output) internal pure returns (uint256) {\n        if (_output.length < 9) {\n            return ERR_BAD_ARG;\n        }\n        bytes memory _afterValue = _output.slice(8, _output.length - 8);\n\n        uint256 _varIntDataLen;\n        uint256 _scriptPubkeyLength;\n        (_varIntDataLen, _scriptPubkeyLength) = parseVarInt(_afterValue);\n\n        if (_varIntDataLen == ERR_BAD_ARG) {\n            return ERR_BAD_ARG;\n        }\n\n        // 8-byte value, 1-byte for tag itself\n        return 8 + 1 + _varIntDataLen + _scriptPubkeyLength;\n    }\n\n    /// @notice          Extracts the output at a given index in the TxOuts vector\n    /// @dev             Iterates over the vout. If you need to extract multiple, write a custom function\n    /// @param _vout     The _vout to extract from\n    /// @param _index    The 0-indexed location of the output to extract\n    /// @return          The specified output\n    function extractOutputAtIndex(bytes memory _vout, uint256 _index) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _nOuts;\n\n        (_varIntDataLen, _nOuts) = parseVarInt(_vout);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Read overrun during VarInt parsing\");\n        require(_index < _nOuts, \"Vout read overrun\");\n\n        bytes memory _remaining;\n\n        uint256 _len = 0;\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 _i = 0; _i < _index; _i ++) {\n            _remaining = _vout.slice(_offset, _vout.length - _offset);\n            _len = determineOutputLength(_remaining);\n            require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptPubkey\");\n            _offset += _len;\n        }\n\n        _remaining = _vout.slice(_offset, _vout.length - _offset);\n        _len = determineOutputLength(_remaining);\n        require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptPubkey\");\n        return _vout.slice(_offset, _len);\n    }\n\n    /// @notice          Extracts the value bytes from the output in a tx\n    /// @dev             Value is an 8-byte little-endian number\n    /// @param _output   The output\n    /// @return          The output value as LE bytes\n    function extractValueLE(bytes memory _output) internal pure returns (bytes memory) {\n        return _output.slice(0, 8);\n    }\n\n    /// @notice          Extracts the value from the output in a tx\n    /// @dev             Value is an 8-byte little-endian number\n    /// @param _output   The output\n    /// @return          The output value\n    function extractValue(bytes memory _output) internal pure returns (uint64) {\n        bytes memory _leValue = extractValueLE(_output);\n        bytes memory _beValue = reverseEndianness(_leValue);\n        return uint64(bytesToUint(_beValue));\n    }\n\n    /// @notice          Extracts the data from an op return output\n    /// @dev             Returns hex\"\" if no data or not an op return\n    /// @param _output   The output\n    /// @return          Any data contained in the opreturn output, null if not an op return\n    function extractOpReturnData(bytes memory _output) internal pure returns (bytes memory) {\n        if (_output.keccak256Slice(9, 1) != keccak256(hex\"6a\")) {\n            return hex\"\";\n        }\n        bytes memory _dataLen = _output.slice(10, 1);\n        return _output.slice(11, bytesToUint(_dataLen));\n    }\n\n    /// @notice          Extracts the hash from the output script\n    /// @dev             Determines type by the length prefix and validates format\n    /// @param _output   The output\n    /// @return          The hash committed to by the pk_script, or null for errors\n    function extractHash(bytes memory _output) internal pure returns (bytes memory) {\n        uint8 _scriptLen = uint8(_output[8]);\n\n        // don't have to worry about overflow here.\n        // if _scriptLen + 9 overflows, then output.length would have to be < 9\n        // for this check to pass. if it's < 9, then we errored when assigning\n        // _scriptLen\n        if (_scriptLen + 9 != _output.length) {\n            return hex\"\";\n        }\n\n        if (uint8(_output[9]) == 0) {\n            if (_scriptLen < 2) {\n                return hex\"\";\n            }\n            uint256 _payloadLen = uint8(_output[10]);\n            // Check for maliciously formatted witness outputs.\n            // No need to worry about underflow as long b/c of the `< 2` check\n            if (_payloadLen != _scriptLen - 2 || (_payloadLen != 0x20 && _payloadLen != 0x14)) {\n                return hex\"\";\n            }\n            return _output.slice(11, _payloadLen);\n        } else {\n            bytes32 _tag = _output.keccak256Slice(8, 3);\n            // p2pkh\n            if (_tag == keccak256(hex\"1976a9\")) {\n                // Check for maliciously formatted p2pkh\n                // No need to worry about underflow, b/c of _scriptLen check\n                if (uint8(_output[11]) != 0x14 ||\n                    _output.keccak256Slice(_output.length - 2, 2) != keccak256(hex\"88ac\")) {\n                    return hex\"\";\n                }\n                return _output.slice(12, 20);\n            //p2sh\n            } else if (_tag == keccak256(hex\"17a914\")) {\n                // Check for maliciously formatted p2sh\n                // No need to worry about underflow, b/c of _scriptLen check\n                if (uint8(_output[_output.length - 1]) != 0x87) {\n                    return hex\"\";\n                }\n                return _output.slice(11, 20);\n            }\n        }\n        return hex\"\";  /* NB: will trigger on OPRETURN and any non-standard that doesn't overrun */\n    }\n\n    /* ********** */\n    /* Witness TX */\n    /* ********** */\n\n\n    /// @notice      Checks that the vin passed up is properly formatted\n    /// @dev         Consider a vin with a valid vout in its scriptsig\n    /// @param _vin  Raw bytes length-prefixed input vector\n    /// @return      True if it represents a validly formatted vin\n    function validateVin(bytes memory _vin) internal pure returns (bool) {\n        uint256 _varIntDataLen;\n        uint256 _nIns;\n\n        (_varIntDataLen, _nIns) = parseVarInt(_vin);\n\n        // Not valid if it says there are too many or no inputs\n        if (_nIns == 0 || _varIntDataLen == ERR_BAD_ARG) {\n            return false;\n        }\n\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 i = 0; i < _nIns; i++) {\n            // If we're at the end, but still expect more\n            if (_offset >= _vin.length) {\n                return false;\n            }\n\n            // Grab the next input and determine its length.\n            bytes memory _next = _vin.slice(_offset, _vin.length - _offset);\n            uint256 _nextLen = determineInputLength(_next);\n            if (_nextLen == ERR_BAD_ARG) {\n                return false;\n            }\n\n            // Increase the offset by that much\n            _offset += _nextLen;\n        }\n\n        // Returns false if we're not exactly at the end\n        return _offset == _vin.length;\n    }\n\n    /// @notice      Checks that the vout passed up is properly formatted\n    /// @dev         Consider a vout with a valid scriptpubkey\n    /// @param _vout Raw bytes length-prefixed output vector\n    /// @return      True if it represents a validly formatted vout\n    function validateVout(bytes memory _vout) internal pure returns (bool) {\n        uint256 _varIntDataLen;\n        uint256 _nOuts;\n\n        (_varIntDataLen, _nOuts) = parseVarInt(_vout);\n\n        // Not valid if it says there are too many or no outputs\n        if (_nOuts == 0 || _varIntDataLen == ERR_BAD_ARG) {\n            return false;\n        }\n\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 i = 0; i < _nOuts; i++) {\n            // If we're at the end, but still expect more\n            if (_offset >= _vout.length) {\n                return false;\n            }\n\n            // Grab the next output and determine its length.\n            // Increase the offset by that much\n            bytes memory _next = _vout.slice(_offset, _vout.length - _offset);\n            uint256 _nextLen = determineOutputLength(_next);\n            if (_nextLen == ERR_BAD_ARG) {\n                return false;\n            }\n\n            _offset += _nextLen;\n        }\n\n        // Returns false if we're not exactly at the end\n        return _offset == _vout.length;\n    }\n\n\n\n    /* ************ */\n    /* Block Header */\n    /* ************ */\n\n    /// @notice          Extracts the transaction merkle root from a block header\n    /// @dev             Use verifyHash256Merkle to verify proofs with this root\n    /// @param _header   The header\n    /// @return          The merkle root (little-endian)\n    function extractMerkleRootLE(bytes memory _header) internal pure returns (bytes memory) {\n        return _header.slice(36, 32);\n    }\n\n    /// @notice          Extracts the target from a block header\n    /// @dev             Target is a 256-bit number encoded as a 3-byte mantissa and 1-byte exponent\n    /// @param _header   The header\n    /// @return          The target threshold\n    function extractTarget(bytes memory _header) internal pure returns (uint256) {\n        bytes memory _m = _header.slice(72, 3);\n        uint8 _e = uint8(_header[75]);\n        uint256 _mantissa = bytesToUint(reverseEndianness(_m));\n        uint _exponent = _e - 3;\n\n        return _mantissa * (256 ** _exponent);\n    }\n\n    /// @notice          Calculate difficulty from the difficulty 1 target and current target\n    /// @dev             Difficulty 1 is 0x1d00ffff on mainnet and testnet\n    /// @dev             Difficulty 1 is a 256-bit number encoded as a 3-byte mantissa and 1-byte exponent\n    /// @param _target   The current target\n    /// @return          The block difficulty (bdiff)\n    function calculateDifficulty(uint256 _target) internal pure returns (uint256) {\n        // Difficulty 1 calculated from 0x1d00ffff\n        return DIFF1_TARGET.div(_target);\n    }\n\n    /// @notice          Extracts the previous block's hash from a block header\n    /// @dev             Block headers do NOT include block number :(\n    /// @param _header   The header\n    /// @return          The previous block's hash (little-endian)\n    function extractPrevBlockLE(bytes memory _header) internal pure returns (bytes memory) {\n        return _header.slice(4, 32);\n    }\n\n    /// @notice          Extracts the timestamp from a block header\n    /// @dev             Time is not 100% reliable\n    /// @param _header   The header\n    /// @return          The timestamp (little-endian bytes)\n    function extractTimestampLE(bytes memory _header) internal pure returns (bytes memory) {\n        return _header.slice(68, 4);\n    }\n\n    /// @notice          Extracts the timestamp from a block header\n    /// @dev             Time is not 100% reliable\n    /// @param _header   The header\n    /// @return          The timestamp (uint)\n    function extractTimestamp(bytes memory _header) internal pure returns (uint32) {\n        return uint32(bytesToUint(reverseEndianness(extractTimestampLE(_header))));\n    }\n\n    /// @notice          Extracts the expected difficulty from a block header\n    /// @dev             Does NOT verify the work\n    /// @param _header   The header\n    /// @return          The difficulty as an integer\n    function extractDifficulty(bytes memory _header) internal pure returns (uint256) {\n        return calculateDifficulty(extractTarget(_header));\n    }\n\n    /// @notice          Concatenates and hashes two inputs for merkle proving\n    /// @param _a        The first hash\n    /// @param _b        The second hash\n    /// @return          The double-sha256 of the concatenated hashes\n    function _hash256MerkleStep(bytes memory _a, bytes memory _b) internal pure returns (bytes32) {\n        return hash256(abi.encodePacked(_a, _b));\n    }\n\n    /// @notice          Verifies a Bitcoin-style merkle tree\n    /// @dev             Leaves are 0-indexed.\n    /// @param _proof    The proof. Tightly packed LE sha256 hashes. The last hash is the root\n    /// @param _index    The index of the leaf\n    /// @return          true if the proof is valid, else false\n    function verifyHash256Merkle(bytes memory _proof, uint _index) internal pure returns (bool) {\n        // Not an even number of hashes\n        if (_proof.length % 32 != 0) {\n            return false;\n        }\n\n        // Special case for coinbase-only blocks\n        if (_proof.length == 32) {\n            return true;\n        }\n\n        // Should never occur\n        if (_proof.length == 64) {\n            return false;\n        }\n\n        uint _idx = _index;\n        bytes32 _root = _proof.slice(_proof.length - 32, 32).toBytes32();\n        bytes32 _current = _proof.slice(0, 32).toBytes32();\n\n        for (uint i = 1; i < (_proof.length.div(32)) - 1; i++) {\n            if (_idx % 2 == 1) {\n                _current = _hash256MerkleStep(_proof.slice(i * 32, 32), abi.encodePacked(_current));\n            } else {\n                _current = _hash256MerkleStep(abi.encodePacked(_current), _proof.slice(i * 32, 32));\n            }\n            _idx = _idx >> 1;\n        }\n        return _current == _root;\n    }\n\n    /*\n    NB: https://github.com/bitcoin/bitcoin/blob/78dae8caccd82cfbfd76557f1fb7d7557c7b5edb/src/pow.cpp#L49-L72\n    NB: We get a full-bitlength target from this. For comparison with\n        header-encoded targets we need to mask it with the header target\n        e.g. (full & truncated) == truncated\n    */\n    /// @notice                 performs the bitcoin difficulty retarget\n    /// @dev                    implements the Bitcoin algorithm precisely\n    /// @param _previousTarget  the target of the previous period\n    /// @param _firstTimestamp  the timestamp of the first block in the difficulty period\n    /// @param _secondTimestamp the timestamp of the last block in the difficulty period\n    /// @return                 the new period's target threshold\n    function retargetAlgorithm(\n        uint256 _previousTarget,\n        uint256 _firstTimestamp,\n        uint256 _secondTimestamp\n    ) internal pure returns (uint256) {\n        uint256 _elapsedTime = _secondTimestamp.sub(_firstTimestamp);\n\n        // Normalize ratio to factor of 4 if very long or very short\n        if (_elapsedTime < RETARGET_PERIOD.div(4)) {\n            _elapsedTime = RETARGET_PERIOD.div(4);\n        }\n        if (_elapsedTime > RETARGET_PERIOD.mul(4)) {\n            _elapsedTime = RETARGET_PERIOD.mul(4);\n        }\n\n        /*\n          NB: high targets e.g. ffff0020 can cause overflows here\n              so we divide it by 256**2, then multiply by 256**2 later\n              we know the target is evenly divisible by 256**2, so this isn't an issue\n        */\n\n        uint256 _adjusted = _previousTarget.div(65536).mul(_elapsedTime);\n        return _adjusted.div(RETARGET_PERIOD).mul(65536);\n    }\n}\n"
    },
    "@summa-tx/bitcoin-spv-sol/contracts/BytesLib.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/*\n\nhttps://github.com/GNSPS/solidity-bytes-utils/\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <https://unlicense.org>\n*/\n\n\n/** @title BytesLib **/\n/** @author https://github.com/GNSPS **/\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n                add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes_slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                        ),\n                        // and now shift left the number of bytes to\n                        // leave space for the length in the slot\n                        exp(0x100, sub(32, newlength))\n                        ),\n                        // increase length by the double of the memory\n                        // bytes length\n                        mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                    ),\n                    and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(bytes memory _bytes, uint _start, uint _length) internal  pure returns (bytes memory res) {\n        if (_length == 0) {\n            return hex\"\";\n        }\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            // Alloc bytes array with additional 32 bytes afterspace and assign it's size\n            res := mload(0x40)\n            mstore(0x40, add(add(res, 64), _length))\n            mstore(res, _length)\n\n            // Compute distance between source and destination pointers\n            let diff := sub(res, add(_bytes, _start))\n\n            for {\n                let src := add(add(_bytes, 32), _start)\n                let end := add(src, _length)\n            } lt(src, end) {\n                src := add(src, 32)\n            } {\n                mstore(add(src, diff), mload(src))\n            }\n        }\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n        uint _totalLen = _start + 20;\n        require(_totalLen > _start && _bytes.length >= _totalLen, \"Address conversion out of bounds.\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n        uint _totalLen = _start + 32;\n        require(_totalLen > _start && _bytes.length >= _totalLen, \"Uint conversion out of bounds.\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function toBytes32(bytes memory _source) pure internal returns (bytes32 result) {\n        if (_source.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(_source, 32))\n        }\n    }\n\n    function keccak256Slice(bytes memory _bytes, uint _start, uint _length) pure internal returns (bytes32 result) {\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            result := keccak256(add(add(_bytes, 32), _start), _length)\n        }\n    }\n}\n"
    },
    "@summa-tx/bitcoin-spv-sol/contracts/SafeMath.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        c = _a * _b;\n        require(c / _a == _b, \"Overflow during multiplication.\");\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // assert(_b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, \"Underflow during subtraction.\");\n        return _a - _b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n        c = _a + _b;\n        require(c >= _a, \"Overflow during addition.\");\n        return c;\n    }\n}\n"
    },
    "@keep-network/keep-ecdsa/contracts/api/IBondedECDSAKeep.sol": {
      "content": "/**\n     \n   \n                            \n                             \n                           \n                           \n                          \n     \n     \n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\n/// @title ECDSA Keep\n/// @notice Contract reflecting an ECDSA keep.\ncontract IBondedECDSAKeep {\n    /// @notice Returns public key of this keep.\n    /// @return Keeps's public key.\n    function getPublicKey() external view returns (bytes memory);\n\n    /// @notice Returns the amount of the keep's ETH bond in wei.\n    /// @return The amount of the keep's ETH bond in wei.\n    function checkBondAmount() external view returns (uint256);\n\n    /// @notice Calculates a signature over provided digest by the keep. Note that\n    /// signatures from the keep not explicitly requested by calling `sign`\n    /// will be provable as fraud via `submitSignatureFraud`.\n    /// @param _digest Digest to be signed.\n    function sign(bytes32 _digest) external;\n\n    /// @notice Distributes ETH reward evenly across keep signer beneficiaries.\n    /// @dev Only the value passed to this function is distributed.\n    function distributeETHReward() external payable;\n\n    /// @notice Distributes ERC20 reward evenly across keep signer beneficiaries.\n    /// @dev This works with any ERC20 token that implements a transferFrom\n    /// function.\n    /// This function only has authority over pre-approved\n    /// token amount. We don't explicitly check for allowance, SafeMath\n    /// subtraction overflow is enough protection.\n    /// @param _tokenAddress Address of the ERC20 token to distribute.\n    /// @param _value Amount of ERC20 token to distribute.\n    function distributeERC20Reward(address _tokenAddress, uint256 _value)\n        external;\n\n    /// @notice Seizes the signers' ETH bonds. After seizing bonds keep is\n    /// terminated so it will no longer respond to signing requests. Bonds can\n    /// be seized only when there is no signing in progress or requested signing\n    /// process has timed out. This function seizes all of signers' bonds.\n    /// The application may decide to return part of bonds later after they are\n    /// processed using returnPartialSignerBonds function.\n    function seizeSignerBonds() external;\n\n    /// @notice Returns partial signer's ETH bonds to the pool as an unbounded\n    /// value. This function is called after bonds have been seized and processed\n    /// by the privileged application after calling seizeSignerBonds function.\n    /// It is entirely up to the application if a part of signers' bonds is\n    /// returned. The application may decide for that but may also decide to\n    /// seize bonds and do not return anything.\n    function returnPartialSignerBonds() external payable;\n\n    /// @notice Submits a fraud proof for a valid signature from this keep that was\n    /// not first approved via a call to sign.\n    /// @dev The function expects the signed digest to be calculated as a sha256\n    /// hash of the preimage: `sha256(_preimage)`.\n    /// @param _v Signature's header byte: `27 + recoveryID`.\n    /// @param _r R part of ECDSA signature.\n    /// @param _s S part of ECDSA signature.\n    /// @param _signedDigest Digest for the provided signature. Result of hashing\n    /// the preimage.\n    /// @param _preimage Preimage of the hashed message.\n    /// @return True if fraud, error otherwise.\n    function submitSignatureFraud(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    )\n        external returns (bool _isFraud);\n\n    /// @notice Closes keep when no longer needed. Releases bonds to the keep\n    /// members. Keep can be closed only when there is no signing in progress or\n    /// requested signing process has timed out.\n    /// @dev The function can be called only by the owner of the keep and only\n    /// if the keep has not been already closed.\n    function closeKeep() external;\n}\n"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"
    },
    "solidity/contracts/deposit/DepositStates.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {DepositUtils} from \"./DepositUtils.sol\";\n\nlibrary DepositStates {\n\n    enum States {\n        // DOES NOT EXIST YET\n        START,\n\n        // FUNDING FLOW\n        AWAITING_SIGNER_SETUP,\n        AWAITING_BTC_FUNDING_PROOF,\n\n        // FAILED SETUP\n        FAILED_SETUP,\n\n        // ACTIVE\n        ACTIVE,  // includes courtesy call\n\n        // REDEMPTION FLOW\n        AWAITING_WITHDRAWAL_SIGNATURE,\n        AWAITING_WITHDRAWAL_PROOF,\n        REDEEMED,\n\n        // SIGNER LIQUIDATION FLOW\n        COURTESY_CALL,\n        FRAUD_LIQUIDATION_IN_PROGRESS,\n        LIQUIDATION_IN_PROGRESS,\n        LIQUIDATED\n    }\n\n    /// @notice     Check if the contract is currently in the funding flow.\n    /// @dev        This checks on the funding flow happy path, not the fraud path.\n    /// @param _d   Deposit storage pointer.\n    /// @return     True if contract is currently in the funding flow else False.\n    function inFunding(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return (\n            _d.currentState == uint8(States.AWAITING_SIGNER_SETUP)\n         || _d.currentState == uint8(States.AWAITING_BTC_FUNDING_PROOF)\n        );\n    }\n\n    /// @notice     Check if the contract is currently in the signer liquidation flow.\n    /// @dev        This could be caused by fraud, or by an unfilled margin call.\n    /// @param _d   Deposit storage pointer.\n    /// @return     True if contract is currently in the liquidaton flow else False.\n    function inSignerLiquidation(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return (\n            _d.currentState == uint8(States.LIQUIDATION_IN_PROGRESS)\n         || _d.currentState == uint8(States.FRAUD_LIQUIDATION_IN_PROGRESS)\n        );\n    }\n\n    /// @notice     Check if the contract is currently in the redepmtion flow.\n    /// @dev        This checks on the redemption flow, not the REDEEMED termination state.\n    /// @param _d   Deposit storage pointer.\n    /// @return     True if contract is currently in the redemption flow else False.\n    function inRedemption(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return (\n            _d.currentState == uint8(States.AWAITING_WITHDRAWAL_SIGNATURE)\n         || _d.currentState == uint8(States.AWAITING_WITHDRAWAL_PROOF)\n        );\n    }\n\n    /// @notice     Check if the contract has halted.\n    /// @dev        This checks on any halt state, regardless of triggering circumstances.\n    /// @param _d   Deposit storage pointer.\n    /// @return     True if contract has halted permanently.\n    function inEndState(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return (\n            _d.currentState == uint8(States.LIQUIDATED)\n         || _d.currentState == uint8(States.REDEEMED)\n         || _d.currentState == uint8(States.FAILED_SETUP)\n        );\n    }\n\n    /// @notice     Check if the contract is available for a redemption request.\n    /// @dev        Redemption is available from active and courtesy call.\n    /// @param _d   Deposit storage pointer.\n    /// @return     True if available, False otherwise.\n    function inRedeemableState(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return (\n            _d.currentState == uint8(States.ACTIVE)\n         || _d.currentState == uint8(States.COURTESY_CALL)\n        );\n    }\n\n    /// @notice     Check if the contract is currently in the start state (awaiting setup).\n    /// @dev        This checks on the funding flow happy path, not the fraud path.\n    /// @param _d   Deposit storage pointer.\n    /// @return     True if contract is currently in the start state else False.\n    function inStart(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return (_d.currentState == uint8(States.START));\n    }\n\n    function inAwaitingSignerSetup(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return _d.currentState == uint8(States.AWAITING_SIGNER_SETUP);\n    }\n\n    function inAwaitingBTCFundingProof(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return _d.currentState == uint8(States.AWAITING_BTC_FUNDING_PROOF);\n    }\n\n    function inFailedSetup(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return _d.currentState == uint8(States.FAILED_SETUP);\n    }\n\n    function inActive(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return _d.currentState == uint8(States.ACTIVE);\n    }\n\n    function inAwaitingWithdrawalSignature(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return _d.currentState == uint8(States.AWAITING_WITHDRAWAL_SIGNATURE);\n    }\n\n    function inAwaitingWithdrawalProof(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return _d.currentState == uint8(States.AWAITING_WITHDRAWAL_PROOF);\n    }\n\n    function inRedeemed(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return _d.currentState == uint8(States.REDEEMED);\n    }\n\n    function inCourtesyCall(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return _d.currentState == uint8(States.COURTESY_CALL);\n    }\n\n    function inFraudLiquidationInProgress(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return _d.currentState == uint8(States.FRAUD_LIQUIDATION_IN_PROGRESS);\n    }\n\n    function inLiquidationInProgress(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return _d.currentState == uint8(States.LIQUIDATION_IN_PROGRESS);\n    }\n\n    function inLiquidated(DepositUtils.Deposit storage _d) external view returns (bool) {\n        return _d.currentState == uint8(States.LIQUIDATED);\n    }\n\n    function setAwaitingSignerSetup(DepositUtils.Deposit storage _d) external {\n        _d.currentState = uint8(States.AWAITING_SIGNER_SETUP);\n    }\n\n    function setAwaitingBTCFundingProof(DepositUtils.Deposit storage _d) external {\n        _d.currentState = uint8(States.AWAITING_BTC_FUNDING_PROOF);\n    }\n\n    function setFailedSetup(DepositUtils.Deposit storage _d) external {\n        _d.currentState = uint8(States.FAILED_SETUP);\n    }\n\n    function setActive(DepositUtils.Deposit storage _d) external {\n        _d.currentState = uint8(States.ACTIVE);\n    }\n\n    function setAwaitingWithdrawalSignature(DepositUtils.Deposit storage _d) external {\n        _d.currentState = uint8(States.AWAITING_WITHDRAWAL_SIGNATURE);\n    }\n\n    function setAwaitingWithdrawalProof(DepositUtils.Deposit storage _d) external {\n        _d.currentState = uint8(States.AWAITING_WITHDRAWAL_PROOF);\n    }\n\n    function setRedeemed(DepositUtils.Deposit storage _d) external {\n        _d.currentState = uint8(States.REDEEMED);\n    }\n\n    function setCourtesyCall(DepositUtils.Deposit storage _d) external {\n        _d.currentState = uint8(States.COURTESY_CALL);\n    }\n\n    function setFraudLiquidationInProgress(DepositUtils.Deposit storage _d) external {\n        _d.currentState = uint8(States.FRAUD_LIQUIDATION_IN_PROGRESS);\n    }\n\n    function setLiquidationInProgress(DepositUtils.Deposit storage _d) external {\n        _d.currentState = uint8(States.LIQUIDATION_IN_PROGRESS);\n    }\n\n    function setLiquidated(DepositUtils.Deposit storage _d) external {\n        _d.currentState = uint8(States.LIQUIDATED);\n    }\n}\n"
    },
    "@summa-tx/bitcoin-spv-sol/contracts/ValidateSPV.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/** @title ValidateSPV*/\n/** @author Summa (https://summa.one) */\n\nimport {BytesLib} from \"./BytesLib.sol\";\nimport {SafeMath} from \"./SafeMath.sol\";\nimport {BTCUtils} from \"./BTCUtils.sol\";\n\n\nlibrary ValidateSPV {\n\n    using BTCUtils for bytes;\n    using BTCUtils for uint256;\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n\n    enum InputTypes { NONE, LEGACY, COMPATIBILITY, WITNESS }\n    enum OutputTypes { NONE, WPKH, WSH, OP_RETURN, PKH, SH, NONSTANDARD }\n\n    uint256 constant ERR_BAD_LENGTH = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 constant ERR_INVALID_CHAIN = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe;\n    uint256 constant ERR_LOW_WORK = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd;\n\n    function getErrBadLength() internal pure returns (uint256) {\n        return ERR_BAD_LENGTH;\n    }\n\n    function getErrInvalidChain() internal pure returns (uint256) {\n        return ERR_INVALID_CHAIN;\n    }\n\n    function getErrLowWork() internal pure returns (uint256) {\n        return ERR_LOW_WORK;\n    }\n\n    /// @notice                     Validates a tx inclusion in the block\n    /// @dev                        `index` is not a reliable indicator of location within a block\n    /// @param _txid                The txid (LE)\n    /// @param _merkleRoot          The merkle root (as in the block header)\n    /// @param _intermediateNodes   The proof's intermediate nodes (digests between leaf and root)\n    /// @param _index               The leaf's index in the tree (0-indexed)\n    /// @return                     true if fully valid, false otherwise\n    function prove(\n        bytes32 _txid,\n        bytes32 _merkleRoot,\n        bytes memory _intermediateNodes,\n        uint _index\n    ) internal pure returns (bool) {\n        // Shortcut the empty-block case\n        if (_txid == _merkleRoot && _index == 0 && _intermediateNodes.length == 0) {\n            return true;\n        }\n\n        bytes memory _proof = abi.encodePacked(_txid, _intermediateNodes, _merkleRoot);\n        // If the Merkle proof failed, bubble up error\n        return _proof.verifyHash256Merkle(_index);\n    }\n\n    /// @notice             Hashes transaction to get txid\n    /// @dev                Supports Legacy and Witness\n    /// @param _version     4-bytes version\n    /// @param _vin         Raw bytes length-prefixed input vector\n    /// @param _vout        Raw bytes length-prefixed output vector\n    /// @param _locktime   4-byte tx locktime\n    /// @return             32-byte transaction id, little endian\n    function calculateTxId(\n        bytes memory _version,\n        bytes memory _vin,\n        bytes memory _vout,\n        bytes memory _locktime\n    ) internal pure returns (bytes32) {\n        // Get transaction hash double-Sha256(version + nIns + inputs + nOuts + outputs + locktime)\n        return abi.encodePacked(_version, _vin, _vout, _locktime).hash256();\n    }\n\n    /// @notice             Checks validity of header chain\n    /// @notice             Compares the hash of each header to the prevHash in the next header\n    /// @param _headers     Raw byte array of header chain\n    /// @return             The total accumulated difficulty of the header chain, or an error code\n    function validateHeaderChain(bytes memory _headers) internal view returns (uint256 _totalDifficulty) {\n\n        // Check header chain length\n        if (_headers.length % 80 != 0) {return ERR_BAD_LENGTH;}\n\n        // Initialize header start index\n        bytes32 _digest;\n\n        _totalDifficulty = 0;\n\n        for (uint256 _start = 0; _start < _headers.length; _start += 80) {\n\n            // ith header start index and ith header\n            bytes memory _header = _headers.slice(_start, 80);\n\n            // After the first header, check that headers are in a chain\n            if (_start != 0) {\n                if (!validateHeaderPrevHash(_header, _digest)) {return ERR_INVALID_CHAIN;}\n            }\n\n            // ith header target\n            uint256 _target = _header.extractTarget();\n\n            // Require that the header has sufficient work\n            _digest = _header.hash256View();\n            if(uint256(_digest).reverseUint256() > _target) {\n                return ERR_LOW_WORK;\n            }\n\n            // Add ith header difficulty to difficulty sum\n            _totalDifficulty = _totalDifficulty.add(_target.calculateDifficulty());\n        }\n    }\n\n    /// @notice             Checks validity of header work\n    /// @param _digest      Header digest\n    /// @param _target      The target threshold\n    /// @return             true if header work is valid, false otherwise\n    function validateHeaderWork(bytes32 _digest, uint256 _target) internal pure returns (bool) {\n        if (_digest == bytes32(0)) {return false;}\n        return (abi.encodePacked(_digest).reverseEndianness().bytesToUint() < _target);\n    }\n\n    /// @notice                     Checks validity of header chain\n    /// @dev                        Compares current header prevHash to previous header's digest\n    /// @param _header              The raw bytes header\n    /// @param _prevHeaderDigest    The previous header's digest\n    /// @return                     true if the connect is valid, false otherwise\n    function validateHeaderPrevHash(bytes memory _header, bytes32 _prevHeaderDigest) internal pure returns (bool) {\n\n        // Extract prevHash of current header\n        bytes32 _prevHash = _header.extractPrevBlockLE().toBytes32();\n\n        // Compare prevHash of current header to previous header's digest\n        if (_prevHash != _prevHeaderDigest) {return false;}\n\n        return true;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/IERC721.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * \n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either `approve` or `setApproveForAll`.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either `approve` or `setApproveForAll`.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n"
    },
    "openzeppelin-solidity/contracts/introspection/IERC165.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others (`ERC165Checker`).\n *\n * For an implementation, see `ERC165`.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "solidity/contracts/system/TBTCConstants.sol": {
      "content": "pragma solidity 0.5.17;\n\nlibrary TBTCConstants {\n    // This is intended to make it easy to update system params\n    // During testing swap this out with another constats contract\n\n    // System Parameters\n    uint256 public constant BENEFICIARY_FEE_DIVISOR = 1000;  // 1/1000 = 10 bps = 0.1% = 0.001\n    uint256 public constant SATOSHI_MULTIPLIER = 10 ** 10; // multiplier to convert satoshi to TBTC token units\n    uint256 public constant DEPOSIT_TERM_LENGTH = 180 * 24 * 60 * 60; // 180 days in seconds\n    uint256 public constant TX_PROOF_DIFFICULTY_FACTOR = 6; // confirmations on the Bitcoin chain\n\n    // Redemption Flow\n    uint256 public constant REDEMPTION_SIGNATURE_TIMEOUT = 2 * 60 * 60;  // seconds\n    uint256 public constant INCREASE_FEE_TIMER = 4 * 60 * 60;  // seconds\n    uint256 public constant REDEMPTION_PROOF_TIMEOUT = 6 * 60 * 60;  // seconds\n    uint256 public constant MINIMUM_REDEMPTION_FEE = 2000; // satoshi\n    uint256 public constant MINIMUM_UTXO_VALUE = 2000; // satoshi\n\n    // Funding Flow\n    uint256 public constant FUNDING_PROOF_TIMEOUT = 3 * 60 * 60; // seconds\n    uint256 public constant FORMATION_TIMEOUT = 3 * 60 * 60; // seconds\n\n    // Liquidation Flow\n    uint256 public constant COURTESY_CALL_DURATION = 6 * 60 * 60; // seconds\n    uint256 public constant AUCTION_DURATION = 24 * 60 * 60; // seconds\n\n    // Getters for easy access\n    function getBeneficiaryRewardDivisor() external pure returns (uint256) { return BENEFICIARY_FEE_DIVISOR; }\n    function getSatoshiMultiplier() external pure returns (uint256) { return SATOSHI_MULTIPLIER; }\n    function getDepositTerm() external pure returns (uint256) { return DEPOSIT_TERM_LENGTH; }\n    function getTxProofDifficultyFactor() external pure returns (uint256) { return TX_PROOF_DIFFICULTY_FACTOR; }\n\n    function getSignatureTimeout() external pure returns (uint256) { return REDEMPTION_SIGNATURE_TIMEOUT; }\n    function getIncreaseFeeTimer() external pure returns (uint256) { return INCREASE_FEE_TIMER; }\n    function getRedemptionProofTimeout() external pure returns (uint256) { return REDEMPTION_PROOF_TIMEOUT; }\n    function getMinimumRedemptionFee() external pure returns (uint256) { return MINIMUM_REDEMPTION_FEE; }\n    function getMinimumUtxoValue() external pure returns (uint256) { return MINIMUM_UTXO_VALUE; }\n\n    function getFundingTimeout() external pure returns (uint256) { return FUNDING_PROOF_TIMEOUT; }\n    function getSigningGroupFormationTimeout() external pure returns (uint256) { return FORMATION_TIMEOUT; }\n\n    function getCourtesyCallTimeout() external pure returns (uint256) { return COURTESY_CALL_DURATION; }\n    function getAuctionDuration() external pure returns (uint256) { return AUCTION_DURATION; }\n}\n"
    },
    "solidity/contracts/system/TBTCToken.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {ERC20} from \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Detailed} from \"openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\";\nimport {VendingMachineAuthority} from \"./VendingMachineAuthority.sol\";\nimport {ITokenRecipient} from \"../interfaces/ITokenRecipient.sol\";\n\n/// @title  TBTC Token.\n/// @notice This is the TBTC ERC20 contract.\n/// @dev    Tokens can only be minted by the `VendingMachine` contract.\ncontract TBTCToken is ERC20Detailed, ERC20, VendingMachineAuthority {\n    /// @dev Constructor, calls ERC20Detailed constructor to set Token info\n    ///      ERC20Detailed(TokenName, TokenSymbol, NumberOfDecimals)\n    constructor(address _VendingMachine)\n        ERC20Detailed(\"tBTC\", \"TBTC\", 18)\n        VendingMachineAuthority(_VendingMachine)\n    public {\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    /// @dev             Mints an amount of the token and assigns it to an account.\n    ///                  Uses the internal _mint function.\n    /// @param _account  The account that will receive the created tokens.\n    /// @param _amount   The amount of tokens that will be created.\n    function mint(address _account, uint256 _amount) external onlyVendingMachine returns (bool) {\n        // NOTE: this is a public function with unchecked minting. Only the\n        // vending machine is allowed to call it, and it is in charge of\n        // ensuring minting is permitted.\n        _mint(_account, _amount);\n        return true;\n    }\n\n    /// @dev             Burns an amount of the token from the given account's balance.\n    ///                  deducting from the sender's allowance for said account.\n    ///                  Uses the internal _burn function.\n    /// @param _account  The account whose tokens will be burnt.\n    /// @param _amount   The amount of tokens that will be burnt.\n    function burnFrom(address _account, uint256 _amount) external {\n        _burnFrom(_account, _amount);\n    }\n\n    /// @dev Destroys `amount` tokens from `msg.sender`, reducing the\n    /// total supply.\n    /// @param _amount   The amount of tokens that will be burnt.\n    function burn(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n    }\n\n    /// @notice           Set allowance for other address and notify.\n    ///                   Allows `_spender` to spend no more than `_value`\n    ///                   tokens on your behalf and then ping the contract about\n    ///                   it.\n    /// @dev              The `_spender` should implement the `ITokenRecipient`\n    ///                   interface to receive approval notifications.\n    /// @param _spender   Address of contract authorized to spend.\n    /// @param _value     The max amount they can spend.\n    /// @param _extraData Extra information to send to the approved contract.\n    /// @return true if the `_spender` was successfully approved and acted on\n    ///         the approval, false (or revert) otherwise.\n    function approveAndCall(\n        ITokenRecipient _spender,\n        uint256 _value,\n        bytes memory _extraData\n    ) public returns (bool) { // not external to allow bytes memory parameters\n        if (approve(address(_spender), _value)) {\n            _spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n        return false;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * > Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "solidity/contracts/system/VendingMachineAuthority.sol": {
      "content": "pragma solidity 0.5.17;\n\n/// @title  Vending Machine Authority.\n/// @notice Contract to secure function calls to the Vending Machine.\n/// @dev    Secured by setting the VendingMachine address and using the\n///         onlyVendingMachine modifier on functions requiring restriction.\ncontract VendingMachineAuthority {\n    address internal VendingMachine;\n\n    constructor(address _vendingMachine) public {\n        VendingMachine = _vendingMachine;\n    }\n\n    /// @notice Function modifier ensures modified function caller address is the vending machine.\n    modifier onlyVendingMachine() {\n        require(msg.sender == VendingMachine, \"caller must be the vending machine\");\n        _;\n    }\n}\n"
    },
    "solidity/contracts/interfaces/ITokenRecipient.sol": {
      "content": "pragma solidity 0.5.17;\n\n/// @title Interface of recipient contract for `approveAndCall` pattern.\n///        Implementors will be able to be used in an `approveAndCall`\n///        interaction with a supporting contract, such that a token approval\n///        can call the contract acting on that approval in a single\n///        transaction.\n///\n///        See the `FundingScript` and `RedemptionScript` contracts as examples.\ninterface ITokenRecipient {\n    /// Typically called from a token contract's `approveAndCall` method, this\n    /// method will receive the original owner of the token (`_from`), the\n    /// transferred `_value` (in the case of an ERC721, the token id), the token\n    /// address (`_token`), and a blob of `_extraData` that is informally\n    /// specified by the implementor of this method as a way to communicate\n    /// additional parameters.\n    ///\n    /// Token calls to `receiveApproval` should revert if `receiveApproval`\n    /// reverts, and reverts should remove the approval.\n    ///\n    /// @param _from The original owner of the token approved for transfer.\n    /// @param _value For an ERC20, the amount approved for transfer; for an\n    ///        ERC721, the id of the token approved for transfer.\n    /// @param _token The address of the contract for the token whose transfer\n    ///        was approved.\n    /// @param _extraData An additional data blob forwarded unmodified through\n    ///        `approveAndCall`, used to allow the token owner to pass\n    ///         additional parameters and data to this method. The structure of\n    ///         the extra data is informally specified by the implementor of\n    ///         this interface.\n    function receiveApproval(\n        address _from,\n        uint256 _value,\n        address _token,\n        bytes calldata _extraData\n    ) external;\n}\n"
    },
    "solidity/contracts/system/FeeRebateToken.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol\";\nimport \"./VendingMachineAuthority.sol\";\n\n/// @title  Fee Rebate Token\n/// @notice The Fee Rebate Token (FRT) is a non fungible token (ERC721)\n///         the ID of which corresponds to a given deposit address.\n///         If the corresponding deposit is still active, ownership of this token\n///         could result in reimbursement of the signer fee paid to open the deposit.\n/// @dev    This token is minted automatically when a TDT (`TBTCDepositToken`)\n///         is exchanged for TBTC (`TBTCToken`) via the Vending Machine (`VendingMachine`).\n///         When the Deposit is redeemed, the TDT holder will be reimbursed\n///         the signer fee if the redeemer is not the TDT holder and Deposit is not\n///         at-term or in COURTESY_CALL.\ncontract FeeRebateToken is ERC721Metadata, VendingMachineAuthority {\n\n    constructor(address _vendingMachine)\n        ERC721Metadata(\"tBTC Fee Rebate Token\", \"FRT\")\n        VendingMachineAuthority(_vendingMachine)\n    public {\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    /// @dev Mints a new token.\n    /// Reverts if the given token ID already exists.\n    /// @param _to The address that will own the minted token.\n    /// @param _tokenId uint256 ID of the token to be minted.\n    function mint(address _to, uint256 _tokenId) external onlyVendingMachine {\n        _mint(_to, _tokenId);\n    }\n\n    /// @dev Returns whether the specified token exists.\n    /// @param _tokenId uint256 ID of the token to query the existence of.\n    /// @return bool whether the token exists.\n    function exists(uint256 _tokenId) external view returns (bool) {\n        return _exists(_tokenId);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"../../introspection/ERC165.sol\";\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /**\n     * @dev Constructor function\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /**\n     * @dev Gets the token name.\n     * @return string representing the token name\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Gets the token symbol.\n     * @return string representing the token symbol\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns an URI for a given token ID.\n     * Throws if the token ID does not exist. May return an empty string.\n     * @param tokenId uint256 ID of the token to query\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        return _tokenURIs[tokenId];\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token.\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to set its URI\n     * @param uri string URI to assign\n     */\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = uri;\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/ERC721.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../drafts/Counters.sol\";\nimport \"../../introspection/ERC165.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != msg.sender, \"ERC721: approve to caller\");\n\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke `onERC721Received` on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This function is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a `safeTransfer`. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Collection of functions related to the address type,\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * > It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/drafts/Counters.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../math/SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/introspection/ERC165.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the `IERC165` interface.\n *\n * Contracts may inherit from this and call `_registerInterface` to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See `IERC165.supportsInterface`.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See `IERC165.supportsInterface`.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "solidity/contracts/deposit/OutsourceDepositLogging.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {DepositLog} from \"../DepositLog.sol\";\nimport {DepositUtils} from \"./DepositUtils.sol\";\n\nlibrary OutsourceDepositLogging {\n\n\n    /// @notice               Fires a Created event.\n    /// @dev                  `DepositLog.logCreated` fires a Created event with\n    ///                       _keepAddress, msg.sender and block.timestamp.\n    ///                       msg.sender will be the calling Deposit's address.\n    /// @param  _keepAddress  The address of the associated keep.\n    function logCreated(DepositUtils.Deposit storage _d, address _keepAddress) external {\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logCreated(_keepAddress);\n    }\n\n    /// @notice                 Fires a RedemptionRequested event.\n    /// @dev                    This is the only event without an explicit timestamp.\n    /// @param  _redeemer       The ethereum address of the redeemer.\n    /// @param  _digest         The calculated sighash digest.\n    /// @param  _utxoValue       The size of the utxo in sat.\n    /// @param  _redeemerOutputScript The redeemer's length-prefixed output script.\n    /// @param  _requestedFee   The redeemer or bump-system specified fee.\n    /// @param  _outpoint       The 36 byte outpoint.\n    /// @return                 True if successful, else revert.\n    function logRedemptionRequested(\n        DepositUtils.Deposit storage _d,\n        address _redeemer,\n        bytes32 _digest,\n        uint256 _utxoValue,\n        bytes memory _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes memory _outpoint\n    ) public { // not external to allow bytes memory parameters\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logRedemptionRequested(\n            _redeemer,\n            _digest,\n            _utxoValue,\n            _redeemerOutputScript,\n            _requestedFee,\n            _outpoint\n        );\n    }\n\n    /// @notice         Fires a GotRedemptionSignature event.\n    /// @dev            We append the sender, which is the deposit contract that called.\n    /// @param  _digest Signed digest.\n    /// @param  _r      Signature r value.\n    /// @param  _s      Signature s value.\n    /// @return         True if successful, else revert.\n    function logGotRedemptionSignature(\n        DepositUtils.Deposit storage _d,\n        bytes32 _digest,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logGotRedemptionSignature(\n            _digest,\n            _r,\n            _s\n        );\n    }\n\n    /// @notice     Fires a RegisteredPubkey event.\n    /// @dev        The logger is on a system contract, so all logs from all deposits are from the same address.\n    function logRegisteredPubkey(\n        DepositUtils.Deposit storage _d,\n        bytes32 _signingGroupPubkeyX,\n        bytes32 _signingGroupPubkeyY\n    ) external {\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logRegisteredPubkey(\n            _signingGroupPubkeyX,\n            _signingGroupPubkeyY);\n    }\n\n    /// @notice     Fires a SetupFailed event.\n    /// @dev        The logger is on a system contract, so all logs from all deposits are from the same address.\n    function logSetupFailed(DepositUtils.Deposit storage _d) external {\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logSetupFailed();\n    }\n\n    /// @notice     Fires a FunderAbortRequested event.\n    /// @dev        The logger is on a system contract, so all logs from all deposits are from the same address.\n    function logFunderRequestedAbort(\n        DepositUtils.Deposit storage _d,\n        bytes memory _abortOutputScript\n    ) public { // not external to allow bytes memory parameters\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logFunderRequestedAbort(_abortOutputScript);\n    }\n\n    /// @notice     Fires a FraudDuringSetup event.\n    /// @dev        The logger is on a system contract, so all logs from all deposits are from the same address.\n    function logFraudDuringSetup(DepositUtils.Deposit storage _d) external {\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logFraudDuringSetup();\n    }\n\n    /// @notice     Fires a Funded event.\n    /// @dev        The logger is on a system contract, so all logs from all deposits are from the same address.\n    function logFunded(DepositUtils.Deposit storage _d, bytes32 _txid) external {\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logFunded(_txid);\n    }\n\n    /// @notice     Fires a CourtesyCalled event.\n    /// @dev        The logger is on a system contract, so all logs from all deposits are from the same address.\n    function logCourtesyCalled(DepositUtils.Deposit storage _d) external {\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logCourtesyCalled();\n    }\n\n    /// @notice             Fires a StartedLiquidation event.\n    /// @dev                We append the sender, which is the deposit contract that called.\n    /// @param _wasFraud    True if liquidating for fraud.\n    function logStartedLiquidation(DepositUtils.Deposit storage _d, bool _wasFraud) external {\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logStartedLiquidation(_wasFraud);\n    }\n\n    /// @notice     Fires a Redeemed event.\n    /// @dev        The logger is on a system contract, so all logs from all deposits are from the same address.\n    function logRedeemed(DepositUtils.Deposit storage _d, bytes32 _txid) external {\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logRedeemed(_txid);\n    }\n\n    /// @notice     Fires a Liquidated event.\n    /// @dev        The logger is on a system contract, so all logs from all deposits are from the same address.\n    function logLiquidated(DepositUtils.Deposit storage _d) external {\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logLiquidated();\n    }\n\n    /// @notice     Fires a ExitedCourtesyCall event.\n    /// @dev        The logger is on a system contract, so all logs from all deposits are from the same address.\n    function logExitedCourtesyCall(DepositUtils.Deposit storage _d) external {\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logExitedCourtesyCall();\n    }\n}\n"
    },
    "solidity/contracts/DepositLog.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {TBTCDepositToken} from \"./system/TBTCDepositToken.sol\";\n\n\n// solium-disable function-order\n// Below, a few functions must be public to allow bytes memory parameters, but\n// their being so triggers errors because public functions should be grouped\n// below external functions. Since these would be external if it were possible,\n// we ignore the issue.\n\ncontract DepositLog {\n    /*\n    Logging philosophy:\n      Every state transition should fire a log\n      That log should have ALL necessary info for off-chain actors\n      Everyone should be able to ENTIRELY rely on log messages\n    */\n\n    // `TBTCDepositToken` mints a token for every new Deposit.\n    // If a token exists for a given ID, we know it is a valid Deposit address.\n    TBTCDepositToken tbtcDepositToken;\n\n    // This event is fired when we init the deposit\n    event Created(\n        address indexed _depositContractAddress,\n        address indexed _keepAddress,\n        uint256 _timestamp\n    );\n\n    // This log event contains all info needed to rebuild the redemption tx\n    // We index on request and signers and digest\n    event RedemptionRequested(\n        address indexed _depositContractAddress,\n        address indexed _requester,\n        bytes32 indexed _digest,\n        uint256 _utxoValue,\n        bytes _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes _outpoint\n    );\n\n    // This log event contains all info needed to build a witnes\n    // We index the digest so that we can search events for the other log\n    event GotRedemptionSignature(\n        address indexed _depositContractAddress,\n        bytes32 indexed _digest,\n        bytes32 _r,\n        bytes32 _s,\n        uint256 _timestamp\n    );\n\n    // This log is fired when the signing group returns a public key\n    event RegisteredPubkey(\n        address indexed _depositContractAddress,\n        bytes32 _signingGroupPubkeyX,\n        bytes32 _signingGroupPubkeyY,\n        uint256 _timestamp\n    );\n\n    // This event is fired when we enter the FAILED_SETUP state for any reason\n    event SetupFailed(\n        address indexed _depositContractAddress,\n        uint256 _timestamp\n    );\n\n    // This event is fired when a funder requests funder abort after\n    // FAILED_SETUP has been reached. Funder abort is a voluntary signer action\n    // to return UTXO(s) that were sent to a signer-controlled wallet despite\n    // the funding proofs having failed.\n    event FunderAbortRequested(\n        address indexed _depositContractAddress,\n        bytes _abortOutputScript\n    );\n\n    // This event is fired when we detect an ECDSA fraud before seeing a funding proof\n    event FraudDuringSetup(\n        address indexed _depositContractAddress,\n        uint256 _timestamp\n    );\n\n    // This event is fired when we enter the ACTIVE state\n    event Funded(\n        address indexed _depositContractAddress,\n        bytes32 indexed _txid,\n        uint256 _timestamp\n    );\n\n    // This event is called when we enter the COURTESY_CALL state\n    event CourtesyCalled(\n        address indexed _depositContractAddress,\n        uint256 _timestamp\n    );\n\n    // This event is fired when we go from COURTESY_CALL to ACTIVE\n    event ExitedCourtesyCall(\n        address indexed _depositContractAddress,\n        uint256 _timestamp\n    );\n\n    // This log event is fired when liquidation\n    event StartedLiquidation(\n        address indexed _depositContractAddress,\n        bool _wasFraud,\n        uint256 _timestamp\n    );\n\n    // This event is fired when the Redemption SPV proof is validated\n    event Redeemed(\n        address indexed _depositContractAddress,\n        bytes32 indexed _txid,\n        uint256 _timestamp\n    );\n\n    // This event is fired when Liquidation is completed\n    event Liquidated(\n        address indexed _depositContractAddress,\n        uint256 _timestamp\n    );\n\n    //\n    // Logging\n    //\n\n    /// @notice               Fires a Created event.\n    /// @dev                  We append the sender, which is the deposit contract that called.\n    /// @param  _keepAddress  The address of the associated keep.\n    /// @return               True if successful, else revert.\n    function logCreated(address _keepAddress) external {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit Created(msg.sender, _keepAddress, block.timestamp);\n    }\n\n    /// @notice                 Fires a RedemptionRequested event.\n    /// @dev                    This is the only event without an explicit timestamp.\n    /// @param  _requester      The ethereum address of the requester.\n    /// @param  _digest         The calculated sighash digest.\n    /// @param  _utxoValue       The size of the utxo in sat.\n    /// @param  _redeemerOutputScript The redeemer's length-prefixed output script.\n    /// @param  _requestedFee   The requester or bump-system specified fee.\n    /// @param  _outpoint       The 36 byte outpoint.\n    /// @return                 True if successful, else revert.\n    function logRedemptionRequested(\n        address _requester,\n        bytes32 _digest,\n        uint256 _utxoValue,\n        bytes memory _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes memory _outpoint\n    ) public {\n        // not external to allow bytes memory parameters\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit RedemptionRequested(\n            msg.sender,\n            _requester,\n            _digest,\n            _utxoValue,\n            _redeemerOutputScript,\n            _requestedFee,\n            _outpoint\n        );\n    }\n\n    /// @notice         Fires a GotRedemptionSignature event.\n    /// @dev            We append the sender, which is the deposit contract that called.\n    /// @param  _digest signed digest.\n    /// @param  _r      signature r value.\n    /// @param  _s      signature s value.\n    function logGotRedemptionSignature(bytes32 _digest, bytes32 _r, bytes32 _s)\n        external\n    {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit GotRedemptionSignature(\n            msg.sender,\n            _digest,\n            _r,\n            _s,\n            block.timestamp\n        );\n    }\n\n    /// @notice     Fires a RegisteredPubkey event.\n    /// @dev        We append the sender, which is the deposit contract that called.\n    function logRegisteredPubkey(\n        bytes32 _signingGroupPubkeyX,\n        bytes32 _signingGroupPubkeyY\n    ) external {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit RegisteredPubkey(\n            msg.sender,\n            _signingGroupPubkeyX,\n            _signingGroupPubkeyY,\n            block.timestamp\n        );\n    }\n\n    /// @notice     Fires a SetupFailed event.\n    /// @dev        We append the sender, which is the deposit contract that called.\n    function logSetupFailed() external {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit SetupFailed(msg.sender, block.timestamp);\n    }\n\n    /// @notice     Fires a FunderAbortRequested event.\n    /// @dev        We append the sender, which is the deposit contract that called.\n    function logFunderRequestedAbort(bytes memory _abortOutputScript) public {\n        // not external to allow bytes memory parameters\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit FunderAbortRequested(msg.sender, _abortOutputScript);\n    }\n\n    /// @notice     Fires a FraudDuringSetup event.\n    /// @dev        We append the sender, which is the deposit contract that called.\n    function logFraudDuringSetup() external {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit FraudDuringSetup(msg.sender, block.timestamp);\n    }\n\n    /// @notice     Fires a Funded event.\n    /// @dev        We append the sender, which is the deposit contract that called.\n    function logFunded(bytes32 _txid) external {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit Funded(msg.sender, _txid, block.timestamp);\n    }\n\n    /// @notice     Fires a CourtesyCalled event.\n    /// @dev        We append the sender, which is the deposit contract that called.\n    function logCourtesyCalled() external {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit CourtesyCalled(msg.sender, block.timestamp);\n    }\n\n    /// @notice             Fires a StartedLiquidation event.\n    /// @dev                We append the sender, which is the deposit contract that called.\n    /// @param _wasFraud    True if liquidating for fraud.\n    function logStartedLiquidation(bool _wasFraud) external {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit StartedLiquidation(msg.sender, _wasFraud, block.timestamp);\n    }\n\n    /// @notice     Fires a Redeemed event\n    /// @dev        We append the sender, which is the deposit contract that called.\n    function logRedeemed(bytes32 _txid) external {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit Redeemed(msg.sender, _txid, block.timestamp);\n    }\n\n    /// @notice     Fires a Liquidated event\n    /// @dev        We append the sender, which is the deposit contract that called.\n    function logLiquidated() external {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit Liquidated(msg.sender, block.timestamp);\n    }\n\n    /// @notice     Fires a ExitedCourtesyCall event\n    /// @dev        We append the sender, which is the deposit contract that called.\n    function logExitedCourtesyCall() external {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit ExitedCourtesyCall(msg.sender, block.timestamp);\n    }\n\n    /// @notice               Sets the tbtcDepositToken contract.\n    /// @dev                  The contract is used by `approvedToLog` to check if the\n    ///                       caller is a Deposit contract. This should only be called once.\n    /// @param  _tbtcDepositTokenAddress  The address of the tbtcDepositToken.\n    function setTbtcDepositToken(TBTCDepositToken _tbtcDepositTokenAddress)\n        internal\n    {\n        require(\n            address(tbtcDepositToken) == address(0),\n            \"tbtcDepositToken is already set\"\n        );\n        tbtcDepositToken = _tbtcDepositTokenAddress;\n    }\n\n    //\n    // AUTH\n    //\n\n    /// @notice             Checks if an address is an allowed logger.\n    /// @dev                checks tbtcDepositToken to see if the caller represents\n    ///                     an existing deposit.\n    ///                     We don't require this, so deposits are not bricked if the system borks.\n    /// @param  _caller     The address of the calling contract.\n    /// @return             True if approved, otherwise false.\n    function approvedToLog(address _caller) public view returns (bool) {\n        return tbtcDepositToken.exists(uint256(_caller));\n    }\n}\n"
    },
    "solidity/contracts/system/TBTCDepositToken.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {ERC721Metadata} from \"openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol\";\nimport {DepositFactoryAuthority} from \"./DepositFactoryAuthority.sol\";\nimport {ITokenRecipient} from \"../interfaces/ITokenRecipient.sol\";\n\n/// @title tBTC Deposit Token for tracking deposit ownership\n/// @notice The tBTC Deposit Token, commonly referenced as the TDT, is an\n///         ERC721 non-fungible token whose ownership reflects the ownership\n///         of its corresponding deposit. Each deposit has one TDT, and vice\n///         versa. Owning a TDT is equivalent to owning its corresponding\n///         deposit. TDTs can be transferred freely. tBTC's VendingMachine\n///         contract takes ownership of TDTs and in exchange returns fungible\n///         TBTC tokens whose value is backed 1-to-1 by the corresponding\n///         deposit's BTC.\n/// @dev Currently, TDTs are minted using the uint256 casting of the\n///      corresponding deposit contract's address. That is, the TDT's id is\n///      convertible to the deposit's address and vice versa. TDTs are minted\n///      automatically by the factory during each deposit's initialization. See\n///      DepositFactory.createNewDeposit() for more info on how the TDT is minted.\ncontract TBTCDepositToken is ERC721Metadata, DepositFactoryAuthority {\n\n    constructor(address _depositFactoryAddress)\n        ERC721Metadata(\"tBTC Deposit Token\", \"TDT\")\n    public {\n        initialize(_depositFactoryAddress);\n    }\n\n    /// @dev Mints a new token.\n    /// Reverts if the given token ID already exists.\n    /// @param _to The address that will own the minted token\n    /// @param _tokenId uint256 ID of the token to be minted\n    function mint(address _to, uint256 _tokenId) external onlyFactory {\n        _mint(_to, _tokenId);\n    }\n\n    /// @dev Returns whether the specified token exists.\n    /// @param _tokenId uint256 ID of the token to query the existence of.\n    /// @return bool whether the token exists.\n    function exists(uint256 _tokenId) external view returns (bool) {\n        return _exists(_tokenId);\n    }\n\n    /// @notice           Allow another address to spend on the caller's behalf.\n    ///                   Set allowance for other address and notify.\n    ///                   Allows `_spender` to transfer the specified TDT\n    ///                   on your behalf and then ping the contract about it.\n    /// @dev              The `_spender` should implement the `ITokenRecipient`\n    ///                   interface below to receive approval notifications.\n    /// @param _spender   `ITokenRecipient`-conforming contract authorized to\n    ///        operate on the approved token.\n    /// @param _tdtId     The TDT they can spend.\n    /// @param _extraData Extra information to send to the approved contract.\n    function approveAndCall(\n        ITokenRecipient _spender,\n        uint256 _tdtId,\n        bytes memory _extraData\n    ) public returns (bool) { // not external to allow bytes memory parameters\n        approve(address(_spender), _tdtId);\n        _spender.receiveApproval(msg.sender, _tdtId, address(this), _extraData);\n        return true;\n    }\n}\n"
    },
    "solidity/contracts/system/DepositFactoryAuthority.sol": {
      "content": "pragma solidity 0.5.17;\n\n/// @title  Deposit Factory Authority\n/// @notice Contract to secure function calls to the Deposit Factory.\n/// @dev    Secured by setting the depositFactory address and using the onlyFactory\n///         modifier on functions requiring restriction.\ncontract DepositFactoryAuthority {\n\n    bool internal _initialized = false;\n    address internal _depositFactory;\n\n    /// @notice Set the address of the System contract on contract\n    ///         initialization.\n    /// @dev Since this function is not access-controlled, it should be called\n    ///      transactionally with contract instantiation. In cases where a\n    ///      regular contract directly inherits from DepositFactoryAuthority,\n    ///      that should happen in the constructor. In cases where the inheritor\n    ///      is binstead used via a clone factory, the same function that\n    ///      creates a new clone should also trigger initialization.\n    function initialize(address _factory) public {\n        require(_factory != address(0), \"Factory cannot be the zero address.\");\n        require(! _initialized, \"Factory can only be initialized once.\");\n\n        _depositFactory = _factory;\n        _initialized = true;\n    }\n\n    /// @notice Function modifier ensures modified function is only called by set deposit factory.\n    modifier onlyFactory(){\n        require(_initialized, \"Factory initialization must have been called.\");\n        require(msg.sender == _depositFactory, \"Caller must be depositFactory contract\");\n        _;\n    }\n}\n"
    },
    "solidity/contracts/deposit/DepositFunding.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {BytesLib} from \"@summa-tx/bitcoin-spv-sol/contracts/BytesLib.sol\";\nimport {BTCUtils} from \"@summa-tx/bitcoin-spv-sol/contracts/BTCUtils.sol\";\nimport {IBondedECDSAKeep} from \"@keep-network/keep-ecdsa/contracts/api/IBondedECDSAKeep.sol\";\nimport {SafeMath} from \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport {TBTCToken} from \"../system/TBTCToken.sol\";\nimport {DepositUtils} from \"./DepositUtils.sol\";\nimport {DepositLiquidation} from \"./DepositLiquidation.sol\";\nimport {DepositStates} from \"./DepositStates.sol\";\nimport {OutsourceDepositLogging} from \"./OutsourceDepositLogging.sol\";\nimport {TBTCConstants} from \"../system/TBTCConstants.sol\";\n\nlibrary DepositFunding {\n\n    using SafeMath for uint256;\n    using SafeMath for uint64;\n    using BTCUtils for bytes;\n    using BytesLib for bytes;\n\n    using DepositUtils for DepositUtils.Deposit;\n    using DepositStates for DepositUtils.Deposit;\n    using DepositLiquidation for DepositUtils.Deposit;\n    using OutsourceDepositLogging for DepositUtils.Deposit;\n\n    /// @notice     Deletes state after funding.\n    /// @dev        This is called when we go to ACTIVE or setup fails without fraud.\n    function fundingTeardown(DepositUtils.Deposit storage _d) internal {\n        _d.signingGroupRequestedAt = 0;\n        _d.fundingProofTimerStart = 0;\n    }\n\n    /// @notice     Deletes state after the funding ECDSA fraud process.\n    /// @dev        This is only called as we transition to setup failed.\n    function fundingFraudTeardown(DepositUtils.Deposit storage _d) internal {\n        _d.keepAddress = address(0);\n        _d.signingGroupRequestedAt = 0;\n        _d.fundingProofTimerStart = 0;\n        _d.signingGroupPubkeyX = bytes32(0);\n        _d.signingGroupPubkeyY = bytes32(0);\n    }\n\n    /// @notice Internally called function to set up a newly created Deposit\n    ///         instance. This should not be called by developers, use\n    ///         `DepositFactory.createDeposit` to create a new deposit.\n    /// @dev If called directly, the transaction will revert since the call will\n    ///      be executed on an already set-up instance.\n    /// @param _d Deposit storage pointer.\n    /// @param _lotSizeSatoshis Lot size in satoshis.\n    function initialize(\n        DepositUtils.Deposit storage _d,\n        uint64 _lotSizeSatoshis\n    ) public {\n        require(_d.tbtcSystem.getAllowNewDeposits(), \"New deposits aren't allowed.\");\n        require(_d.inStart(), \"Deposit setup already requested\");\n\n        _d.lotSizeSatoshis = _lotSizeSatoshis;\n\n        _d.keepSetupFee = _d.tbtcSystem.getNewDepositFeeEstimate();\n\n        // Note: this is a library, and library functions cannot be marked as\n        // payable. Thus, we disable Solium's check that msg.value can only be\n        // used in a payable function---this restriction actually applies to the\n        // caller of this `initialize` function, Deposit.initializeDeposit.\n        /* solium-disable-next-line value-in-payable */\n        _d.keepAddress = _d.tbtcSystem.requestNewKeep.value(msg.value)(\n            _lotSizeSatoshis,\n            TBTCConstants.getDepositTerm()\n        );\n\n        require(_d.fetchBondAmount() >= _d.keepSetupFee, \"Insufficient signer bonds to cover setup fee\");\n\n        _d.signerFeeDivisor = _d.tbtcSystem.getSignerFeeDivisor();\n        _d.undercollateralizedThresholdPercent = _d.tbtcSystem.getUndercollateralizedThresholdPercent();\n        _d.severelyUndercollateralizedThresholdPercent = _d.tbtcSystem.getSeverelyUndercollateralizedThresholdPercent();\n        _d.initialCollateralizedPercent = _d.tbtcSystem.getInitialCollateralizedPercent();\n        _d.signingGroupRequestedAt = block.timestamp;\n\n        _d.setAwaitingSignerSetup();\n        _d.logCreated(_d.keepAddress);\n    }\n\n    /// @notice     Anyone may notify the contract that signing group setup has timed out.\n    /// @param  _d  Deposit storage pointer.\n    function notifySignerSetupFailed(DepositUtils.Deposit storage _d) external {\n        require(_d.inAwaitingSignerSetup(), \"Not awaiting setup\");\n        require(\n            block.timestamp > _d.signingGroupRequestedAt.add(TBTCConstants.getSigningGroupFormationTimeout()),\n            \"Signing group formation timeout not yet elapsed\"\n        );\n\n        // refund the deposit owner the cost to create a new Deposit at the time the Deposit was opened.\n        uint256 _seized = _d.seizeSignerBonds();\n\n        if(_seized >= _d.keepSetupFee){\n            /* solium-disable-next-line security/no-send */\n            _d.enableWithdrawal(_d.depositOwner(), _d.keepSetupFee);\n            _d.pushFundsToKeepGroup(_seized.sub(_d.keepSetupFee));\n        }\n\n        _d.setFailedSetup();\n        _d.logSetupFailed();\n\n        fundingTeardown(_d);\n    }\n\n    /// @notice             we poll the Keep contract to retrieve our pubkey.\n    /// @dev                We store the pubkey as 2 bytestrings, X and Y.\n    /// @param  _d          Deposit storage pointer.\n    /// @return             True if successful, otherwise revert.\n    function retrieveSignerPubkey(DepositUtils.Deposit storage _d) public {\n        require(_d.inAwaitingSignerSetup(), \"Not currently awaiting signer setup\");\n\n        bytes memory _publicKey = IBondedECDSAKeep(_d.keepAddress).getPublicKey();\n        require(_publicKey.length == 64, \"public key not set or not 64-bytes long\");\n\n        _d.signingGroupPubkeyX = _publicKey.slice(0, 32).toBytes32();\n        _d.signingGroupPubkeyY = _publicKey.slice(32, 32).toBytes32();\n        require(_d.signingGroupPubkeyY != bytes32(0) && _d.signingGroupPubkeyX != bytes32(0), \"Keep returned bad pubkey\");\n        _d.fundingProofTimerStart = block.timestamp;\n\n        _d.setAwaitingBTCFundingProof();\n        _d.logRegisteredPubkey(\n            _d.signingGroupPubkeyX,\n            _d.signingGroupPubkeyY);\n    }\n\n    /// @notice Anyone may notify the contract that the funder has failed to\n    ///         prove that they have sent BTC in time.\n    /// @dev This is considered a funder fault, and the funder's payment for\n    ///      opening the deposit is not refunded. Reverts if the funding timeout\n    ///      has not yet elapsed, or if the deposit is not currently awaiting\n    ///      funding proof.\n    /// @param _d Deposit storage pointer.\n    function notifyFundingTimedOut(DepositUtils.Deposit storage _d) external {\n        require(_d.inAwaitingBTCFundingProof(), \"Funding timeout has not started\");\n        require(\n            block.timestamp > _d.fundingProofTimerStart.add(TBTCConstants.getFundingTimeout()),\n            \"Funding timeout has not elapsed.\"\n        );\n        _d.setFailedSetup();\n        _d.logSetupFailed();\n\n        _d.closeKeep();\n        fundingTeardown(_d);\n    }\n\n    /// @notice Requests a funder abort for a failed-funding deposit; that is,\n    ///         requests return of a sent UTXO to `_abortOutputScript`. This can\n    ///         be used for example when a UTXO is sent that is the wrong size\n    ///         for the lot. Must be called after setup fails for any reason,\n    ///         and imposes no requirement or incentive on the signing group to\n    ///         return the UTXO.\n    /// @dev This is a self-admitted funder fault, and should only be callable\n    ///      by the TDT holder.\n    /// @param _d Deposit storage pointer.\n    /// @param _abortOutputScript The output script the funder wishes to request\n    ///        a return of their UTXO to.\n    function requestFunderAbort(\n        DepositUtils.Deposit storage _d,\n        bytes memory _abortOutputScript\n    ) public { // not external to allow bytes memory parameters\n        require(\n            _d.inFailedSetup(),\n            \"The deposit has not failed funding\"\n        );\n\n        _d.logFunderRequestedAbort(_abortOutputScript);\n    }\n\n    /// @notice                 Anyone can provide a signature that was not requested to prove fraud during funding.\n    /// @dev                    Calls out to the keep to verify if there was fraud.\n    /// @param  _d              Deposit storage pointer.\n    /// @param  _v              Signature recovery value.\n    /// @param  _r              Signature R value.\n    /// @param  _s              Signature S value.\n    /// @param _signedDigest    The digest signed by the signature vrs tuple.\n    /// @param _preimage        The sha256 preimage of the digest.\n    /// @return                 True if successful, otherwise revert.\n    function provideFundingECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public { // not external to allow bytes memory parameters\n        require(\n            _d.inAwaitingBTCFundingProof(),\n            \"Signer fraud during funding flow only available while awaiting funding\"\n        );\n\n        _d.submitSignatureFraud(_v, _r, _s, _signedDigest, _preimage);\n        _d.logFraudDuringSetup();\n\n        // Allow deposit owner to withdraw seized bonds after contract termination.\n        uint256 _seized = _d.seizeSignerBonds();\n        _d.enableWithdrawal(_d.depositOwner(), _seized);\n\n        fundingFraudTeardown(_d);\n        _d.setFailedSetup();\n        _d.logSetupFailed();\n    }\n\n    /// @notice                     Anyone may notify the deposit of a funding proof to activate the deposit.\n    ///                             This is the happy-path of the funding flow. It means that we have succeeded.\n    /// @dev                        Takes a pre-parsed transaction and calculates values needed to verify funding.\n    /// @param  _d                  Deposit storage pointer.\n    /// @param _txVersion           Transaction version number (4-byte LE).\n    /// @param _txInputVector       All transaction inputs prepended by the number of inputs encoded as a VarInt, max 0xFC(252) inputs.\n    /// @param _txOutputVector      All transaction outputs prepended by the number of outputs encoded as a VarInt, max 0xFC(252) outputs.\n    /// @param _txLocktime          Final 4 bytes of the transaction.\n    /// @param _fundingOutputIndex  Index of funding output in _txOutputVector (0-indexed).\n    /// @param _merkleProof         The merkle proof of transaction inclusion in a block.\n    /// @param _txIndexInBlock      Transaction index in the block (0-indexed).\n    /// @param _bitcoinHeaders      Single bytestring of 80-byte bitcoin headers, lowest height first.\n    function provideBTCFundingProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public { // not external to allow bytes memory parameters\n\n        require(_d.inAwaitingBTCFundingProof(), \"Not awaiting funding\");\n\n        bytes8 _valueBytes;\n        bytes memory  _utxoOutpoint;\n\n        (_valueBytes, _utxoOutpoint) = _d.validateAndParseFundingSPVProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n\n        // Write down the UTXO info and set to active. Congratulations :)\n        _d.utxoValueBytes = _valueBytes;\n        _d.utxoOutpoint = _utxoOutpoint;\n        _d.fundedAt = block.timestamp;\n\n        bytes32 _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        fundingTeardown(_d);\n        _d.setActive();\n        _d.logFunded(_txid);\n    }\n}\n"
    },
    "@summa-tx/bitcoin-spv-sol/contracts/CheckBitcoinSigs.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/** @title CheckBitcoinSigs */\n/** @author Summa (https://summa.one) */\n\nimport {BytesLib} from \"./BytesLib.sol\";\nimport {BTCUtils} from \"./BTCUtils.sol\";\n\n\nlibrary CheckBitcoinSigs {\n\n    using BytesLib for bytes;\n    using BTCUtils for bytes;\n\n    /// @notice          Derives an Ethereum Account address from a pubkey\n    /// @dev             The address is the last 20 bytes of the keccak256 of the address\n    /// @param _pubkey   The public key X & Y. Unprefixed, as a 64-byte array\n    /// @return          The account address\n    function accountFromPubkey(bytes memory _pubkey) internal pure returns (address) {\n        require(_pubkey.length == 64, \"Pubkey must be 64-byte raw, uncompressed key.\");\n\n        // keccak hash of uncompressed unprefixed pubkey\n        bytes32 _digest = keccak256(_pubkey);\n        return address(uint256(_digest));\n    }\n\n    /// @notice          Calculates the p2wpkh output script of a pubkey\n    /// @dev             Compresses keys to 33 bytes as required by Bitcoin\n    /// @param _pubkey   The public key, compressed or uncompressed\n    /// @return          The p2wkph output script\n    function p2wpkhFromPubkey(bytes memory _pubkey) internal pure returns (bytes memory) {\n        bytes memory _compressedPubkey;\n        uint8 _prefix;\n\n        if (_pubkey.length == 64) {\n            _prefix = uint8(_pubkey[_pubkey.length - 1]) % 2 == 1 ? 3 : 2;\n            _compressedPubkey = abi.encodePacked(_prefix, _pubkey.slice(0, 32));\n        } else if (_pubkey.length == 65) {\n            _prefix = uint8(_pubkey[_pubkey.length - 1]) % 2 == 1 ? 3 : 2;\n            _compressedPubkey = abi.encodePacked(_prefix, _pubkey.slice(1, 32));\n        } else {\n            _compressedPubkey = _pubkey;\n        }\n\n        require(_compressedPubkey.length == 33, \"Witness PKH requires compressed keys\");\n\n        bytes memory _pubkeyHash = _compressedPubkey.hash160();\n        return abi.encodePacked(hex\"0014\", _pubkeyHash);\n    }\n\n    /// @notice          checks a signed message's validity under a pubkey\n    /// @dev             does this using ecrecover because Ethereum has no soul\n    /// @param _pubkey   the public key to check (64 bytes)\n    /// @param _digest   the message digest signed\n    /// @param _v        the signature recovery value\n    /// @param _r        the signature r value\n    /// @param _s        the signature s value\n    /// @return          true if signature is valid, else false\n    function checkSig(\n        bytes memory _pubkey,\n        bytes32 _digest,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal pure returns (bool) {\n        require(_pubkey.length == 64, \"Requires uncompressed unprefixed pubkey\");\n        address _expected = accountFromPubkey(_pubkey);\n        address _actual = ecrecover(_digest, _v, _r, _s);\n        return _actual == _expected;\n    }\n\n    /// @notice                     checks a signed message against a bitcoin p2wpkh output script\n    /// @dev                        does this my verifying the p2wpkh matches an ethereum account\n    /// @param _p2wpkhOutputScript  the bitcoin output script\n    /// @param _pubkey              the uncompressed, unprefixed public key to check\n    /// @param _digest              the message digest signed\n    /// @param _v                   the signature recovery value\n    /// @param _r                   the signature r value\n    /// @param _s                   the signature s value\n    /// @return                     true if signature is valid, else false\n    function checkBitcoinSig(\n        bytes memory _p2wpkhOutputScript,\n        bytes memory _pubkey,\n        bytes32 _digest,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal pure returns (bool) {\n        require(_pubkey.length == 64, \"Requires uncompressed unprefixed pubkey\");\n\n        bool _isExpectedSigner = keccak256(p2wpkhFromPubkey(_pubkey)) == keccak256(_p2wpkhOutputScript);  // is it the expected signer?\n        if (!_isExpectedSigner) {return false;}\n\n        bool _sigResult = checkSig(_pubkey, _digest, _v, _r, _s);\n        return _sigResult;\n    }\n\n    /// @notice             checks if a message is the sha256 preimage of a digest\n    /// @dev                this is NOT the hash256!  this step is necessary for ECDSA security!\n    /// @param _digest      the digest\n    /// @param _candidate   the purported preimage\n    /// @return             true if the preimage matches the digest, else false\n    function isSha256Preimage(\n        bytes memory _candidate,\n        bytes32 _digest\n    ) internal pure returns (bool) {\n        return sha256(_candidate) == _digest;\n    }\n\n    /// @notice             checks if a message is the keccak256 preimage of a digest\n    /// @dev                this step is necessary for ECDSA security!\n    /// @param _digest      the digest\n    /// @param _candidate   the purported preimage\n    /// @return             true if the preimage matches the digest, else false\n    function isKeccak256Preimage(\n        bytes memory _candidate,\n        bytes32 _digest\n    ) internal pure returns (bool) {\n        return keccak256(_candidate) == _digest;\n    }\n\n    /// @notice                 calculates the signature hash of a Bitcoin transaction with the provided details\n    /// @dev                    documented in bip143. many values are hardcoded here\n    /// @param _outpoint        the bitcoin UTXO id (32-byte txid + 4-byte output index)\n    /// @param _inputPKH        the input pubkeyhash (hash160(sender_pubkey))\n    /// @param _inputValue      the value of the input in satoshi\n    /// @param _outputValue     the value of the output in satoshi\n    /// @param _outputScript    the length-prefixed output script\n    /// @return                 the double-sha256 (hash256) signature hash as defined by bip143\n    function wpkhSpendSighash(\n        bytes memory _outpoint,  // 36-byte UTXO id\n        bytes20 _inputPKH,       // 20-byte hash160\n        bytes8 _inputValue,      // 8-byte LE\n        bytes8 _outputValue,     // 8-byte LE\n        bytes memory _outputScript    // lenght-prefixed output script\n    ) internal pure returns (bytes32) {\n        // Fixes elements to easily make a 1-in 1-out sighash digest\n        // Does not support timelocks\n        bytes memory _scriptCode = abi.encodePacked(\n            hex\"1976a914\",  // length, dup, hash160, pkh_length\n            _inputPKH,\n            hex\"88ac\");  // equal, checksig\n        bytes32 _hashOutputs = abi.encodePacked(\n            _outputValue,  // 8-byte LE\n            _outputScript).hash256();\n        bytes memory _sighashPreimage = abi.encodePacked(\n            hex\"01000000\",  // version\n            _outpoint.hash256(),  // hashPrevouts\n            hex\"8cb9012517c817fead650287d61bdd9c68803b6bf9c64133dcab3e65b5a50cb9\",  // hashSequence(00000000)\n            _outpoint,  // outpoint\n            _scriptCode,  // p2wpkh script code\n            _inputValue,  // value of the input in 8-byte LE\n            hex\"00000000\",  // input nSequence\n            _hashOutputs,  // hash of the single output\n            hex\"00000000\",  // nLockTime\n            hex\"01000000\"  // SIGHASH_ALL\n        );\n        return _sighashPreimage.hash256();\n    }\n\n    /// @notice                 calculates the signature hash of a Bitcoin transaction with the provided details\n    /// @dev                    documented in bip143. many values are hardcoded here\n    /// @param _outpoint        the bitcoin UTXO id (32-byte txid + 4-byte output index)\n    /// @param _inputPKH        the input pubkeyhash (hash160(sender_pubkey))\n    /// @param _inputValue      the value of the input in satoshi\n    /// @param _outputValue     the value of the output in satoshi\n    /// @param _outputPKH       the output pubkeyhash (hash160(recipient_pubkey))\n    /// @return                 the double-sha256 (hash256) signature hash as defined by bip143\n    function wpkhToWpkhSighash(\n        bytes memory _outpoint,  // 36-byte UTXO id\n        bytes20 _inputPKH,  // 20-byte hash160\n        bytes8 _inputValue,  // 8-byte LE\n        bytes8 _outputValue,  // 8-byte LE\n        bytes20 _outputPKH  // 20-byte hash160\n    ) internal pure returns (bytes32) {\n        return wpkhSpendSighash(\n            _outpoint,\n            _inputPKH,\n            _inputValue,\n            _outputValue,\n            abi.encodePacked(\n              hex\"160014\",  // wpkh tag\n              _outputPKH)\n            );\n    }\n\n    /// @notice                 Preserved for API compatibility with older version\n    /// @dev                    documented in bip143. many values are hardcoded here\n    /// @param _outpoint        the bitcoin UTXO id (32-byte txid + 4-byte output index)\n    /// @param _inputPKH        the input pubkeyhash (hash160(sender_pubkey))\n    /// @param _inputValue      the value of the input in satoshi\n    /// @param _outputValue     the value of the output in satoshi\n    /// @param _outputPKH       the output pubkeyhash (hash160(recipient_pubkey))\n    /// @return                 the double-sha256 (hash256) signature hash as defined by bip143\n    function oneInputOneOutputSighash(\n        bytes memory _outpoint,  // 36-byte UTXO id\n        bytes20 _inputPKH,  // 20-byte hash160\n        bytes8 _inputValue,  // 8-byte LE\n        bytes8 _outputValue,  // 8-byte LE\n        bytes20 _outputPKH  // 20-byte hash160\n    ) internal pure returns (bytes32) {\n        return wpkhToWpkhSighash(_outpoint, _inputPKH, _inputValue, _outputValue, _outputPKH);\n    }\n\n}\n"
    },
    "solidity/contracts/external/IMedianizer.sol": {
      "content": "pragma solidity 0.5.17;\n\n/// @notice A medianizer price feed.\n/// @dev Based off the MakerDAO medianizer (https://github.com/makerdao/median)\ninterface IMedianizer {\n    /// @notice Get the current price.\n    /// @dev May revert if caller not whitelisted.\n    /// @return Designated price with 18 decimal places.\n    function read() external view returns (uint256);\n\n    /// @notice Get the current price and check if the price feed is active\n    /// @dev May revert if caller not whitelisted.\n    /// @return Designated price with 18 decimal places.\n    /// @return true if price is > 0, else returns false\n    function peek() external view returns (uint256, bool);\n}\n"
    },
    "solidity/contracts/interfaces/ISatWeiPriceFeed.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"../external/IMedianizer.sol\";\n\n/// @notice satoshi/wei price feed interface.\ninterface ISatWeiPriceFeed {\n    /// @notice Get the current price of 1 satoshi in wei.\n    /// @dev This does not account for any 'Flippening' event.\n    /// @return The price of one satoshi in wei.\n    function getPrice() external view returns (uint256);\n\n    /// @notice add a new ETH/BTC meidanizer to the internal ethBtcFeeds array\n    function addEthBtcFeed(IMedianizer _ethBtcFeed) external;\n}\n"
    },
    "solidity/contracts/price-feed/SatWeiPriceFeed.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {SafeMath} from \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"../external/IMedianizer.sol\";\nimport \"../interfaces/ISatWeiPriceFeed.sol\";\n\n/// @notice satoshi/wei price feed.\n/// @dev Used ETH/USD medianizer values converted to sat/wei.\ncontract SatWeiPriceFeed is Ownable, ISatWeiPriceFeed {\n    using SafeMath for uint256;\n\n    bool private _initialized = false;\n    address internal tbtcSystemAddress;\n\n    IMedianizer[] private ethBtcFeeds;\n\n    constructor() public {\n    // solium-disable-previous-line no-empty-blocks\n    }\n\n    /// @notice Initialises the addresses of the ETHBTC price feeds.\n    /// @param _tbtcSystemAddress Address of the `TBTCSystem` contract. Used for access control.\n    /// @param _ETHBTCPriceFeed The ETHBTC price feed address.\n    function initialize(\n        address _tbtcSystemAddress,\n        IMedianizer _ETHBTCPriceFeed\n    )\n        external onlyOwner\n    {\n        require(!_initialized, \"Already initialized.\");\n        tbtcSystemAddress = _tbtcSystemAddress;\n        ethBtcFeeds.push(_ETHBTCPriceFeed);\n        _initialized = true;\n    }\n\n    /// @notice Get the current price of 1 satoshi in wei.\n    /// @dev This does not account for any 'Flippening' event.\n    /// @return The price of one satoshi in wei.\n    function getPrice()\n        external onlyTbtcSystem view returns (uint256)\n    {\n        bool ethBtcActive = false;\n        uint256 ethBtc = 0;\n\n        for(uint i = 0; i < ethBtcFeeds.length; i++){\n            (ethBtc, ethBtcActive) = ethBtcFeeds[i].peek();\n            if(ethBtcActive) {\n                break;\n            }\n        }\n\n        require(ethBtcActive, \"Price feed offline\");\n\n        // convert eth/btc to sat/wei\n        // We typecast down to uint128, because the first 128 bits of\n        // the medianizer value is unrelated to the price.\n        return uint256(10**28).div(uint256(uint128(ethBtc)));\n    }\n\n    /// @notice Get the first active Medianizer contract from the ethBtcFeeds array.\n    /// @return The address of the first Active Medianizer. address(0) if none found\n    function getWorkingEthBtcFeed() external view returns (address){\n        bool ethBtcActive;\n\n        for(uint i = 0; i < ethBtcFeeds.length; i++){\n            (, ethBtcActive) = ethBtcFeeds[i].peek();\n            if(ethBtcActive) {\n                return address(ethBtcFeeds[i]);\n            }\n        }\n        return address(0);\n    }\n\n    /// @notice Add _newEthBtcFeed to internal ethBtcFeeds array.\n    /// @dev IMedianizer must be active in order to add.\n    function addEthBtcFeed(IMedianizer _newEthBtcFeed) external onlyTbtcSystem {\n        bool ethBtcActive;\n        (, ethBtcActive) = _newEthBtcFeed.peek();\n        require(ethBtcActive, \"Cannot add inactive feed\");\n        ethBtcFeeds.push(_newEthBtcFeed);\n    }\n\n    /// @notice Function modifier ensures modified function is only called by tbtcSystemAddress.\n    modifier onlyTbtcSystem(){\n        require(msg.sender == tbtcSystemAddress, \"Caller must be tbtcSystem contract\");\n        _;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "solidity/contracts/proxy/CloneFactory.sol": {
      "content": "pragma solidity 0.5.17;\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2018 Murray Software, LLC.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n//solhint-disable max-line-length\n\n// Implementation of [EIP-1167] based on [clone-factory]\n// source code.\n//\n// EIP 1167: https://eips.ethereum.org/EIPS/eip-1167\n// clone-factory: https://github.com/optionality/clone-factory\n// Modified to use ^0.5.10; instead of ^0.4.23 solidity version\n/* solium-disable */\n\ncontract CloneFactory {\n\n  function createClone(address target) internal returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n  function isClone(address target, address query) internal view returns (bool result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n      mstore(add(clone, 0xa), targetBytes)\n      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n      let other := add(clone, 0x40)\n      extcodecopy(query, other, 0, 0x2d)\n      result := and(\n        eq(mload(clone), mload(other)),\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n      )\n    }\n  }\n}\n"
    },
    "solidity/contracts/proxy/DepositFactory.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./CloneFactory.sol\";\nimport \"../deposit/Deposit.sol\";\nimport \"../system/TBTCSystem.sol\";\nimport \"../system/TBTCToken.sol\";\nimport \"../system/FeeRebateToken.sol\";\nimport \"../system/TBTCSystemAuthority.sol\";\nimport {TBTCDepositToken} from \"../system/TBTCDepositToken.sol\";\n\n\n/// @title Deposit Factory\n/// @notice Factory for the creation of new deposit clones.\n/// @dev We avoid redeployment of deposit contract by using the clone factory.\n/// Proxy delegates calls to Deposit and therefore does not affect deposit state.\n/// This means that we only need to deploy the deposit contracts once.\n/// The factory provides clean state for every new deposit clone.\ncontract DepositFactory is CloneFactory, TBTCSystemAuthority{\n\n    // Holds the address of the deposit contract\n    // which will be used as a master contract for cloning.\n    address payable public masterDepositAddress;\n    TBTCDepositToken tbtcDepositToken;\n    TBTCSystem public tbtcSystem;\n    TBTCToken public tbtcToken;\n    FeeRebateToken public feeRebateToken;\n    address public vendingMachineAddress;\n\n    constructor(address _systemAddress)\n        TBTCSystemAuthority(_systemAddress)\n    public {}\n\n    /// @dev                          Set the required external variables.\n    /// @param _masterDepositAddress  The address of the master deposit contract.\n    /// @param _tbtcSystem            Tbtc system contract.\n    /// @param _tbtcToken             TBTC token contract.\n    /// @param _tbtcDepositToken      TBTC Deposit Token contract.\n    /// @param _feeRebateToken        AFee Rebate Token contract.\n    /// @param _vendingMachineAddress Address of the Vending Machine contract.\n    function setExternalDependencies(\n        address payable _masterDepositAddress,\n        TBTCSystem _tbtcSystem,\n        TBTCToken _tbtcToken,\n        TBTCDepositToken _tbtcDepositToken,\n        FeeRebateToken _feeRebateToken,\n        address _vendingMachineAddress\n    ) external onlyTbtcSystem {\n        masterDepositAddress = _masterDepositAddress;\n        tbtcDepositToken = _tbtcDepositToken;\n        tbtcSystem = _tbtcSystem;\n        tbtcToken = _tbtcToken;\n        feeRebateToken = _feeRebateToken;\n        vendingMachineAddress = _vendingMachineAddress;\n    }\n\n    event DepositCloneCreated(address depositCloneAddress);\n\n    /// @notice Creates a new deposit instance and mints a TDT. This function is\n    ///         currently the only way to create a new deposit.\n    /// @dev Calls `Deposit.initializeDeposit` to initialize the instance. Mints\n    ///      the TDT to the function caller. (See `TBTCDepositToken` for more\n    ///      info on TDTs). Reverts if new deposits are currently paused, if the\n    ///      specified lot size is not currently permitted, or if the selection\n    ///      of the signers fails for any reason. Also reverts if the bonds\n    ///      collateralizing the deposit would not be enough to cover a refund\n    ///      of the deposit creation fee, should the signer group fail to\n    ///      complete its setup process.\n    /// @return The address of the new deposit.\n    function createDeposit(uint64 _lotSizeSatoshis) external payable returns(address) {\n        address cloneAddress = createClone(masterDepositAddress);\n        emit DepositCloneCreated(cloneAddress);\n\n        TBTCDepositToken(tbtcDepositToken).mint(msg.sender, uint256(cloneAddress));\n\n        Deposit deposit = Deposit(address(uint160(cloneAddress)));\n        deposit.initialize(address(this));\n        deposit.initializeDeposit.value(msg.value)(\n                tbtcSystem,\n                tbtcToken,\n                tbtcDepositToken,\n                feeRebateToken,\n                vendingMachineAddress,\n                _lotSizeSatoshis\n            );\n\n        return cloneAddress;\n    }\n}\n"
    },
    "@keep-network/keep-ecdsa/contracts/api/IBondedECDSAKeepFactory.sol": {
      "content": "/**\n     \n   \n                            \n                             \n                           \n                           \n                          \n     \n     \n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\n/// @title Bonded ECDSA Keep Factory\n/// @notice Factory for Bonded ECDSA Keeps.\ninterface IBondedECDSAKeepFactory {\n    /// @notice Open a new ECDSA Keep.\n    /// @param _groupSize Number of members in the keep.\n    /// @param _honestThreshold Minimum number of honest keep members.\n    /// @param _owner Address of the keep owner.\n    /// @param _bond Value of ETH bond required from the keep.\n    /// @param _stakeLockDuration Stake lock duration in seconds.\n    /// @return Address of the opened keep.\n    function openKeep(\n        uint256 _groupSize,\n        uint256 _honestThreshold,\n        address _owner,\n        uint256 _bond,\n        uint256 _stakeLockDuration\n    ) external payable returns (address keepAddress);\n\n    /// @notice Gets a fee estimate for opening a new keep.\n    /// @return Uint256 estimate.\n    function openKeepFeeEstimate() external view returns (uint256);\n\n    /// @notice Gets the total weight of operators\n    /// in the sortition pool for the given application.\n    /// @param _application Address of the application.\n    /// @return The sum of all registered operators' weights in the pool.\n    /// Reverts if sortition pool for the application does not exist.\n    function getSortitionPoolWeight(\n        address _application\n    ) external view returns (uint256);\n\n    /// @notice Sets the minimum bondable value required from the operator to\n    /// join the sortition pool of the given application. It is up to the\n    /// application to specify a reasonable minimum bond for operators trying to\n    /// join the pool to prevent griefing by operators joining without enough\n    /// bondable value.\n    /// @dev The default minimum bond value for each sortition pool created\n    /// is 20 ETH.\n    /// @param _minimumBondableValue The minimum unbonded value the application\n    /// requires from a single keep.\n    /// @param _groupSize Number of signers in the keep.\n    /// @param _honestThreshold Minimum number of honest keep signers.\n    function setMinimumBondableValue(\n        uint256 _minimumBondableValue,\n        uint256 _groupSize,\n        uint256 _honestThreshold\n    ) external;\n}\n"
    },
    "solidity/contracts/system/VendingMachine.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {SafeMath} from \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport {TBTCDepositToken} from \"./TBTCDepositToken.sol\";\nimport {FeeRebateToken} from \"./FeeRebateToken.sol\";\nimport {TBTCToken} from \"./TBTCToken.sol\";\nimport {TBTCConstants} from \"./TBTCConstants.sol\";\nimport \"../deposit/Deposit.sol\";\nimport \"./TBTCSystemAuthority.sol\";\n\n/// @title  Vending Machine\n/// @notice The Vending Machine swaps TDTs (`TBTCDepositToken`)\n///         to TBTC (`TBTCToken`) and vice versa.\n/// @dev    The Vending Machine should have exclusive TBTC and FRT (`FeeRebateToken`) minting\n///         privileges.\ncontract VendingMachine is TBTCSystemAuthority{\n    using SafeMath for uint256;\n\n    TBTCToken tbtcToken;\n    TBTCDepositToken tbtcDepositToken;\n    FeeRebateToken feeRebateToken;\n\n    uint256 createdAt;\n\n    constructor(address _systemAddress)\n        TBTCSystemAuthority(_systemAddress)\n    public {\n        createdAt = block.timestamp;\n    }\n\n    /// @notice Set external contracts needed by the Vending Machine.\n    /// @dev    Addresses are used to update the local contract instance.\n    /// @param _tbtcToken        TBTCToken contract. More info in `TBTCToken`.\n    /// @param _tbtcDepositToken TBTCDepositToken (TDT) contract. More info in `TBTCDepositToken`.\n    /// @param _feeRebateToken   FeeRebateToken (FRT) contract. More info in `FeeRebateToken`.\n    function setExternalAddresses(\n        TBTCToken _tbtcToken,\n        TBTCDepositToken _tbtcDepositToken,\n        FeeRebateToken _feeRebateToken\n    ) external onlyTbtcSystem {\n        tbtcToken = _tbtcToken;\n        tbtcDepositToken = _tbtcDepositToken;\n        feeRebateToken = _feeRebateToken;\n    }\n\n    /// @notice Burns TBTC and transfers the tBTC Deposit Token to the caller\n    ///         as long as it is qualified.\n    /// @dev    We burn the lotSize of the Deposit in order to maintain\n    ///         the TBTC supply peg in the Vending Machine. VendingMachine must be approved\n    ///         by the caller to burn the required amount.\n    /// @param _tdtId ID of tBTC Deposit Token to buy.\n    function tbtcToTdt(uint256 _tdtId) external {\n        require(tbtcDepositToken.exists(_tdtId), \"tBTC Deposit Token does not exist\");\n        require(isQualified(address(_tdtId)), \"Deposit must be qualified\");\n\n        uint256 depositValue = Deposit(address(uint160(_tdtId))).lotSizeTbtc();\n        require(tbtcToken.balanceOf(msg.sender) >= depositValue, \"Not enough TBTC for TDT exchange\");\n        tbtcToken.burnFrom(msg.sender, depositValue);\n\n        // TODO do we need the owner check below? transferFrom can be approved for a user, which might be an interesting use case.\n        require(tbtcDepositToken.ownerOf(_tdtId) == address(this), \"Deposit is locked\");\n        tbtcDepositToken.transferFrom(address(this), msg.sender, _tdtId);\n    }\n\n    /// @notice Transfer the tBTC Deposit Token and mint TBTC.\n    /// @dev    Transfers TDT from caller to vending machine, and mints TBTC to caller.\n    ///         Vending Machine must be approved to transfer TDT by the caller.\n    /// @param _tdtId ID of tBTC Deposit Token to sell.\n    function tdtToTbtc(uint256 _tdtId) public {\n        require(tbtcDepositToken.exists(_tdtId), \"tBTC Deposit Token does not exist\");\n        require(isQualified(address(_tdtId)), \"Deposit must be qualified\");\n\n        tbtcDepositToken.transferFrom(msg.sender, address(this), _tdtId);\n\n        Deposit deposit = Deposit(address(uint160(_tdtId)));\n        uint256 signerFee = deposit.signerFeeTbtc();\n        uint256 depositValue = deposit.lotSizeTbtc();\n\n        require(canMint(depositValue), \"Can't mint more than the max supply cap\");\n\n        // If the backing Deposit does not have a signer fee in escrow, mint it.\n        if(tbtcToken.balanceOf(address(_tdtId)) < signerFee) {\n            tbtcToken.mint(msg.sender, depositValue.sub(signerFee));\n            tbtcToken.mint(address(_tdtId), signerFee);\n        }\n        else{\n            tbtcToken.mint(msg.sender, depositValue);\n        }\n\n        // owner of the TDT during first TBTC mint receives the FRT\n        if(!feeRebateToken.exists(_tdtId)){\n            feeRebateToken.mint(msg.sender, _tdtId);\n        }\n    }\n\n    /// @notice Return whether an amount of TBTC can be minted according to the supply cap\n    ///         schedule\n    /// @dev This function is also used by TBTCSystem to decide whether to allow a new deposit.\n    /// @return True if the amount can be minted without hitting the max supply, false otherwise.\n    function canMint(uint256 amount) public view returns (bool) {\n        return getMintedSupply().add(amount) < getMaxSupply();\n    }\n\n    /// @notice Determines whether a deposit is qualified for minting TBTC.\n    /// @param _depositAddress The address of the deposit\n    function isQualified(address payable _depositAddress) public view returns (bool) {\n        return Deposit(_depositAddress).inActive();\n    }\n\n    /// @notice Return the minted TBTC supply in weitoshis (BTC * 10 ** 18).\n    function getMintedSupply() public view returns (uint256) {\n        return tbtcToken.totalSupply();\n    }\n\n    /// @notice Get the maximum TBTC token supply based on the age of the\n    ///         contract deployment. The supply cap starts at 2 BTC for the two\n    ///         days, 100 for the first week, 250 for the next, then 500, 750,\n    ///         1000, 1500, 2000, 2500, and 3000... finally removing the minting\n    ///         restriction after 9 weeks and returning 21M BTC as a sanity\n    ///         check.\n    /// @return The max supply in weitoshis (BTC * 10 ** 18).\n    function getMaxSupply() public view returns (uint256) {\n        uint256 age = block.timestamp - createdAt;\n\n        if(age < 2 days) {\n            return 2 * 10 ** 18;\n        }\n\n        if (age < 7 days) {\n            return 100 * 10 ** 18;\n        }\n\n        if (age < 14 days) {\n            return 250 * 10 ** 18;\n        }\n\n        if (age < 21 days) {\n            return 500 * 10 ** 18;\n        }\n\n        if (age < 28 days) {\n            return 750 * 10 ** 18;\n        }\n\n        if (age < 35 days) {\n            return 1000 * 10 ** 18;\n        }\n\n        if (age < 42 days) {\n            return 1500 * 10 ** 18;\n        }\n\n        if (age < 49 days) {\n            return 2000 * 10 ** 18;\n        }\n\n        if (age < 56 days) {\n            return 2500 * 10 ** 18;\n        }\n\n        if (age < 63 days) {\n            return 3000 * 10 ** 18;\n        }\n\n        return 21e6 * 10 ** 18;\n    }\n\n    // WRAPPERS\n\n    /// @notice Qualifies a deposit and mints TBTC.\n    /// @dev User must allow VendingManchine to transfer TDT.\n    function unqualifiedDepositToTbtc(\n        address payable _depositAddress,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public { // not external to allow bytes memory parameters\n        Deposit _d = Deposit(_depositAddress);\n        _d.provideBTCFundingProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n\n        tdtToTbtc(uint256(_depositAddress));\n    }\n\n    /// @notice Redeems a Deposit by purchasing a TDT with TBTC for _finalRecipient,\n    ///         and using the TDT to redeem corresponding Deposit as _finalRecipient.\n    ///         This function will revert if the Deposit is not in ACTIVE state.\n    /// @dev Vending Machine transfers TBTC allowance to Deposit.\n    /// @param  _depositAddress     The address of the Deposit to redeem.\n    /// @param  _outputValueBytes   The 8-byte Bitcoin transaction output size in Little Endian.\n    /// @param  _redeemerOutputScript The redeemer's length-prefixed output script.\n    function tbtcToBtc(\n        address payable _depositAddress,\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript\n    ) public { // not external to allow bytes memory parameters\n        require(tbtcDepositToken.exists(uint256(_depositAddress)), \"tBTC Deposit Token does not exist\");\n        Deposit _d = Deposit(_depositAddress);\n\n        tbtcToken.burnFrom(msg.sender, _d.lotSizeTbtc());\n        tbtcDepositToken.approve(_depositAddress, uint256(_depositAddress));\n\n        uint256 tbtcOwed = _d.getOwnerRedemptionTbtcRequirement(msg.sender);\n\n        if(tbtcOwed != 0){\n            tbtcToken.transferFrom(msg.sender, address(this), tbtcOwed);\n            tbtcToken.approve(_depositAddress, tbtcOwed);\n        }\n\n        _d.transferAndRequestRedemption(_outputValueBytes, _redeemerOutputScript, msg.sender);\n    }\n}\n"
    },
    "solidity/contracts/system/TBTCSystemAuthority.sol": {
      "content": "pragma solidity 0.5.17;\n\n/// @title  TBTC System Authority.\n/// @notice Contract to secure function calls to the TBTC System contract.\n/// @dev    The `TBTCSystem` contract address is passed as a constructor parameter.\ncontract TBTCSystemAuthority {\n\n    address internal tbtcSystemAddress;\n\n    /// @notice Set the address of the System contract on contract initialization.\n    constructor(address _tbtcSystemAddress) public {\n        tbtcSystemAddress = _tbtcSystemAddress;\n    }\n\n    /// @notice Function modifier ensures modified function is only called by TBTCSystem.\n    modifier onlyTbtcSystem(){\n        require(msg.sender == tbtcSystemAddress, \"Caller must be tbtcSystem contract\");\n        _;\n    }\n}\n"
    },
    "@summa-tx/relay-sol/contracts/Relay.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/** @title Relay */\n/** @author Summa (https://summa.one) */\n\nimport {SafeMath} from \"@summa-tx/bitcoin-spv-sol/contracts/SafeMath.sol\";\nimport {BytesLib} from \"@summa-tx/bitcoin-spv-sol/contracts/BytesLib.sol\";\nimport {BTCUtils} from \"@summa-tx/bitcoin-spv-sol/contracts/BTCUtils.sol\";\nimport {ValidateSPV} from \"@summa-tx/bitcoin-spv-sol/contracts/ValidateSPV.sol\";\nimport {IRelay} from \"./Interfaces.sol\";\n\ncontract Relay is IRelay {\n    using SafeMath for uint256;\n    using BytesLib for bytes;\n    using BTCUtils for bytes;\n    using ValidateSPV for bytes;\n\n    // How often do we store the height?\n    // A higher number incurs less storage cost, but more lookup cost\n    uint32 public constant HEIGHT_INTERVAL = 4;\n\n    bytes32 internal relayGenesis;\n    bytes32 internal bestKnownDigest;\n    bytes32 internal lastReorgCommonAncestor;\n    mapping (bytes32 => bytes32) internal previousBlock;\n    mapping (bytes32 => uint256) internal blockHeight;\n\n    uint256 internal currentEpochDiff;\n    uint256 internal prevEpochDiff;\n\n\n    /// @notice                   Gives a starting point for the relay\n    /// @dev                      We don't check this AT ALL really. Don't use relays with bad genesis\n    /// @param  _genesisHeader    The starting header\n    /// @param  _height           The starting height\n    /// @param  _periodStart      The hash of the first header in the genesis epoch\n    constructor(bytes memory _genesisHeader, uint256 _height, bytes32 _periodStart) public {\n        require(_genesisHeader.length == 80, \"Stop being dumb\");\n        bytes32 _genesisDigest = _genesisHeader.hash256();\n\n        require(\n            _periodStart & bytes32(0x0000000000000000000000000000000000000000000000000000000000ffffff) == bytes32(0),\n            \"Period start hash does not have work. Hint: wrong byte order?\");\n\n        relayGenesis = _genesisDigest;\n        bestKnownDigest = _genesisDigest;\n        lastReorgCommonAncestor = _genesisDigest;\n        blockHeight[_genesisDigest] = _height;\n        blockHeight[_periodStart] = _height.sub(_height % 2016);\n\n        currentEpochDiff = _genesisHeader.extractDifficulty();\n    }\n\n    /// @notice     Getter for currentEpochDiff\n    /// @dev        This is updated when a new heavist header has a new diff\n    /// @return     The difficulty of the bestKnownDigest\n    function getCurrentEpochDifficulty() external view returns (uint256) {\n        return currentEpochDiff;\n    }\n    /// @notice     Getter for prevEpochDiff\n    /// @dev        This is updated when a difficulty change is accepted\n    /// @return     The difficulty of the previous epoch\n    function getPrevEpochDifficulty() external view returns (uint256) {\n        return prevEpochDiff;\n    }\n\n    /// @notice     Getter for relayGenesis\n    /// @dev        This is an initialization parameter\n    /// @return     The hash of the first block of the relay\n    function getRelayGenesis() public view returns (bytes32) {\n        return relayGenesis;\n    }\n\n    /// @notice     Getter for bestKnownDigest\n    /// @dev        This updated only by calling markNewHeaviest\n    /// @return     The hash of the best marked chain tip\n    function getBestKnownDigest() public view returns (bytes32) {\n        return bestKnownDigest;\n    }\n\n    /// @notice     Getter for relayGenesis\n    /// @dev        This is updated only by calling markNewHeaviest\n    /// @return     The hash of the shared ancestor of the most recent fork\n    function getLastReorgCommonAncestor() public view returns (bytes32) {\n        return lastReorgCommonAncestor;\n    }\n\n    /// @notice         Finds the height of a header by its digest\n    /// @dev            Will fail if the header is unknown\n    /// @param _digest  The header digest to search for\n    /// @return         The height of the header, or error if unknown\n    function findHeight(bytes32 _digest) external view returns (uint256) {\n        return _findHeight(_digest);\n    }\n\n    /// @notice         Finds an ancestor for a block by its digest\n    /// @dev            Will fail if the header is unknown\n    /// @param _digest  The header digest to search for\n    /// @return         The height of the header, or error if unknown\n    function findAncestor(bytes32 _digest, uint256 _offset) external view returns (bytes32) {\n        return _findAncestor(_digest, _offset);\n    }\n\n    /// @notice             Checks if a digest is an ancestor of the current one\n    /// @dev                Limit the amount of lookups (and thus gas usage) with _limit\n    /// @param _ancestor    The prospective ancestor\n    /// @param _descendant  The descendant to check\n    /// @param _limit       The maximum number of blocks to check\n    /// @return             true if ancestor is at most limit blocks lower than descendant, otherwise false\n    function isAncestor(bytes32 _ancestor, bytes32 _descendant, uint256 _limit) external view returns (bool) {\n        return _isAncestor(_ancestor, _descendant, _limit);\n    }\n\n    /// @notice             Adds headers to storage after validating\n    /// @dev                We check integrity and consistency of the header chain\n    /// @param  _anchor     The header immediately preceeding the new chain\n    /// @param  _headers    A tightly-packed list of 80-byte Bitcoin headers\n    /// @return             True if successfully written, error otherwise\n    function addHeaders(bytes calldata _anchor, bytes calldata _headers) external returns (bool) {\n        return _addHeaders(_anchor, _headers, false);\n    }\n\n    /// @notice                       Adds headers to storage, performs additional validation of retarget\n    /// @dev                          Checks the retarget, the heights, and the linkage\n    /// @param  _oldPeriodStartHeader The first header in the difficulty period being closed\n    /// @param  _oldPeriodEndHeader   The last header in the difficulty period being closed\n    /// @param  _headers              A tightly-packed list of 80-byte Bitcoin headers\n    /// @return                       True if successfully written, error otherwise\n    function addHeadersWithRetarget(\n        bytes calldata _oldPeriodStartHeader,\n        bytes calldata _oldPeriodEndHeader,\n        bytes calldata _headers\n    ) external returns (bool) {\n        return _addHeadersWithRetarget(_oldPeriodStartHeader, _oldPeriodEndHeader, _headers);\n    }\n\n    /// @notice                   Gives a starting point for the relay\n    /// @dev                      We don't check this AT ALL really. Don't use relays with bad genesis\n    /// @param  _ancestor         The digest of the most recent common ancestor\n    /// @param  _currentBest      The 80-byte header referenced by bestKnownDigest\n    /// @param  _newBest          The 80-byte header to mark as the new best\n    /// @param  _limit            Limit the amount of traversal of the chain\n    /// @return                   True if successfully updates bestKnownDigest, error otherwise\n    function markNewHeaviest(\n        bytes32 _ancestor,\n        bytes calldata _currentBest,\n        bytes calldata _newBest,\n        uint256 _limit\n    ) external returns (bool) {\n        return _markNewHeaviest(_ancestor, _currentBest, _newBest, _limit);\n    }\n\n    /// @notice             Adds headers to storage after validating\n    /// @dev                We check integrity and consistency of the header chain\n    /// @param  _anchor     The header immediately preceeding the new chain\n    /// @param  _headers    A tightly-packed list of new 80-byte Bitcoin headers to record\n    /// @param  _internal   True if called internally from addHeadersWithRetarget, false otherwise\n    /// @return             True if successfully written, error otherwise\n    function _addHeaders(bytes memory _anchor, bytes memory _headers, bool _internal) internal returns (bool) {\n        uint256 _height;\n        bytes memory _header;\n        bytes32 _currentDigest;\n        bytes32 _previousDigest = _anchor.hash256();\n\n        uint256 _target = _headers.slice(0, 80).extractTarget();\n        uint256 _anchorHeight = _findHeight(_previousDigest);  /* NB: errors if unknown */\n\n        require(\n            _internal || _anchor.extractTarget() == _target,\n            \"Unexpected retarget on external call\");\n        require(_headers.length % 80 == 0, \"Header array length must be divisible by 80\");\n\n        /*\n        NB:\n        1. check that the header has sufficient work\n        2. check that headers are in a coherent chain (no retargets, hash links good)\n        3. Store the block connection\n        4. Store the height\n        */\n        for (uint256 i = 0; i < _headers.length / 80; i = i.add(1)) {\n            _header = _headers.slice(i.mul(80), 80);\n            _height = _anchorHeight.add(i + 1);\n            _currentDigest = _header.hash256();\n\n            /*\n            NB:\n            if the block is already authenticated, we don't need to a work check\n            Or write anything to state. This saves gas\n            */\n            if (previousBlock[_currentDigest] == bytes32(0)) {\n                require(\n                    abi.encodePacked(_currentDigest).reverseEndianness().bytesToUint() <= _target,\n                    \"Header work is insufficient\");\n                previousBlock[_currentDigest] = _previousDigest;\n                if (_height % HEIGHT_INTERVAL == 0) {\n                    /*\n                    NB: We store the height only every 4th header to save gas\n                    */\n                    blockHeight[_currentDigest] = _height;\n                }\n            }\n\n            /* NB: we do still need to make chain level checks tho */\n            require(_header.extractTarget() == _target, \"Target changed unexpectedly\");\n            require(_header.validateHeaderPrevHash(_previousDigest), \"Headers do not form a consistent chain\");\n\n            _previousDigest = _currentDigest;\n        }\n\n        emit Extension(\n            _anchor.hash256(),\n            _currentDigest);\n        return true;\n    }\n\n    /// @notice                       Adds headers to storage, performs additional validation of retarget\n    /// @dev                          Checks the retarget, the heights, and the linkage\n    /// @param  _oldPeriodStartHeader The first header in the difficulty period being closed\n    /// @param  _oldPeriodEndHeader   The last header in the difficulty period being closed\n    /// @param  _headers              A tightly-packed list of 80-byte Bitcoin headers\n    /// @return                       True if successfully written, error otherwise\n    function _addHeadersWithRetarget(\n        bytes memory _oldPeriodStartHeader,\n        bytes memory _oldPeriodEndHeader,\n        bytes memory _headers\n    ) internal returns (bool) {\n        /* NB: requires that both blocks are known */\n        uint256 _startHeight = _findHeight(_oldPeriodStartHeader.hash256());\n        uint256 _endHeight = _findHeight(_oldPeriodEndHeader.hash256());\n\n        /* NB: retargets should happen at 2016 block intervals */\n        require(\n            _endHeight % 2016 == 2015,\n            \"Must provide the last header of the closing difficulty period\");\n        require(\n            _endHeight == _startHeight.add(2015),\n            \"Must provide exactly 1 difficulty period\");\n        require(\n            _oldPeriodStartHeader.extractDifficulty() == _oldPeriodEndHeader.extractDifficulty(),\n            \"Period header difficulties do not match\");\n\n        /* NB: This comparison looks weird because header nBits encoding truncates targets */\n        bytes memory _newPeriodStart = _headers.slice(0, 80);\n        uint256 _actualTarget = _newPeriodStart.extractTarget();\n        uint256 _expectedTarget = BTCUtils.retargetAlgorithm(\n            _oldPeriodStartHeader.extractTarget(),\n            _oldPeriodStartHeader.extractTimestamp(),\n            _oldPeriodEndHeader.extractTimestamp()\n        );\n        require(\n            (_actualTarget & _expectedTarget) == _actualTarget,\n            \"Invalid retarget provided\");\n\n        // If the current known prevEpochDiff doesn't match, and this old period is near the chaintip/\n        // update the stored prevEpochDiff\n        // Don't update if this is a deep past epoch\n        uint256 _oldDiff = _oldPeriodStartHeader.extractDifficulty();\n        if (prevEpochDiff != _oldDiff && _endHeight > _findHeight(bestKnownDigest).sub(2016)) {\n            prevEpochDiff = _oldDiff;\n        }\n\n        // Pass all but the first through to be added\n        return _addHeaders(_oldPeriodEndHeader, _headers, true);\n    }\n\n    /// @notice         Finds the height of a header by its digest\n    /// @dev            Will fail if the header is unknown\n    /// @param _digest  The header digest to search for\n    /// @return         The height of the header\n    function _findHeight(bytes32 _digest) internal view returns (uint256) {\n        uint256 _height = 0;\n        bytes32 _current = _digest;\n        for (uint256 i = 0; i < HEIGHT_INTERVAL + 1; i = i.add(1)) {\n            _height = blockHeight[_current];\n            if (_height == 0) {\n                _current = previousBlock[_current];\n            } else {\n                return _height.add(i);\n            }\n        }\n        revert(\"Unknown block\");\n    }\n\n    /// @notice         Finds an ancestor for a block by its digest\n    /// @dev            Will fail if the header is unknown\n    /// @param _digest  The header digest to search for\n    /// @return         The height of the header, or error if unknown\n    function _findAncestor(bytes32 _digest, uint256 _offset) internal view returns (bytes32) {\n        bytes32 _current = _digest;\n        for (uint256 i = 0; i < _offset; i = i.add(1)) {\n            _current = previousBlock[_current];\n        }\n        require(_current != bytes32(0), \"Unknown ancestor\");\n        return _current;\n    }\n\n    /// @notice             Checks if a digest is an ancestor of the current one\n    /// @dev                Limit the amount of lookups (and thus gas usage) with _limit\n    /// @param _ancestor    The prospective ancestor\n    /// @param _descendant  The descendant to check\n    /// @param _limit       The maximum number of blocks to check\n    /// @return             true if ancestor is at most limit blocks lower than descendant, otherwise false\n    function _isAncestor(bytes32 _ancestor, bytes32 _descendant, uint256 _limit) internal view returns (bool) {\n        bytes32 _current = _descendant;\n        /* NB: 200 gas/read, so gas is capped at ~200 * limit */\n        for (uint256 i = 0; i < _limit; i = i.add(1)) {\n            if (_current == _ancestor) {\n                return true;\n            }\n            _current = previousBlock[_current];\n        }\n        return false;\n    }\n\n    /// @notice                   Marks the new best-known chain tip\n    /// @param  _ancestor         The digest of the most recent common ancestor\n    /// @param  _currentBest      The 80-byte header referenced by bestKnownDigest\n    /// @param  _newBest          The 80-byte header to mark as the new best\n    /// @param  _limit            Limit the amount of traversal of the chain\n    /// @return                   True if successfully updates bestKnownDigest, error otherwise\n    function _markNewHeaviest(\n        bytes32 _ancestor,\n        bytes memory _currentBest,\n        bytes memory _newBest,\n        uint256 _limit\n    ) internal returns (bool) {\n        require(_limit <= 2016, \"Requested limit is greater than 1 difficulty period\");\n        bytes32 _newBestDigest = _newBest.hash256();\n        bytes32 _currentBestDigest = _currentBest.hash256();\n        require(_currentBestDigest == bestKnownDigest, \"Passed in best is not best known\");\n        require(\n            previousBlock[_newBestDigest] != bytes32(0),\n            \"New best is unknown\");\n        require(\n            _isMostRecentAncestor(_ancestor, bestKnownDigest, _newBestDigest, _limit),\n            \"Ancestor must be heaviest common ancestor\");\n        require(\n            _heaviestFromAncestor(_ancestor, _currentBest, _newBest) == _newBestDigest,\n            \"New best hash does not have more work than previous\");\n\n        bestKnownDigest = _newBestDigest;\n        lastReorgCommonAncestor = _ancestor;\n\n        uint256 _newDiff = _newBest.extractDifficulty();\n        if (_newDiff != currentEpochDiff) {\n            currentEpochDiff = _newDiff;\n        }\n\n        emit NewTip(\n            _currentBestDigest,\n            _newBestDigest,\n            _ancestor);\n        return true;\n    }\n\n    /// @notice             Checks if a digest is an ancestor of the current one\n    /// @dev                Limit the amount of lookups (and thus gas usage) with _limit\n    /// @param _ancestor    The prospective shared ancestor\n    /// @param _left        A chain tip\n    /// @param _right       A chain tip\n    /// @param _limit       The maximum number of blocks to check\n    /// @return             true if it is the most recent common ancestor within _limit, false otherwise\n    function _isMostRecentAncestor(\n        bytes32 _ancestor,\n        bytes32 _left,\n        bytes32 _right,\n        uint256 _limit\n    ) internal view returns (bool) {\n        /* NB: sure why not */\n        if (_ancestor == _left && _ancestor == _right) {\n            return true;\n        }\n\n        bytes32 _leftCurrent = _left;\n        bytes32 _rightCurrent = _right;\n        bytes32 _leftPrev = _left;\n        bytes32 _rightPrev = _right;\n\n        for(uint256 i = 0; i < _limit; i = i.add(1)) {\n            if (_leftPrev != _ancestor) {\n                _leftCurrent = _leftPrev;  // cheap\n                _leftPrev = previousBlock[_leftPrev];  // expensive\n            }\n            if (_rightPrev != _ancestor) {\n                _rightCurrent = _rightPrev;  // cheap\n                _rightPrev = previousBlock[_rightPrev];  // expensive\n            }\n        }\n        if (_leftCurrent == _rightCurrent) {return false;} /* NB: If the same, they're a nearer ancestor */\n        if (_leftPrev != _rightPrev) {return false;} /* NB: Both must be ancestor */\n        return true;\n    }\n\n    /// @notice             Decides which header is heaviest from the ancestor\n    /// @dev                Does not support reorgs above 2017 blocks (:\n    /// @param _ancestor    The prospective shared ancestor\n    /// @param _left        A chain tip\n    /// @param _right       A chain tip\n    /// @return             true if it is the most recent common ancestor within _limit, false otherwise\n    function _heaviestFromAncestor(\n        bytes32 _ancestor,\n        bytes memory _left,\n        bytes memory _right\n    ) internal view returns (bytes32) {\n        uint256 _ancestorHeight = _findHeight(_ancestor);\n        uint256 _leftHeight = _findHeight(_left.hash256());\n        uint256 _rightHeight = _findHeight(_right.hash256());\n\n        require(\n            _leftHeight >= _ancestorHeight && _rightHeight >= _ancestorHeight,\n            \"A descendant height is below the ancestor height\");\n\n        /* NB: we can shortcut if one block is in a new difficulty window and the other isn't */\n        uint256 _nextPeriodStartHeight = _ancestorHeight.add(2016).sub(_ancestorHeight % 2016);\n        bool _leftInPeriod = _leftHeight < _nextPeriodStartHeight;\n        bool _rightInPeriod = _rightHeight < _nextPeriodStartHeight;\n\n        /*\n        NB:\n        1. Left is in a new window, right is in the old window. Left is heavier\n        2. Right is in a new window, left is in the old window. Right is heavier\n        3. Both are in the same window, choose the higher one\n        4. They're in different new windows. Choose the heavier one\n        */\n        if (!_leftInPeriod && _rightInPeriod) {return _left.hash256();}\n        if (_leftInPeriod && !_rightInPeriod) {return _right.hash256();}\n        if (_leftInPeriod && _rightInPeriod) {\n            return _leftHeight >= _rightHeight ? _left.hash256() : _right.hash256();\n        } else {  // if (!_leftInPeriod && !_rightInPeriod) {\n            if (((_leftHeight % 2016).mul(_left.extractDifficulty())) <\n                (_rightHeight % 2016).mul(_right.extractDifficulty())) {\n                return _right.hash256();\n            } else {\n                return _left.hash256();\n            }\n        }\n    }\n}\n\n// For unittests\ncontract TestRelay is Relay {\n\n    /// @notice                   Gives a starting point for the relay\n    /// @dev                      We don't check this AT ALL really. Don't use relays with bad genesis\n    /// @param  _genesisHeader    The starting header\n    /// @param  _height           The starting height\n    /// @param  _periodStart      The hash of the first header in the genesis epoch\n    constructor(bytes memory _genesisHeader, uint256 _height, bytes32 _periodStart)\n        Relay(_genesisHeader, _height, _periodStart)\n    public {}\n\n    function heaviestFromAncestor(\n        bytes32 _ancestor,\n        bytes calldata _left,\n        bytes calldata _right\n    ) external view returns (bytes32) {\n        return _heaviestFromAncestor(_ancestor, _left, _right);\n    }\n\n    function isMostRecentAncestor(\n        bytes32 _ancestor,\n        bytes32 _left,\n        bytes32 _right,\n        uint256 _limit\n    ) external view returns (bool) {\n        return _isMostRecentAncestor(_ancestor, _left, _right, _limit);\n    }\n}\n"
    },
    "@summa-tx/relay-sol/contracts/Interfaces.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/// @title      ISPVConsumer\n/// @author     Summa (https://summa.one)\n/// @notice     This interface consumes validated transaction information.\n///             It is the primary way that user contracts accept\n/// @dev        Implement this interface to process transactions provided by\n///             the Relay system.\ninterface ISPVConsumer {\n    /// @notice     A consumer for Bitcoin transaction information.\n    /// @dev        Users must implement this function. It handles Bitcoin\n    ///             events that have been validated by the Relay contract.\n    ///             It is VERY IMPORTANT that this function validates the\n    ///             msg.sender. The callee must check the origin of the data\n    ///             or risk accepting spurious information.\n    /// @param _txid        The LE(!) txid of the bitcoin transaction that\n    ///                     triggered the notification.\n    /// @param _vin         The length-prefixed input vector of the bitcoin tx\n    ///                     that triggered the notification.\n    /// @param _vout        The length-prefixed output vector of the bitcoin tx\n    ///                     that triggered the notification.\n    /// @param _requestID   The ID of the event request that this notification\n    ///                     satisfies. The ID is returned by\n    ///                     OnDemandSPV.request and should be locally stored by\n    ///                     any contract that makes more than one request.\n    /// @param _inputIndex  The index of the input in the _vin that triggered\n    ///                     the notification.\n    /// @param _outputIndex The index of the output in the _vout that triggered\n    ///                     the notification. Useful for subscribing to transactions\n    ///                     that spend the newly-created UTXO.\n    function spv(\n        bytes32 _txid,\n        bytes calldata _vin,\n        bytes calldata _vout,\n        uint256 _requestID,\n        uint8 _inputIndex,\n        uint8 _outputIndex) external;\n}\n\n/// @title      ISPVRequestManager\n/// @author     Summa (https://summa.one)\n/// @notice     The interface for using the OnDemandSPV system. This interface\n///             allows you to subscribe to Bitcoin events.\n/// @dev        Manage subscriptions to Bitcoin events. Register callbacks to\n///             be called whenever specific Bitcoin transactions are made.\ninterface ISPVRequestManager {\n    event NewProofRequest (\n        address indexed _requester,\n        uint256 indexed _requestID,\n        uint64 _paysValue,\n        bytes _spends,\n        bytes _pays\n    );\n\n    event RequestClosed(uint256 indexed _requestID);\n    event RequestFilled(bytes32 indexed _txid, uint256 indexed _requestID);\n\n    /// @notice             Subscribe to a feed of Bitcoin transactions matching a request\n    /// @dev                The request can be a spent utxo and/or a created utxo.\n    ///\n    ///                     The contract allows users to register a \"consumer\" contract\n    ///                     that implements ISPVConsumer to handle Bitcoin events.\n    ///\n    ///                     Bitcoin transactions are composed of a vector of inputs,\n    ///                     and a vector of outputs. The `_spends` parameter allows consumers\n    ///                     to watch a specific UTXO, and receive an event when it is spent.\n    ///\n    ///                     The `_pays` and `_paysValue` param allow the user to watch specific\n    ///                     Bitcoin output scripts. An output script is typically encoded\n    ///                     as an address, but an address is not an in-protocol construction.\n    ///                     In other words, consumers will receive an event whenever a specific\n    ///                     address receives funds, or when a specific OP_RETURN is created.\n    ///\n    ///                     Either `_spends` or `_pays` MUST be set. Both MAY be set.\n    ///                     If both are set, only notifications meeting both criteria\n    ///                     will be triggered.\n    ///\n    /// @param  _spends     An outpoint that must be spent in acceptable transactions.\n    ///                     The outpoint must be exactly 36 bytes, and composed of a\n    ///                     LE txid (32 bytes), and an 4-byte LE-encoded index integer.\n    ///                     In other words, the precise serialization format used in a\n    ///                     serialized Bitcoin TxIn.\n    ///\n    ///                     Note that while we might expect a `_spends` event to fire at most\n    ///                     one time, that expectation becomes invalid in long Bitcoin reorgs\n    ///                     if there is a double-spend or a disconfirmation followed by\n    ///                     reconfirmation.\n    ///\n    /// @param  _pays       An output script to watch for events. A filter with `_pays` set will\n    ///                     validate any number of events that create new UTXOs with a specific\n    ///                     output script.\n    ///\n    ///                     This is useful for watching an address and responding to incoming\n    ///                     payments.\n    ///\n    /// @param  _paysValue  A minimum value in satoshi that must be paid to the output script.\n    ///                     If this is set no any non-0 number, the Relay will only forward\n    ///                     `_pays` notifications to the consumer if the value of the new UTXO is\n    ///                     at least `_paysValue`.\n    ///\n    /// @param  _consumer   The address of a contract that implements the `ISPVConsumer` interface.\n    ///                     Whenever events are available, the Relay will validate inclusion\n    ///                     and confirmation, then call the `spv` function on the consumer.\n    ///\n    /// @param  _numConfs   The number of headers that must confirm the block\n    ///                     containing the transaction. Used as a security parameter.\n    ///                     More confirmations means less likely to revert due to a\n    ///                     chain reorganization. Note that 1 confirmation is required,\n    ///                     so the general \"6 confirmation\" rule would be expressed\n    ///                     as `5` when calling this function\n    ///\n    /// @param  _notBefore  An Ethereum timestamp before which proofs will not be accepted.\n    ///                     Used to control app flow for specific users.\n    ///\n    /// @return             A unique request ID.\n    function request(\n        bytes calldata _spends,\n        bytes calldata _pays,\n        uint64 _paysValue,\n        address _consumer,\n        uint8 _numConfs,\n        uint256 _notBefore\n    ) external returns (uint256);\n\n    /// @notice                 Cancel an active bitcoin event request.\n    /// @dev                    Prevents the relay from forwarding tx information\n    /// @param  _requestID      The ID of the request to be cancelled\n    /// @return                 True if succesful, error otherwise\n    function cancelRequest(uint256 _requestID) external returns (bool);\n\n    /// @notice             Retrieve info about a request\n    /// @dev                Requests ids are numerical\n    /// @param  _requestID  The numerical ID of the request\n    /// @return             A tuple representation of the request struct.\n    ///                     To save space`spends` and `pays` are stored as keccak256\n    ///                     hashes of the original information. The `state` is\n    ///                     `0` for \"does not exist\", `1` for \"active\" and `2` for\n    ///                     \"cancelled.\"\n    function getRequest(\n        uint256 _requestID\n    ) external view returns (\n        bytes32 spends,\n        bytes32 pays,\n        uint64 paysValue,\n        uint8 state,\n        address consumer,\n        address owner,\n        uint8 numConfs,\n        uint256 notBefore\n    );\n}\n\n\n\ninterface IRelay {\n    event Extension(bytes32 indexed _first, bytes32 indexed _last);\n    event NewTip(bytes32 indexed _from, bytes32 indexed _to, bytes32 indexed _gcd);\n\n    function getCurrentEpochDifficulty() external view returns (uint256);\n    function getPrevEpochDifficulty() external view returns (uint256);\n    function getRelayGenesis() external view returns (bytes32);\n    function getBestKnownDigest() external view returns (bytes32);\n    function getLastReorgCommonAncestor() external view returns (bytes32);\n\n    function findHeight(bytes32 _digest) external view returns (uint256);\n\n    function findAncestor(bytes32 _digest, uint256 _offset) external view returns (bytes32);\n\n    function isAncestor(bytes32 _ancestor, bytes32 _descendant, uint256 _limit) external view returns (bool);\n\n    function addHeaders(bytes calldata _anchor, bytes calldata _headers) external returns (bool);\n\n    function addHeadersWithRetarget(\n        bytes calldata _oldPeriodStartHeader,\n        bytes calldata _oldPeriodEndHeader,\n        bytes calldata _headers\n    ) external returns (bool);\n\n    function markNewHeaviest(\n        bytes32 _ancestor,\n        bytes calldata _currentBest,\n        bytes calldata _newBest,\n        uint256 _limit\n    ) external returns (bool);\n}\n"
    },
    "solidity/contracts/system/KeepFactorySelection.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {IBondedECDSAKeepFactory} from \"@keep-network/keep-ecdsa/contracts/api/IBondedECDSAKeepFactory.sol\";\n\n/// @title Bonded ECDSA keep factory selection strategy.\n/// @notice The strategy defines the algorithm for selecting a factory. tBTC\n/// uses two bonded ECDSA keep factories, selecting one of them for each new\n/// deposit being opened.\ninterface KeepFactorySelector {\n\n    /// @notice Selects keep factory for the new deposit.\n    /// @param _seed Request seed.\n    /// @param _keepStakedFactory Regular, KEEP-stake based keep factory.\n    /// @param _fullyBackedFactory Fully backed, ETH-bond-only based keep factory.\n    /// @return The selected keep factory.\n    function selectFactory(\n        uint256 _seed,\n        IBondedECDSAKeepFactory _keepStakedFactory,\n        IBondedECDSAKeepFactory _fullyBackedFactory\n    ) external view returns (IBondedECDSAKeepFactory);\n}\n\n/// @title Bonded ECDSA keep factory selection library.\n/// @notice tBTC uses two bonded ECDSA keep factories: one based on KEEP stake\n/// and ETH bond, and another based only on ETH bond. The library holds\n/// a reference to both factories as well as a reference to a selection strategy\n/// deciding which factory to choose for the new deposit being opened.\nlibrary KeepFactorySelection {\n\n    struct Storage {\n        uint256 requestCounter;\n\n        IBondedECDSAKeepFactory selectedFactory;\n\n        KeepFactorySelector factorySelector;\n\n        // Standard ECDSA keep factory: KEEP stake and ETH bond.\n        // Guaranteed to be set for initialized factory.\n        IBondedECDSAKeepFactory keepStakedFactory;\n\n        // Fully backed ECDSA keep factory: ETH bond only.\n        IBondedECDSAKeepFactory fullyBackedFactory;\n    }\n\n    /// @notice Initializes the library with the default KEEP-stake-based\n    /// factory. The default factory is guaranteed to be set and this function\n    /// must be called when creating contract using this library.\n    /// @dev This function can be called only one time.\n    function initialize(\n        Storage storage _self,\n        IBondedECDSAKeepFactory _defaultFactory\n    ) public {\n        require(\n            address(_self.keepStakedFactory) == address(0),\n            \"Already initialized\"\n        );\n\n        _self.keepStakedFactory = IBondedECDSAKeepFactory(_defaultFactory);\n        _self.selectedFactory = _self.keepStakedFactory;\n    }\n\n    /// @notice Returns the selected keep factory.\n    /// This function guarantees that the same factory is returned for every\n    /// call until selectFactoryAndRefresh is executed. This lets to evaluate\n    /// open keep fee estimate on the same factory that will be used later for\n    /// opening a new keep (fee estimate and open keep requests are two\n    /// separate calls).\n    /// @return Selected keep factory. The same vale will be returned for every\n    /// call of this function until selectFactoryAndRefresh is executed.\n    function selectFactory(\n        Storage storage _self\n    ) public view returns (IBondedECDSAKeepFactory) {\n        return _self.selectedFactory;\n    }\n\n    /// @notice Returns the selected keep factory and refreshes the choice\n    /// for the next select call. The value returned by this function has been\n    /// evaluated during the previous call. This lets to return the same value\n    /// from selectFactory and selectFactoryAndRefresh, thus, allowing to use\n    /// the same factory for which open keep fee estimate was evaluated (fee\n    /// estimate and open keep requests are two separate calls).\n    /// @return Selected keep factory.\n    function selectFactoryAndRefresh(\n        Storage storage _self\n    ) external returns (IBondedECDSAKeepFactory) {\n        IBondedECDSAKeepFactory factory = selectFactory(_self);\n        refreshFactory(_self);\n\n        return factory;\n    }\n\n    /// @notice Sets the minimum bondable value required from the operator to\n    /// join the sortition pool for tBTC.\n    /// @param _minimumBondableValue The minimum bond value the application\n    /// requires from a single keep.\n    /// @param _groupSize Number of signers in the keep.\n    /// @param _honestThreshold Minimum number of honest keep signers.\n    function setMinimumBondableValue(\n        Storage storage _self,\n        uint256 _minimumBondableValue,\n        uint256 _groupSize,\n        uint256 _honestThreshold\n    ) external {\n        if (address(_self.keepStakedFactory) != address(0)) {\n            _self.keepStakedFactory.setMinimumBondableValue(\n                _minimumBondableValue,\n                _groupSize,\n                _honestThreshold\n            );\n        }\n        if (address(_self.fullyBackedFactory) != address(0)) {\n            _self.fullyBackedFactory.setMinimumBondableValue(\n                _minimumBondableValue,\n                _groupSize,\n                _honestThreshold\n            );\n        }\n    }\n\n    /// @notice Refreshes the keep factory choice. If either ETH-bond-only factory\n    /// or selection strategy is not set, KEEP-stake factory is selected.\n    /// Otherwise, calls selection strategy providing addresses of both\n    /// factories to make a choice. Additionally, passes the selection seed\n    /// evaluated from the current request counter value.\n    function refreshFactory(Storage storage _self) internal {\n        if (\n            address(_self.fullyBackedFactory) == address(0) ||\n            address(_self.factorySelector) == address(0)\n        ) {\n            // KEEP-stake factory is guaranteed to be there. If the selection\n            // can not be performed, this is the default choice.\n            _self.selectedFactory = _self.keepStakedFactory;\n            return;\n        }\n\n        _self.requestCounter++;\n        uint256 seed = uint256(\n            keccak256(abi.encodePacked(address(this), _self.requestCounter))\n        );\n        _self.selectedFactory = _self.factorySelector.selectFactory(\n            seed,\n            _self.keepStakedFactory,\n            _self.fullyBackedFactory\n        );\n\n        require(\n            _self.selectedFactory == _self.keepStakedFactory ||\n                _self.selectedFactory == _self.fullyBackedFactory,\n            \"Factory selector returned unknown factory\"\n        );\n    }\n\n    /// @notice Sets addresses of the keep factories and the selection strategy\n    /// contracts.\n    /// KeepFactorySelection can work without the keep factory selection\n    /// strategy set, always selecting the default KEEP-stake-based factory.\n    /// Once both fully-backed keep factory and factory selection strategy are\n    /// set, KEEP-stake-based factory is no longer the default choice and it is\n    /// up to the selection strategy to decide which factory should be chosen.\n    /// @dev Can be called multiple times! It's responsibility of a contract\n    /// using this library to limit and protect updates.\n    /// @param _keepStakedFactory Address of the regular, KEEP-stake based keep\n    /// factory.\n    /// @param _fullyBackedFactory Address of the fully-backed, ETH-bond-only based\n    /// keep factory.\n    /// @param _factorySelector Address of the keep factory selection strategy.\n    function setFactories(\n        Storage storage _self,\n        address _keepStakedFactory,\n        address _fullyBackedFactory,\n        address _factorySelector\n    ) internal {\n        require(\n            address(_keepStakedFactory) != address(0),\n            \"Invalid KEEP-staked factory address\"\n        );\n\n        _self.keepStakedFactory = IBondedECDSAKeepFactory(_keepStakedFactory);\n        _self.fullyBackedFactory = IBondedECDSAKeepFactory(_fullyBackedFactory);\n        _self.factorySelector = KeepFactorySelector(_factorySelector);\n    }\n}\n"
    },
    "solidity/contracts/scripts/FundingScript.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {ITokenRecipient} from \"../interfaces/ITokenRecipient.sol\";\nimport {TBTCDepositToken} from \"../system/TBTCDepositToken.sol\";\nimport {TBTCToken} from \"../system/TBTCToken.sol\";\nimport {FeeRebateToken} from \"../system/FeeRebateToken.sol\";\nimport {VendingMachine} from \"../system/VendingMachine.sol\";\n\n/// @notice A one-click script for minting TBTC from an unqualified TDT.\n/// @dev Wrapper script for VendingMachine.unqualifiedDepositToTbtc\n/// This contract implements receiveApproval() and can therefore use\n/// approveAndCall(). This pattern combines TBTC Token approval and\n/// vendingMachine.unqualifiedDepositToTbtc() in a single transaction.\ncontract FundingScript is ITokenRecipient {\n    TBTCToken tbtcToken;\n    VendingMachine vendingMachine;\n    TBTCDepositToken tbtcDepositToken;\n    FeeRebateToken feeRebateToken;\n\n    constructor(\n        address _VendingMachine,\n        address _TBTCToken,\n        address _TBTCDepositToken,\n        address _FeeRebateToken\n    ) public {\n        vendingMachine = VendingMachine(_VendingMachine);\n        tbtcToken = TBTCToken(_TBTCToken);\n        tbtcDepositToken = TBTCDepositToken(_TBTCDepositToken);\n        feeRebateToken = FeeRebateToken(_FeeRebateToken);\n    }\n\n    /// @notice Receives approval for a TDT transfer, and calls `VendingMachine.unqualifiedDepositToTbtc` for a user.\n    /// @dev Implements the approveAndCall receiver interface.\n    /// @param _from The owner of the token who approved them for transfer.\n    /// @param _tokenId Approved TDT for the transfer.\n    /// @param _extraData Encoded function call to `VendingMachine.unqualifiedDepositToTbtc`.\n    function receiveApproval(\n        address _from,\n        uint256 _tokenId,\n        address,\n        bytes memory _extraData\n    ) public { // not external to allow bytes memory parameters\n        require(msg.sender == address(tbtcDepositToken), \"Only token contract can call receiveApproval\");\n\n        tbtcDepositToken.transferFrom(_from, address(this), _tokenId);\n        tbtcDepositToken.approve(address(vendingMachine), _tokenId);\n\n        // Verify _extraData is a call to unqualifiedDepositToTbtc.\n        bytes4 functionSignature;\n        assembly {\n            functionSignature := and(mload(add(_extraData, 0x20)), not(0xff))\n        }\n        require(\n            functionSignature == vendingMachine.unqualifiedDepositToTbtc.selector,\n            \"Bad _extraData signature. Call must be to unqualifiedDepositToTbtc.\"\n        );\n\n        // Call the VendingMachine.\n        // We could explictly encode the call to vending machine, but this would\n        // involve manually parsing _extraData and allocating variables.\n        // We capture the `returnData` in order to forward any nested revert message\n        // from the contract call.\n        /* solium-disable-next-line security/no-low-level-calls */\n        (bool success, bytes memory returnData) = address(vendingMachine).call(_extraData);\n\n        string memory revertMessage;\n        assembly {\n            // A revert message is ABI-encoded as a call to Error(string).\n            // Slicing the Error() signature (4 bytes) and Data offset (4 bytes)\n            // leaves us with a pre-encoded string.\n            // We also slice off the ABI-coded length of returnData (32).\n            revertMessage := add(returnData, 0x44)\n        }\n\n        require(success, revertMessage);\n\n        // Transfer the TBTC and feeRebateToken to the user.\n        tbtcToken.transfer(_from, tbtcToken.balanceOf(address(this)));\n        feeRebateToken.transferFrom(address(this), _from, uint256(_tokenId));\n    }\n}\n"
    },
    "solidity/contracts/scripts/RedemptionScript.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport {ITokenRecipient} from \"../interfaces/ITokenRecipient.sol\";\nimport {TBTCDepositToken} from \"../system/TBTCDepositToken.sol\";\nimport {TBTCToken} from \"../system/TBTCToken.sol\";\nimport {FeeRebateToken} from \"../system/FeeRebateToken.sol\";\nimport {VendingMachine} from \"../system/VendingMachine.sol\";\nimport {Deposit} from \"../deposit/Deposit.sol\";\nimport {BytesLib} from \"@summa-tx/bitcoin-spv-sol/contracts/BytesLib.sol\";\n\n/// @notice A one-click script for redeeming TBTC into BTC.\n/// @dev Wrapper script for VendingMachine.tbtcToBtc\n/// This contract implements receiveApproval() and can therefore use\n/// approveAndCall(). This pattern combines TBTC Token approval and\n/// vendingMachine.tbtcToBtc() in a single transaction.\ncontract RedemptionScript is ITokenRecipient {\n    using BytesLib for bytes;\n\n    TBTCToken tbtcToken;\n    VendingMachine vendingMachine;\n    FeeRebateToken feeRebateToken;\n\n    constructor(\n        address _VendingMachine,\n        address _TBTCToken,\n        address _FeeRebateToken\n    ) public {\n        vendingMachine = VendingMachine(_VendingMachine);\n        tbtcToken = TBTCToken(_TBTCToken);\n        feeRebateToken = FeeRebateToken(_FeeRebateToken);\n    }\n\n    /// @notice Receives approval for a TBTC transfer, and calls `VendingMachine.tbtcToBtc` for a user.\n    /// @dev Implements the approveAndCall receiver interface.\n    /// @param _from The owner of the token who approved them for transfer.\n    /// @param _amount Approved TBTC amount for the transfer.\n    /// @param _extraData Encoded function call to `VendingMachine.tbtcToBtc`.\n    function receiveApproval(\n        address _from,\n        uint256 _amount,\n        address,\n        bytes memory _extraData\n    ) public { // not external to allow bytes memory parameters\n        require(msg.sender == address(tbtcToken), \"Only token contract can call receiveApproval\");\n\n        tbtcToken.transferFrom(_from, address(this), _amount);\n        tbtcToken.approve(address(vendingMachine), _amount);\n\n        // Verify _extraData is a call to tbtcToBtc.\n        bytes4 functionSignature;\n        assembly {\n            functionSignature := and(mload(add(_extraData, 0x20)), not(0xff))\n        }\n        require(\n            functionSignature == vendingMachine.tbtcToBtc.selector,\n            \"Bad _extraData signature. Call must be to tbtcToBtc.\"\n        );\n\n        // We capture the `returnData` in order to forward any nested revert message\n        // from the contract call.\n        // solium-disable-next-line security/no-low-level-calls\n        (bool success, bytes memory returnData) = address(vendingMachine).call(_extraData);\n\n        string memory revertMessage;\n        assembly {\n            // A revert message is ABI-encoded as a call to Error(string).\n            // Slicing the Error() signature (4 bytes) and Data offset (4 bytes)\n            // leaves us with a pre-encoded string.\n            // We also slice off the ABI-coded length of returnData (32).\n            revertMessage := add(returnData, 0x44)\n        }\n\n        require(success, revertMessage);\n    }\n}\n"
    },
    "solidity/contracts/system/TBTCDevelopmentConstants.sol": {
      "content": "pragma solidity 0.5.17;\n\n/// @title TBTCDevelopmentConstants\n/// @notice Constants for development testnet usages; tuned for testing and\n///         faster iteration rather than security. These should NOT be deployed\n///         on mainnet or mainnet-like (\"staging\") environments.\nlibrary TBTCDevelopmentConstants {\n    // This is intended to make it easy to update system params\n    // During testing swap this out with another constats contract\n\n    // System Parameters\n    uint256 public constant BENEFICIARY_FEE_DIVISOR = 1000;  // 1/1000 = 10 bps = 0.1% = 0.001\n    uint256 public constant SATOSHI_MULTIPLIER = 10 ** 10; // multiplier to convert satoshi to TBTC token units\n    uint256 public constant DEPOSIT_TERM_LENGTH = 180 * 24 * 60 * 60; // 180 days in seconds\n    uint256 public constant TX_PROOF_DIFFICULTY_FACTOR = 1; // confirmations on the Bitcoin chain\n\n    // Redemption Flow\n    uint256 public constant REDEMPTION_SIGNATURE_TIMEOUT = 2 * 60 * 60;  // seconds\n    uint256 public constant INCREASE_FEE_TIMER = 4 * 60 * 60;  // seconds\n    uint256 public constant REDEMPTION_PROOF_TIMEOUT = 6 * 60 * 60;  // seconds\n    uint256 public constant MINIMUM_REDEMPTION_FEE = 150; // satoshi\n\n    // Funding Flow\n    uint256 public constant FUNDING_PROOF_TIMEOUT = 3 * 60 * 60; // seconds\n    uint256 public constant FORMATION_TIMEOUT = 3 * 60 * 60; // seconds\n\n    // Liquidation Flow\n    uint256 public constant COURTESY_CALL_DURATION = 6 * 60 * 60; // seconds\n    uint256 public constant AUCTION_DURATION = 24 * 60 * 60; // seconds\n\n    // Getters for easy access\n    function getBeneficiaryRewardDivisor() external pure returns (uint256) { return BENEFICIARY_FEE_DIVISOR; }\n    function getSatoshiMultiplier() external pure returns (uint256) { return SATOSHI_MULTIPLIER; }\n    function getDepositTerm() external pure returns (uint256) { return DEPOSIT_TERM_LENGTH; }\n    function getTxProofDifficultyFactor() external pure returns (uint256) { return TX_PROOF_DIFFICULTY_FACTOR; }\n\n    function getSignatureTimeout() external pure returns (uint256) { return REDEMPTION_SIGNATURE_TIMEOUT; }\n    function getIncreaseFeeTimer() external pure returns (uint256) { return INCREASE_FEE_TIMER; }\n    function getRedemptionProofTimeout() external pure returns (uint256) { return REDEMPTION_PROOF_TIMEOUT; }\n    function getMinimumRedemptionFee() external pure returns (uint256) { return MINIMUM_REDEMPTION_FEE; }\n\n    function getFundingTimeout() external pure returns (uint256) { return FUNDING_PROOF_TIMEOUT; }\n    function getSigningGroupFormationTimeout() external pure returns (uint256) { return FORMATION_TIMEOUT; }\n\n    function getCourtesyCallTimeout() external pure returns (uint256) { return COURTESY_CALL_DURATION; }\n    function getAuctionDuration() external pure returns (uint256) { return AUCTION_DURATION; }\n}\n"
    }
  },
  "settings": {
    "libraries": {
      "solidity/contracts/system/TBTCSystem.sol": {
        "KeepFactorySelection": "0x29fA8F46CBB9562b87773c8f50a7F9F27178261c"
      },
      "solidity/contracts/deposit/DepositUtils.sol": {
        "TBTCConstants": "0x63a152eA1cD78AC3C7C1FCF1322DC6dE1126750d"
      },
      "solidity/contracts/deposit/DepositLiquidation.sol": {
        "TBTCConstants": "0x63a152eA1cD78AC3C7C1FCF1322DC6dE1126750d",
        "DepositUtils": "0x2Ad83DECF0555945094E5D25129c1F324F212517",
        "DepositStates": "0x8695FF199A1216Fc7E2BF97303bF662baBae1C80",
        "OutsourceDepositLogging": "0x478409D856CD759cbfaa6639D88b7cdcB8Ec29ED"
      },
      "solidity/contracts/deposit/DepositRedemption.sol": {
        "TBTCConstants": "0x63a152eA1cD78AC3C7C1FCF1322DC6dE1126750d",
        "DepositUtils": "0x2Ad83DECF0555945094E5D25129c1F324F212517",
        "DepositStates": "0x8695FF199A1216Fc7E2BF97303bF662baBae1C80",
        "OutsourceDepositLogging": "0x478409D856CD759cbfaa6639D88b7cdcB8Ec29ED"
      },
      "solidity/contracts/deposit/DepositFunding.sol": {
        "TBTCConstants": "0x63a152eA1cD78AC3C7C1FCF1322DC6dE1126750d",
        "DepositUtils": "0x2Ad83DECF0555945094E5D25129c1F324F212517",
        "DepositStates": "0x8695FF199A1216Fc7E2BF97303bF662baBae1C80",
        "OutsourceDepositLogging": "0x478409D856CD759cbfaa6639D88b7cdcB8Ec29ED",
        "DepositLiquidation": "0x1Ca5060BF142c58168aEdb974aABb020BC081A56"
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}