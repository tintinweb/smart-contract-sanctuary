{{
  "language": "Solidity",
  "sources": {
    "src/dispenser/contracts/Dispenser.sol": {
      "content": "// SPDX-License-Identifier: MPL-2.0\npragma solidity >=0.6.2;\n\ninterface IERC20 {\n  function balanceOf (address account) external view returns (uint256);\n\n  function transfer (address to, uint256 value) external returns (bool);\n}\n\ncontract Dispenser {\n  uint256 public lastUpdate;\n\n  event NewDispenser (address contractAddress);\n\n  /// @notice Creates a new contract.\n  function create (\n    address token,\n    address payer,\n    uint256 startTime,\n    address[] calldata payees,\n    uint256[] calldata ratesPerHour\n  ) external returns (address addr) {\n    uint256 len = payees.length;\n    require(len > 0 && len == ratesPerHour.length);\n\n    uint256 totalRatePerHour = 0;\n    for (uint256 i = 0; i < len; i++) {\n      uint256 tmp = totalRatePerHour + ratesPerHour[i];\n      // overflow + zero -check\n      require(tmp > totalRatePerHour);\n\n      totalRatePerHour = tmp;\n    }\n\n    addr = _createSimpleProxy();\n    // setup the dispenser\n    Dispenser(addr).setup();\n    emit NewDispenser(addr);\n  }\n\n  /// @notice Returns the metadata of this contract.\n  /// Only relevant with contracts created via the function `create()`.\n  function getMetadata ()\n  public view returns (\n    address token,\n    address payer,\n    uint256 startTime,\n    address[] memory payees,\n    uint256[] memory ratesPerHour\n  ) {\n    assembly {\n      let x := sub(calldatasize(), 32)\n      let size := calldataload(x)\n      let ptr := sub(x, size)\n      calldatacopy(0, ptr, size)\n      return(0, size)\n    }\n  }\n\n  /// @notice Setup this contract.\n  function setup (\n  ) external {\n    require(lastUpdate == 0);\n\n    (,,uint256 startTime,,) = Dispenser(this).getMetadata();\n    require(startTime > 0);\n    lastUpdate = startTime;\n  }\n\n  /// @notice Drips `ratesPerHour` to each payee since the last drip\n  /// and then returns any remaining balance to the `payer`.\n  function drain (\n  ) external {\n    (\n      address token,\n      address payer,\n      uint256 startTime,\n      address[] memory payees,\n      uint256[] memory ratesPerHour\n    ) = Dispenser(this).getMetadata();\n\n    require(msg.sender == payer);\n\n    // drip any accumulated debt first\n    _update(token, payer, startTime, payees, ratesPerHour);\n\n    IERC20 tokenContract = IERC20(token);\n    uint256 balance = tokenContract.balanceOf(address(this));\n\n    // any remaining balance can go back to the payer\n    if (balance > 0) {\n      require(tokenContract.transfer(payer, balance));\n    }\n  }\n\n  /// @notice Drips `ratesPerHour` for each `payees` from `token` since the last drip.\n  /// Returns Satisfaction.\n  function drip (\n  ) external {\n    (\n      address token,\n      address payer,\n      uint256 startTime,\n      address[] memory payees,\n      uint256[] memory ratesPerHour\n    ) = Dispenser(this).getMetadata();\n\n    _update(token, payer, startTime, payees, ratesPerHour);\n  }\n\n  /// @notice Allows to recover `lostToken` other than the intended `token`.\n  /// Transfers `lostToken` to the first payee.\n  function recoverLostTokens (\n    address lostToken\n  ) external {\n    (address token, , , address[] memory payees,) = Dispenser(this).getMetadata();\n    require(token != lostToken);\n\n    IERC20 tokenContract = IERC20(lostToken);\n    uint256 balance = tokenContract.balanceOf(address(this));\n    // lost tokens go to the first payee\n    tokenContract.transfer(payees[0], balance);\n  }\n\n  /// @dev The dripping logic.\n  function _update (\n    address token,\n    address payer,\n    uint256 startTime,\n    address[] memory payees,\n    uint256[] memory ratesPerHour\n  ) internal {\n    uint256 lastDrip = lastUpdate;\n\n    if (block.timestamp < lastDrip) {\n      return;\n    }\n\n    uint256 len = payees.length;\n    uint256 totalRatePerHour = 0;\n    for (uint256 i = 0; i < len; i++) {\n      totalRatePerHour += ratesPerHour[i];\n    }\n\n    IERC20 tokenContract = IERC20(token);\n    uint256 availableBalance = tokenContract.balanceOf(address(this));\n    uint256 availableHours = availableBalance / totalRatePerHour;\n    uint256 maxHours = (block.timestamp - lastDrip) / 3600;\n\n    if (availableHours > maxHours) {\n      // clamp\n      availableHours = maxHours;\n    }\n\n    if (availableHours > 0) {\n      // update\n      lastUpdate = lastDrip + (availableHours * 3600);\n\n      // transfer to payees\n      for (uint256 i = 0; i < len; i++) {\n        uint256 rate = ratesPerHour[i];\n        uint256 amount = rate * availableHours;\n\n        availableBalance -= amount;\n        require(tokenContract.transfer(payees[i], amount));\n      }\n    }\n\n    // drip any dust to the payer\n    if (availableBalance > 0 && availableBalance < totalRatePerHour) {\n      // dust\n      require(tokenContract.transfer(payer, availableBalance));\n    }\n  }\n\n  function _createSimpleProxy () internal returns (address addr) {\n    // the following assembly code (init code + contract code) is a simple proxy.\n    assembly {\n      // # deploy code\n      // PUSH1 11;\n      // CODESIZE;\n      // SUB;\n      // DUP1;\n      // PUSH1 11;\n      // CALLDATASIZE;\n      // CODECOPY;\n      // CALLDATASIZE;\n      // RETURN; (contract bytecode is everything after this return opcode)\n      mstore(128, 0x600b380380600b363936f3000000000000000000000000000000000000000000)\n\n      // # contract code\n      // RETURNDATASIZE; push `0` on stack\n      // RETURNDATASIZE; 0 outSize\n      // RETURNDATASIZE; 0 outOffset\n\n      // copy args\n      // CALLDATASIZE;\n      // RETURNDATASIZE;\n      // RETURNDATASIZE;\n      // CALLDATACOPY; (0, 0, calldatasize())\n\n      // PUSH1 55;\n      // DUP1; 55, 55\n      // CODESIZE;\n      // SUB; size, 55\n      // DUP1; size ,size, 55\n      // SWAP2; 55, size, size\n      // CALLDATASIZE;\n      // CODECOPY; (calldatasize(), 55, size)\n\n      // CALLDATASIZE;\n      // ADD; size+calldatasize\n      // RETURNDATASIZE; 0 inOffset\n      // PUSH20 0; zero is replaced with shl(96, address())\n      // GAS;\n      // DELEGATECALL; (gas, addr, 0, calldatasize() + metadata, 0, 0) delegatecall to this Dispenser contract;\n      //\n      // RETURNDATASIZE;\n      // DUP3; 0\n      // DUP1; 0\n      // RETURNDATACOPY; (0, 0, returndatasize) - Copy everything into memory that the call returned\n      //\n      // # this is for either revert(0, returndatasize()) or return (0, returndatasize())\n      // RETURNDATASIZE;\n      // DUP3; 0\n      //\n      // DUP3; copy retCode from delegatecall() - 0 fail, 1 success\n      // PUSH1 _SUCCESS_; push jumpdest of _SUCCESS_\n      // JUMPI; jump if delegatecall returned `1`\n      // REVERT; (0, returndatasize()) if delegatecall returned `0`\n      // JUMPDEST _SUCCESS_;\n      // RETURN; (0, returndatasize()) if delegatecall returned non-zero (1)\n\n      // the bytecode from the above statements\n      mstore(139, 0x3d3d3d363d3d3760378038038091363936013d73000000000000000000000000)\n      mstore(159, shl(96, address()))\n      // 15 bytes\n      mstore(179, 0x5af43d82803e3d8282603557fd5bf30000000000000000000000000000000000)\n\n      let size := sub(calldatasize(), 4)\n      calldatacopy(194, 4, size)\n      let ptr := add(194, size)\n      mstore(ptr, size)\n\n      // The size is deploy code + contract code + calldatasize - 4 + 32.\n      // Subtract 96 instead of 128 because the `ptr` is not increased after the last `mstore`.\n      addr := create(0, 128, sub(ptr, 96))\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 2,
      "details": {
        "peephole": true,
        "jumpdestRemover": true,
        "orderLiterals": false,
        "deduplicate": true,
        "cse": true,
        "constantOptimizer": true,
        "yul": false
      }
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}