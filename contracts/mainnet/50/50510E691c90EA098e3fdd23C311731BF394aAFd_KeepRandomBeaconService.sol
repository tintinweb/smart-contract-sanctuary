{{
  "language": "Solidity",
  "sources": {
    "solidity/contracts/KeepRandomBeaconService.sol": {
      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/upgradeability/Proxy.sol\";\n\n/// @title Keep Random Beacon service\n/// @notice A proxy contract to provide upgradable Random Beacon functionality.\n/// All calls to this proxy contract are delegated to the implementation contract.\ncontract KeepRandomBeaconService is Proxy {\n    using SafeMath for uint256;\n\n    /// @dev Storage slot with the admin of the contract.\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n    /// It is validated in the constructor.\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /// @dev Storage slot with the address of the current implementation.\n    /// This is the keccak-256 hash of \"eip1967.proxy.implementation\"\n    /// subtracted by 1. It is validated in the constructor.\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /// @dev Storage slot with the upgrade time delay. Upgrade time delay\n    /// defines a period for implementation upgrade. This is the keccak-256\n    /// hash of \"network.keep.randombeacon.proxy.upgradeTimeDelay\"\n    /// subtracted by 1. It is validated in the constructor.\n    bytes32 internal constant UPGRADE_TIME_DELAY_SLOT = 0x73bbd307af06a74c12a4f925288c98f759a1ee8fee7eae47a0c215cb63ef2c6b;\n\n    /// @dev Storage slot with the new implementation address. This is the\n    /// keccak-256 hash of \"network.keep.randombeacon.proxy.upgradeImplementation\"\n    /// subtracted by 1. It is validated in the constructor.\n    bytes32 internal constant UPGRADE_IMPLEMENTATION_SLOT = 0x3c3c1acab6a17c8ef7a1d07995c8ed2942488afd9e13cf89bd5c6e4828160276;\n\n    /// @dev Storage slot with the implementation address upgrade initiation.\n    /// This is the keccak-256 hash of \"network.keep.randombeacon.proxy.upgradeInitiatedTimestamp\"\n    /// subtracted by 1. It is validated in the constructor.\n    bytes32 internal constant UPGRADE_INIT_TIMESTAMP_SLOT = 0xb49edbaf3913780c2ef1ff781deec1eb653eab7236ff107428d60052d0f0d18d;\n\n    /// @notice Implementation initialization data to be used on the second step\n    /// of upgrade.\n    /// @dev Mapping is stored at the position calculated with keccak256 of the\n    /// new implementation address. Hence, it should be protected from clashing\n    /// with implementation's fields.\n    mapping(address => bytes) public initializationData;\n\n    event UpgradeStarted(address implementation, uint256 timestamp);\n    event UpgradeCompleted(address implementation);\n\n    constructor(address _implementation, bytes memory _data) public {\n        assertSlot(IMPLEMENTATION_SLOT, \"eip1967.proxy.implementation\");\n        assertSlot(ADMIN_SLOT, \"eip1967.proxy.admin\");\n        assertSlot(UPGRADE_TIME_DELAY_SLOT, \"network.keep.randombeacon.proxy.upgradeTimeDelay\");\n        assertSlot(UPGRADE_IMPLEMENTATION_SLOT, \"network.keep.randombeacon.proxy.upgradeImplementation\");\n        assertSlot(UPGRADE_INIT_TIMESTAMP_SLOT, \"network.keep.randombeacon.proxy.upgradeInitiatedTimestamp\");\n\n        require(\n            _implementation != address(0),\n            \"Implementation address can't be zero.\"\n        );\n\n        if (_data.length > 0) {\n            initializeImplementation(_implementation, _data);\n        }\n\n        setImplementation(_implementation);\n\n        setUpgradeTimeDelay(1 days);\n\n        setAdmin(msg.sender);\n    }\n\n    /// @notice Starts upgrade of the current vendor implementation.\n    /// @dev It is the first part of the two-step implementation address update\n    /// process. The function emits an event containing the new value and current\n    /// block timestamp.\n    /// @param _newImplementation Address of the new vendor implementation contract.\n    /// @param _data Delegate call data for implementation initialization.\n    function upgradeTo(address _newImplementation, bytes memory _data)\n        public\n        onlyAdmin\n    {\n        address currentImplementation = _implementation();\n        require(\n            _newImplementation != address(0),\n            \"Implementation address can't be zero.\"\n        );\n        require(\n            _newImplementation != currentImplementation,\n            \"Implementation address must be different from the current one.\"\n        );\n\n        initializationData[_newImplementation] = _data;\n\n        setNewImplementation(_newImplementation);\n\n        /* solium-disable-next-line security/no-block-members */\n        setUpgradeInitiatedTimestamp(block.timestamp);\n\n        /* solium-disable-next-line security/no-block-members */\n        emit UpgradeStarted(_newImplementation, block.timestamp);\n    }\n\n    /// @notice Finalizes implementation address upgrade.\n    /// @dev It is the second part of the two-step implementation address update\n    /// process. The function emits an event containing the new implementation\n    /// address. It can be called after upgrade time delay period has passed since\n    /// upgrade initiation.\n    function completeUpgrade() public onlyAdmin {\n        require(upgradeInitiatedTimestamp() > 0, \"Upgrade not initiated\");\n\n        require(\n            /* solium-disable-next-line security/no-block-members */\n            block.timestamp.sub(upgradeInitiatedTimestamp()) >=\n            upgradeTimeDelay(),\n            \"Timer not elapsed\"\n        );\n\n        address newImplementation = newImplementation();\n\n        setImplementation(newImplementation);\n\n        bytes memory data = initializationData[newImplementation];\n        if (data.length > 0) {\n            initializeImplementation(newImplementation, data);\n        }\n\n        setUpgradeInitiatedTimestamp(0);\n\n        emit UpgradeCompleted(newImplementation);\n    }\n\n    /// @notice Initializes implementation contract.\n    /// @dev Delegates a call to the implementation with provided data. It is\n    /// expected that data contains details of function to be called.\n    /// @param _implementation Address of the new vendor implementation contract.\n    /// @param _data Delegate call data for implementation initialization.\n    function initializeImplementation(\n        address _implementation,\n        bytes memory _data\n    ) internal {\n        (bool success, bytes memory returnData) = _implementation.delegatecall(\n            _data\n        );\n\n        require(success, string(returnData));\n    }\n\n    /// @notice Asserts correct slot for provided key.\n    /// @dev To avoid clashing with implementation's fields the proxy contract\n    /// defines its' fields on specific slots. Slot is calculated as hash of a\n    /// string subtracted by 1 to reduce chances of a possible attack.\n    /// For details see EIP-1967.\n    function assertSlot(bytes32 slot, bytes memory key) internal pure {\n        assert(slot == bytes32(uint256(keccak256(key)) - 1));\n    }\n\n    /// @dev Gets the address of the current implementation.\n    /// @return address of the current implementation.\n    function implementation() public view returns (address) {\n        return _implementation();\n    }\n\n    /// @notice Returns the current implementation. Implements function from `Proxy`\n    /// contract.\n    /// @return Address of the current implementation\n    function _implementation() internal view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        /* solium-disable-next-line */\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /// @notice Sets the address of the current implementation.\n    /// @param _implementation address representing the new implementation to be set.\n    function setImplementation(address _implementation) internal {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        /* solium-disable-next-line */\n        assembly {\n            sstore(slot, _implementation)\n        }\n    }\n\n    function upgradeTimeDelay()\n        public\n        view\n        returns (uint256 _upgradeTimeDelay)\n    {\n        bytes32 position = UPGRADE_TIME_DELAY_SLOT;\n        /* solium-disable-next-line */\n        assembly {\n            _upgradeTimeDelay := sload(position)\n        }\n    }\n\n    function setUpgradeTimeDelay(uint256 _upgradeTimeDelay) internal {\n        bytes32 position = UPGRADE_TIME_DELAY_SLOT;\n        /* solium-disable-next-line */\n        assembly {\n            sstore(position, _upgradeTimeDelay)\n        }\n    }\n\n    function newImplementation()\n        public\n        view\n        returns (address _newImplementation)\n    {\n        bytes32 position = UPGRADE_IMPLEMENTATION_SLOT;\n        /* solium-disable-next-line */\n        assembly {\n            _newImplementation := sload(position)\n        }\n    }\n\n    function setNewImplementation(address _newImplementation) internal {\n        bytes32 position = UPGRADE_IMPLEMENTATION_SLOT;\n        /* solium-disable-next-line */\n        assembly {\n            sstore(position, _newImplementation)\n        }\n    }\n\n    function upgradeInitiatedTimestamp()\n        public\n        view\n        returns (uint256 _upgradeInitiatedTimestamp)\n    {\n        bytes32 position = UPGRADE_INIT_TIMESTAMP_SLOT;\n        /* solium-disable-next-line */\n        assembly {\n            _upgradeInitiatedTimestamp := sload(position)\n        }\n    }\n\n    function setUpgradeInitiatedTimestamp(uint256 _upgradeInitiatedTimestamp)\n        internal\n    {\n        bytes32 position = UPGRADE_INIT_TIMESTAMP_SLOT;\n        /* solium-disable-next-line */\n        assembly {\n            sstore(position, _upgradeInitiatedTimestamp)\n        }\n    }\n\n    /// @notice The admin slot.\n    /// @return The contract owner's address.\n    function admin() public view returns (address adm) {\n        bytes32 slot = ADMIN_SLOT;\n        /* solium-disable-next-line */\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /// @notice Sets the address of the proxy admin.\n    /// @dev Function can be called only by the current admin.\n    /// @param _newAdmin Address of the new proxy admin.\n    function updateAdmin(address _newAdmin) public onlyAdmin {\n        setAdmin(_newAdmin);\n    }\n\n    /// @notice Sets the address of the proxy admin.\n    /// @param _newAdmin Address of the new proxy admin.\n    function setAdmin(address _newAdmin) internal {\n        bytes32 slot = ADMIN_SLOT;\n        /* solium-disable-next-line */\n        assembly {\n            sstore(slot, _newAdmin)\n        }\n    }\n\n    /// @notice Throws if called by any account other than the contract owner.\n    modifier onlyAdmin() {\n        require(msg.sender == admin(), \"Caller is not the admin\");\n        _;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/upgrades/contracts/upgradeability/Proxy.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\ncontract Proxy {\n  /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n  function () payable external {\n    _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal view returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize)\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize)\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize) }\n      default { return(0, returndatasize) }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal {\n  }\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}