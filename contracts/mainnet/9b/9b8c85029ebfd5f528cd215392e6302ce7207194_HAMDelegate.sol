{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.17;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n",
      "keccak256": "0xfb72ae2642cad8f5da1644433dbcc12681f8064335dff144623f0514dc7922c6"
    },
    "contracts/token/HAM.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./HAMGovernance.sol\";\n\ncontract HAMToken is HAMGovernanceToken {\n    // Modifiers\n    modifier onlyGov() {\n        require(msg.sender == gov);\n        _;\n    }\n\n    modifier onlyRebaser() {\n        require(msg.sender == rebaser);\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == rebaser || msg.sender == incentivizer || msg.sender == gov, \"not minter\");\n        _;\n    }\n\n    modifier validRecipient(address to) {\n        require(to != address(0x0));\n        require(to != address(this));\n        _;\n    }\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    )\n        public\n    {\n        require(hamsScalingFactor == 0, \"already initialized\");\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /**\n    * @notice Computes the current max scaling factor\n    */\n    function maxScalingFactor()\n        external\n        view\n        returns (uint256)\n    {\n        return _maxScalingFactor();\n    }\n\n    function _maxScalingFactor()\n        internal\n        view\n        returns (uint256)\n    {\n        // scaling factor can only go up to 2**256-1 = initSupply * hamsScalingFactor\n        // this is used to check if hamsScalingFactor will be too high to compute balances when rebasing.\n        return uint256(-1) / initSupply;\n    }\n\n    /**\n    * @notice Mints new tokens, increasing totalSupply, initSupply, and a users balance.\n    * @dev Limited to onlyMinter modifier\n    */\n    function mint(address to, uint256 amount)\n        external\n        onlyMinter\n        returns (bool)\n    {\n        _mint(to, amount);\n        return true;\n    }\n\n    function _mint(address to, uint256 amount)\n        internal\n    {\n      // increase totalSupply\n      totalSupply = totalSupply.add(amount);\n\n      // get underlying value\n      uint256 hamValue = amount.mul(internalDecimals).div(hamsScalingFactor);\n\n      // increase initSupply\n      initSupply = initSupply.add(hamValue);\n\n      // make sure the mint didnt push maxScalingFactor too low\n      require(hamsScalingFactor <= _maxScalingFactor(), \"max scaling factor too low\");\n\n      // add balance\n      _hamBalances[to] = _hamBalances[to].add(hamValue);\n\n      // add delegates to the minter\n      _moveDelegates(address(0), _delegates[to], hamValue);\n      emit Mint(to, amount);\n    }\n\n    /* - ERC20 functionality - */\n\n    /**\n    * @dev Transfer tokens to a specified address.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    * @return True on success, false otherwise.\n    */\n    function transfer(address to, uint256 value)\n        external\n        validRecipient(to)\n        returns (bool)\n    {\n        // underlying balance is stored in hams, so divide by current scaling factor\n\n        // note, this means as scaling factor grows, dust will be untransferrable.\n        // minimum transfer value == hamsScalingFactor / 1e24;\n\n        // get amount in underlying\n        uint256 hamValue = value.mul(internalDecimals).div(hamsScalingFactor);\n\n        // sub from balance of sender\n        _hamBalances[msg.sender] = _hamBalances[msg.sender].sub(hamValue);\n\n        // add to balance of receiver\n        _hamBalances[to] = _hamBalances[to].add(hamValue);\n        emit Transfer(msg.sender, to, value);\n\n        _moveDelegates(_delegates[msg.sender], _delegates[to], hamValue);\n        return true;\n    }\n\n    /**\n    * @dev Transfer tokens from one address to another.\n    * @param from The address you want to send tokens from.\n    * @param to The address you want to transfer to.\n    * @param value The amount of tokens to be transferred.\n    */\n    function transferFrom(address from, address to, uint256 value)\n        external\n        validRecipient(to)\n        returns (bool)\n    {\n        // decrease allowance\n        _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender].sub(value);\n\n        // get value in hams\n        uint256 hamValue = value.mul(internalDecimals).div(hamsScalingFactor);\n\n        // sub from from\n        _hamBalances[from] = _hamBalances[from].sub(hamValue);\n        _hamBalances[to] = _hamBalances[to].add(hamValue);\n        emit Transfer(from, to, value);\n\n        _moveDelegates(_delegates[from], _delegates[to], hamValue);\n        return true;\n    }\n\n    /**\n    * @param who The address to query.\n    * @return The balance of the specified address.\n    */\n    function balanceOf(address who)\n      external\n      view\n      returns (uint256)\n    {\n      return _hamBalances[who].mul(hamsScalingFactor).div(internalDecimals);\n    }\n\n    /** @notice Currently returns the internal storage amount\n    * @param who The address to query.\n    * @return The underlying balance of the specified address.\n    */\n    function balanceOfUnderlying(address who)\n      external\n      view\n      returns (uint256)\n    {\n      return _hamBalances[who];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner has allowed to a spender.\n     * @param owner_ The address which owns the funds.\n     * @param spender The address which will spend the funds.\n     * @return The number of tokens still available for the spender.\n     */\n    function allowance(address owner_, address spender)\n        external\n        view\n        returns (uint256)\n    {\n        return _allowedFragments[owner_][spender];\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of\n     * msg.sender. This method is included for ERC20 compatibility.\n     * increaseAllowance and decreaseAllowance should be used instead.\n     * Changing an allowance with this method brings the risk that someone may transfer both\n     * the old and the new allowance - if they are both greater than zero - if a transfer\n     * transaction is mined before the later approve() call is mined.\n     *\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value)\n        external\n        returns (bool)\n    {\n        _allowedFragments[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner has allowed to a spender.\n     * This method should be used instead of approve() to avoid the double approval vulnerability\n     * described above.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        external\n        returns (bool)\n    {\n        _allowedFragments[msg.sender][spender] =\n            _allowedFragments[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner has allowed to a spender.\n     *\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        external\n        returns (bool)\n    {\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\n        if (subtractedValue >= oldValue) {\n            _allowedFragments[msg.sender][spender] = 0;\n        } else {\n            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);\n        }\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\n        return true;\n    }\n\n    /* - Governance Functions - */\n\n    /** @notice sets the rebaser\n     * @param rebaser_ The address of the rebaser contract to use for authentication.\n     */\n    function _setRebaser(address rebaser_)\n        external\n        onlyGov\n    {\n        address oldRebaser = rebaser;\n        rebaser = rebaser_;\n        emit NewRebaser(oldRebaser, rebaser_);\n    }\n\n    /** @notice sets the incentivizer\n     * @param incentivizer_ The address of the incentivizer contract to use for authentication.\n     */\n    function _setIncentivizer(address incentivizer_)\n        external\n        onlyGov\n    {\n        address oldIncentivizer = incentivizer;\n        incentivizer = incentivizer_;\n        emit NewIncentivizer(oldIncentivizer, incentivizer_);\n    }\n\n    /** @notice sets the pendingGov\n     * @param pendingGov_ The address of the rebaser contract to use for authentication.\n     */\n    function _setPendingGov(address pendingGov_)\n        external\n        onlyGov\n    {\n        address oldPendingGov = pendingGov;\n        pendingGov = pendingGov_;\n        emit NewPendingGov(oldPendingGov, pendingGov_);\n    }\n\n    /** @notice lets msg.sender accept governance\n     *\n     */\n    function _acceptGov()\n        external\n    {\n        require(msg.sender == pendingGov, \"!pending\");\n        address oldGov = gov;\n        gov = pendingGov;\n        pendingGov = address(0);\n        emit NewGov(oldGov, gov);\n    }\n\n    /* - Extras - */\n\n    /**\n    * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\n    *\n    * @dev The supply adjustment equals (totalSupply * DeviationFromTargetRate) / rebaseLag\n    *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\n    *      and targetRate is CpiOracleRate / baseCpi\n    */\n    function rebase(\n        uint256 epoch,\n        uint256 indexDelta,\n        bool positive\n    )\n        external\n        onlyRebaser\n        returns (uint256)\n    {\n        if (indexDelta == 0) {\n          emit Rebase(epoch, hamsScalingFactor, hamsScalingFactor);\n          return totalSupply;\n        }\n\n        uint256 prevHamsScalingFactor = hamsScalingFactor;\n\n        if (!positive) {\n           hamsScalingFactor = hamsScalingFactor.mul(BASE.sub(indexDelta)).div(BASE);\n        } else {\n            uint256 newScalingFactor = hamsScalingFactor.mul(BASE.add(indexDelta)).div(BASE);\n            if (newScalingFactor < _maxScalingFactor()) {\n              hamsScalingFactor = newScalingFactor;\n            } else {\n              hamsScalingFactor = _maxScalingFactor();\n            }\n        }\n\n        totalSupply = initSupply.mul(hamsScalingFactor).div(BASE);\n        emit Rebase(epoch, prevHamsScalingFactor, hamsScalingFactor);\n        return totalSupply;\n    }\n}\n\ncontract HAM is HAMToken {\n    /**\n     * @notice Initialize the new money market\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address initialOwner,\n        uint256 initSupply_\n    )\n        public\n    {\n        require(initSupply_ > 0, \"0 init supply\");\n\n        super.initialize(name_, symbol_, decimals_);\n\n        initSupply = initSupply_.mul(10**24/ (BASE));\n        totalSupply = initSupply_;\n        hamsScalingFactor = BASE;\n        _hamBalances[initialOwner] = initSupply_.mul(10**24 / (BASE));\n        farmRegistry = address(0);\n    }\n\n    function setFarmRegistry(address registry) external onlyGov {\n        farmRegistry = registry;\n    }\n}\n",
      "keccak256": "0x24ccebe05fbf07161e2ccab582ccb37dd401fde1df8132507ae2f840a4c281d3"
    },
    "contracts/token/HAMDelegate.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./HAM.sol\";\n\ncontract HAMDelegationStorage {\n    /**\n     * @notice Implementation address for this contract\n     */\n    address public implementation;\n}\n\ncontract HAMDelegatorInterface is HAMDelegationStorage {\n    /**\n     * @notice Emitted when implementation is changed\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * @notice Called by the gov to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\n}\n\ncontract HAMDelegateInterface is HAMDelegationStorage {\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @dev Should revert if any issues arise which make it unfit for delegation\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes memory data) public;\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() public;\n}\n\n\ncontract HAMDelegate is HAM, HAMDelegateInterface {\n    /**\n     * @notice Construct an empty delegate\n     */\n    constructor() public {}\n\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes memory data) public {\n        // Shh -- currently unused\n        data;\n\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == gov, \"only the gov may call _becomeImplementation\");\n    }\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() public {\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == gov, \"only the gov may call _resignImplementation\");\n    }\n}\n",
      "keccak256": "0x161e4a957e0337430ae87c2a44793cde650faf11bb37d2b59c67953525a755fa"
    },
    "contracts/token/HAMGovernance.sol": {
      "content": "pragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"./HAMGovernanceStorage.sol\";\nimport \"./HAMTokenInterface.sol\";\n\ncontract HAMGovernanceToken is HAMTokenInterface {\n\n      /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Get the delegate for a delegator address\n     * @param delegator The address to get delegates for\n     */\n    function delegates(address delegator)\n        external\n        view\n        returns (address)\n    {\n        return _delegates[delegator];\n    }\n\n   /**\n    * @notice Delegate votes from `msg.sender` to `delegatee`\n    * @param delegatee The address to delegate votes to\n    */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"HAM::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"HAM::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"HAM::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        require(blockNumber < block.number, \"HAM::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee)\n        internal\n    {\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = _hamBalances[delegator]; // balance of underlying HAMs (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    )\n        internal\n    {\n        uint32 blockNumber = safe32(block.number, \"HAM::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}\n",
      "keccak256": "0xb0f5a6993bf6efb5989ecd83abc1bebfd307054ffda93190b2422c1cd73bfc8f"
    },
    "contracts/token/HAMGovernanceStorage.sol": {
      "content": "pragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\ncontract HAMGovernanceStorage {\n    /// @notice A record of each accounts delegate\n    mapping (address => address) internal _delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n}\n",
      "keccak256": "0x51b412f6a8f6702862d0419a2f9b045a679033653183c6653a26e319ef5d8b62"
    },
    "contracts/token/HAMTokenInterface.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./HAMTokenStorage.sol\";\nimport \"./HAMGovernanceStorage.sol\";\n\ncontract HAMTokenInterface is HAMTokenStorage, HAMGovernanceStorage {\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Event emitted when tokens are rebased\n     */\n    event Rebase(uint256 epoch, uint256 prevHamsScalingFactor, uint256 newHamsScalingFactor);\n\n    /*** Gov Events ***/\n\n    /**\n     * @notice Event emitted when pendingGov is changed\n     */\n    event NewPendingGov(address oldPendingGov, address newPendingGov);\n\n    /**\n     * @notice Event emitted when gov is changed\n     */\n    event NewGov(address oldGov, address newGov);\n\n    /**\n     * @notice Sets the rebaser contract\n     */\n    event NewRebaser(address oldRebaser, address newRebaser);\n\n    /**\n     * @notice Sets the incentivizer contract\n     */\n    event NewIncentivizer(address oldIncentivizer, address newIncentivizer);\n\n    /* - ERC20 Events - */\n\n    /**\n     * @notice EIP20 Transfer event\n     */\n    event Transfer(address indexed from, address indexed to, uint amount);\n\n    /**\n     * @notice EIP20 Approval event\n     */\n    event Approval(address indexed owner, address indexed spender, uint amount);\n\n    /* - Extra Events - */\n    /**\n     * @notice Tokens minted event\n     */\n    event Mint(address to, uint256 amount);\n\n    // Public functions\n    function transfer(address to, uint256 value) external returns(bool);\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\n    function balanceOf(address who) external view returns(uint256);\n    function balanceOfUnderlying(address who) external view returns(uint256);\n    function allowance(address owner_, address spender) external view returns(uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n    function maxScalingFactor() external view returns (uint256);\n\n    /* - Governance Functions - */\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint256);\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\n    function delegate(address delegatee) external;\n    function delegates(address delegator) external view returns (address);\n    function getCurrentVotes(address account) external view returns (uint256);\n\n    /* - Permissioned/Governance functions - */\n    function mint(address to, uint256 amount) external returns (bool);\n    function rebase(uint256 epoch, uint256 indexDelta, bool positive) external returns (uint256);\n    function _setRebaser(address rebaser_) external;\n    function _setIncentivizer(address incentivizer_) external;\n    function _setPendingGov(address pendingGov_) external;\n    function _acceptGov() external;\n}\n",
      "keccak256": "0xbe2025e40a5db9d0c65629bba4981025a175da712704f4a1b7ca4ade836577fc"
    },
    "contracts/token/HAMTokenStorage.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"../lib/SafeMath.sol\";\n\n// Storage for a HAM token\ncontract HAMTokenStorage {\n\n    using SafeMath for uint256;\n\n    /**\n     * @dev Guard variable for re-entrancy checks. Not currently used\n     */\n    bool internal _notEntered;\n\n    /**\n     * @notice EIP-20 token name for this token\n     */\n    string public name;\n\n    /**\n     * @notice EIP-20 token symbol for this token\n     */\n    string public symbol;\n\n    /**\n     * @notice EIP-20 token decimals for this token\n     */\n    uint8 public decimals;\n\n    /**\n     * @notice Governor for this contract\n     */\n    address public gov;\n\n    /**\n     * @notice Pending governance for this contract\n     */\n    address public pendingGov;\n\n    /**\n     * @notice Approved rebaser for this contract\n     */\n    address public rebaser;\n\n    /**\n     * @notice Reserve address of HAM protocol\n     */\n    address public incentivizer;\n\n    /**\n     * @notice Total supply of HAMs\n     */\n    uint256 public totalSupply;\n\n    /**\n     * @notice Internal decimals used to handle scaling factor\n     */\n    uint256 public constant internalDecimals = 10**24;\n\n    /**\n     * @notice Used for percentage maths\n     */\n    uint256 public constant BASE = 10**18;\n\n    /**\n     * @notice Scaling factor that adjusts everyone's balances\n     */\n    uint256 public hamsScalingFactor;\n\n    mapping (address => uint256) internal _hamBalances;\n\n    mapping (address => mapping (address => uint256)) internal _allowedFragments;\n\n    uint256 public initSupply;\n\n    address public farmRegistry;\n}\n",
      "keccak256": "0x848b999c270aeb3d5cd0ac241f3167bad88cd8d29443804ca17892968879aacf"
    }
  }
}}