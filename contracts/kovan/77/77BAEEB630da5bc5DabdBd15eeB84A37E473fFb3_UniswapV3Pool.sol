pragma solidity=0.7.6;import'./interfaces/IUniswapV3Pool.sol';import'./NoDelegateCall.sol';import'./libraries/LowGasSafeMath.sol';import'./libraries/SafeCast.sol';import'./libraries/Tick.sol';import'./libraries/TickBitmap.sol';import'./libraries/Position.sol';import'./libraries/Oracle.sol';import'./libraries/FullMath.sol';import'./libraries/FixedPoint128.sol';import'./libraries/TransferHelper.sol';import'./libraries/TickMath.sol';import'./libraries/LiquidityMath.sol';import'./libraries/SqrtPriceMath.sol';import'./libraries/SwapMath.sol';import'./interfaces/IUniswapV3PoolDeployer.sol';import'./interfaces/IUniswapV3Factory.sol';import'./interfaces/IERC20Minimal.sol';import'./interfaces/callback/IUniswapV3MintCallback.sol';import'./interfaces/callback/IUniswapV3SwapCallback.sol';import'./interfaces/callback/IUniswapV3FlashCallback.sol';contract UniswapV3Pool is IUniswapV3Pool,NoDelegateCall{using LowGasSafeMath for uint256;using LowGasSafeMath for int256;using SafeCast for uint256;using SafeCast for int256;using Tick for mapping(int24=>Tick.Info);using TickBitmap for mapping(int16=>uint256);using Position for mapping(bytes32=>Position.Info);using Position for Position.Info;using Oracle for Oracle.Observation[65535];address public immutable override factory;address public immutable override token0;address public immutable override token1;uint24 public immutable override fee;int24 public immutable override tickSpacing;uint128 public immutable override maxLiquidityPerTick;struct Slot0{uint160 sqrtPriceX96;int24 tick;uint16 observationIndex;uint16 observationCardinality;uint16 observationCardinalityNext;uint8 feeProtocol;bool unlocked;} Slot0 public override slot0;uint256 public override feeGrowthGlobal0X128;uint256 public override feeGrowthGlobal1X128;struct ProtocolFees{uint128 token0;uint128 token1;} ProtocolFees public override protocolFees;uint128 public override liquidity;mapping(int24=>Tick.Info)public override ticks;mapping(int16=>uint256)public override tickBitmap;mapping(bytes32=>Position.Info)public override positions;Oracle.Observation[65535]public override observations;modifier lock(){require(slot0.unlocked,'LOK');slot0.unlocked=false;_;slot0.unlocked=true;} modifier onlyFactoryOwner(){require(msg.sender==IUniswapV3Factory(factory).owner());_;} constructor(){int24 _tickSpacing;(factory,token0,token1,fee,_tickSpacing)=IUniswapV3PoolDeployer(msg.sender).parameters();tickSpacing=_tickSpacing;maxLiquidityPerTick=Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);} function checkTicks(int24 tickLower,int24 tickUpper)private pure{require(tickLower<tickUpper,'TLU');require(tickLower>=TickMath.MIN_TICK,'TLM');require(tickUpper<=TickMath.MAX_TICK,'TUM');} function _blockTimestamp()internal view virtual returns(uint32){return uint32(block.timestamp);} function balance0()private view returns(uint256){(bool success,bytes memory data)=token0.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector,address(this)));require(success&&data.length>=32);return abi.decode(data,(uint256));} function balance1()private view returns(uint256){(bool success,bytes memory data)=token1.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector,address(this)));require(success&&data.length>=32);return abi.decode(data,(uint256));} function snapshotCumulativesInside(int24 tickLower,int24 tickUpper) external view override noDelegateCall returns(int56 tickCumulativeInside,uint160 secondsPerLiquidityInsideX128,uint32 secondsInside) {checkTicks(tickLower,tickUpper);int56 tickCumulativeLower;int56 tickCumulativeUpper;uint160 secondsPerLiquidityOutsideLowerX128;uint160 secondsPerLiquidityOutsideUpperX128;uint32 secondsOutsideLower;uint32 secondsOutsideUpper;{Tick.Info storage lower=ticks[tickLower];Tick.Info storage upper=ticks[tickUpper];bool initializedLower;(tickCumulativeLower,secondsPerLiquidityOutsideLowerX128,secondsOutsideLower,initializedLower)=(lower.tickCumulativeOutside,lower.secondsPerLiquidityOutsideX128,lower.secondsOutside,lower.initialized);require(initializedLower);bool initializedUpper;(tickCumulativeUpper,secondsPerLiquidityOutsideUpperX128,secondsOutsideUpper,initializedUpper)=(upper.tickCumulativeOutside,upper.secondsPerLiquidityOutsideX128,upper.secondsOutside,upper.initialized);require(initializedUpper);} Slot0 memory _slot0=slot0;if(_slot0.tick<tickLower){return(tickCumulativeLower-tickCumulativeUpper,secondsPerLiquidityOutsideLowerX128-secondsPerLiquidityOutsideUpperX128,secondsOutsideLower-secondsOutsideUpper);}else if(_slot0.tick<tickUpper){uint32 time=_blockTimestamp();(int56 tickCumulative,uint160 secondsPerLiquidityCumulativeX128)=observations.observeSingle(time,0,_slot0.tick,_slot0.observationIndex,liquidity,_slot0.observationCardinality);return(tickCumulative-tickCumulativeLower-tickCumulativeUpper,secondsPerLiquidityCumulativeX128- secondsPerLiquidityOutsideLowerX128- secondsPerLiquidityOutsideUpperX128,time-secondsOutsideLower-secondsOutsideUpper);}else{return(tickCumulativeUpper-tickCumulativeLower,secondsPerLiquidityOutsideUpperX128-secondsPerLiquidityOutsideLowerX128,secondsOutsideUpper-secondsOutsideLower);}} function observe(uint32[]calldata secondsAgos) external view override noDelegateCall returns(int56[]memory tickCumulatives,uint160[]memory secondsPerLiquidityCumulativeX128s) {return observations.observe(_blockTimestamp(),secondsAgos,slot0.tick,slot0.observationIndex,liquidity,slot0.observationCardinality);} function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external override lock noDelegateCall {uint16 observationCardinalityNextOld=slot0.observationCardinalityNext;uint16 observationCardinalityNextNew=observations.grow(observationCardinalityNextOld,observationCardinalityNext);slot0.observationCardinalityNext=observationCardinalityNextNew;if(observationCardinalityNextOld!=observationCardinalityNextNew) emit IncreaseObservationCardinalityNext(observationCardinalityNextOld,observationCardinalityNextNew);} function initialize(uint160 sqrtPriceX96)external override{require(slot0.sqrtPriceX96==0,'AI');int24 tick=TickMath.getTickAtSqrtRatio(sqrtPriceX96);(uint16 cardinality,uint16 cardinalityNext)=observations.initialize(_blockTimestamp());slot0=Slot0({sqrtPriceX96:sqrtPriceX96,tick:tick,observationIndex:0,observationCardinality:cardinality,observationCardinalityNext:cardinalityNext,feeProtocol:0,unlocked:true});emit Initialize(sqrtPriceX96,tick);} struct ModifyPositionParams{address owner;int24 tickLower;int24 tickUpper;int128 liquidityDelta;} function _modifyPosition(ModifyPositionParams memory params) private noDelegateCall returns(Position.Info storage position,int256 amount0,int256 amount1) {checkTicks(params.tickLower,params.tickUpper);Slot0 memory _slot0=slot0;position=_updatePosition(params.owner,params.tickLower,params.tickUpper,params.liquidityDelta,_slot0.tick);if(params.liquidityDelta!=0){if(_slot0.tick<params.tickLower){amount0=SqrtPriceMath.getAmount0Delta(TickMath.getSqrtRatioAtTick(params.tickLower),TickMath.getSqrtRatioAtTick(params.tickUpper),params.liquidityDelta);}else if(_slot0.tick<params.tickUpper){uint128 liquidityBefore=liquidity;(slot0.observationIndex,slot0.observationCardinality)=observations.write(_slot0.observationIndex,_blockTimestamp(),_slot0.tick,liquidityBefore,_slot0.observationCardinality,_slot0.observationCardinalityNext);amount0=SqrtPriceMath.getAmount0Delta(_slot0.sqrtPriceX96,TickMath.getSqrtRatioAtTick(params.tickUpper),params.liquidityDelta);amount1=SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(params.tickLower),_slot0.sqrtPriceX96,params.liquidityDelta);liquidity=LiquidityMath.addDelta(liquidityBefore,params.liquidityDelta);}else{amount1=SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(params.tickLower),TickMath.getSqrtRatioAtTick(params.tickUpper),params.liquidityDelta);}}} function _updatePosition(address owner,int24 tickLower,int24 tickUpper,int128 liquidityDelta,int24 tick)private returns(Position.Info storage position){position=positions.get(owner,tickLower,tickUpper);uint256 _feeGrowthGlobal0X128=feeGrowthGlobal0X128;uint256 _feeGrowthGlobal1X128=feeGrowthGlobal1X128;bool flippedLower;bool flippedUpper;if(liquidityDelta!=0){uint32 time=_blockTimestamp();(int56 tickCumulative,uint160 secondsPerLiquidityCumulativeX128)=observations.observeSingle(time,0,slot0.tick,slot0.observationIndex,liquidity,slot0.observationCardinality);flippedLower=ticks.update(tickLower,tick,liquidityDelta,_feeGrowthGlobal0X128,_feeGrowthGlobal1X128,secondsPerLiquidityCumulativeX128,tickCumulative,time,false,maxLiquidityPerTick);flippedUpper=ticks.update(tickUpper,tick,liquidityDelta,_feeGrowthGlobal0X128,_feeGrowthGlobal1X128,secondsPerLiquidityCumulativeX128,tickCumulative,time,true,maxLiquidityPerTick);if(flippedLower){tickBitmap.flipTick(tickLower,tickSpacing);} if(flippedUpper){tickBitmap.flipTick(tickUpper,tickSpacing);}} (uint256 feeGrowthInside0X128,uint256 feeGrowthInside1X128)=ticks.getFeeGrowthInside(tickLower,tickUpper,tick,_feeGrowthGlobal0X128,_feeGrowthGlobal1X128);position.update(liquidityDelta,feeGrowthInside0X128,feeGrowthInside1X128);if(liquidityDelta<0){if(flippedLower){ticks.clear(tickLower);} if(flippedUpper){ticks.clear(tickUpper);}}} function mint(address recipient,int24 tickLower,int24 tickUpper,uint128 amount,bytes calldata data)external override lock returns(uint256 amount0,uint256 amount1){require(amount>0);(,int256 amount0Int,int256 amount1Int)=_modifyPosition(ModifyPositionParams({owner:recipient,tickLower:tickLower,tickUpper:tickUpper,liquidityDelta:int256(amount).toInt128()}));amount0=uint256(amount0Int);amount1=uint256(amount1Int);uint256 balance0Before;uint256 balance1Before;if(amount0>0)balance0Before=balance0();if(amount1>0)balance1Before=balance1();IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0,amount1,data);if(amount0>0)require(balance0Before.add(amount0)<=balance0(),'M0');if(amount1>0)require(balance1Before.add(amount1)<=balance1(),'M1');emit Mint(msg.sender,recipient,tickLower,tickUpper,amount,amount0,amount1);} function collect(address recipient,int24 tickLower,int24 tickUpper,uint128 amount0Requested,uint128 amount1Requested)external override lock returns(uint128 amount0,uint128 amount1){Position.Info storage position=positions.get(msg.sender,tickLower,tickUpper);amount0=amount0Requested>position.tokensOwed0?position.tokensOwed0:amount0Requested;amount1=amount1Requested>position.tokensOwed1?position.tokensOwed1:amount1Requested;if(amount0>0){position.tokensOwed0-=amount0;TransferHelper.safeTransfer(token0,recipient,amount0);} if(amount1>0){position.tokensOwed1-=amount1;TransferHelper.safeTransfer(token1,recipient,amount1);} emit Collect(msg.sender,recipient,tickLower,tickUpper,amount0,amount1);} function burn(int24 tickLower,int24 tickUpper,uint128 amount)external override lock returns(uint256 amount0,uint256 amount1){(Position.Info storage position,int256 amount0Int,int256 amount1Int)=_modifyPosition(ModifyPositionParams({owner:msg.sender,tickLower:tickLower,tickUpper:tickUpper,liquidityDelta:-int256(amount).toInt128()}));amount0=uint256(-amount0Int);amount1=uint256(-amount1Int);if(amount0>0||amount1>0){(position.tokensOwed0,position.tokensOwed1)=(position.tokensOwed0+uint128(amount0),position.tokensOwed1+uint128(amount1));} emit Burn(msg.sender,tickLower,tickUpper,amount,amount0,amount1);} struct SwapCache{uint8 feeProtocol;uint128 liquidityStart;uint32 blockTimestamp;int56 tickCumulative;uint160 secondsPerLiquidityCumulativeX128;bool computedLatestObservation;} struct SwapState{int256 amountSpecifiedRemaining;int256 amountCalculated;uint160 sqrtPriceX96;int24 tick;uint256 feeGrowthGlobalX128;uint128 protocolFee;uint128 liquidity;} struct StepComputations{uint160 sqrtPriceStartX96;int24 tickNext;bool initialized;uint160 sqrtPriceNextX96;uint256 amountIn;uint256 amountOut;uint256 feeAmount;} function swap(address recipient,bool zeroForOne,int256 amountSpecified,uint160 sqrtPriceLimitX96,bytes calldata data)external override noDelegateCall returns(int256 amount0,int256 amount1){require(amountSpecified!=0,'AS');Slot0 memory slot0Start=slot0;require(slot0Start.unlocked,'LOK');require(zeroForOne?sqrtPriceLimitX96<slot0Start.sqrtPriceX96&&sqrtPriceLimitX96>TickMath.MIN_SQRT_RATIO:sqrtPriceLimitX96>slot0Start.sqrtPriceX96&&sqrtPriceLimitX96<TickMath.MAX_SQRT_RATIO,'SPL');slot0.unlocked=false;SwapCache memory cache=SwapCache({liquidityStart:liquidity,blockTimestamp:_blockTimestamp(),feeProtocol:zeroForOne?(slot0Start.feeProtocol%16):(slot0Start.feeProtocol>>4),secondsPerLiquidityCumulativeX128:0,tickCumulative:0,computedLatestObservation:false});bool exactInput=amountSpecified>0;SwapState memory state=SwapState({amountSpecifiedRemaining:amountSpecified,amountCalculated:0,sqrtPriceX96:slot0Start.sqrtPriceX96,tick:slot0Start.tick,feeGrowthGlobalX128:zeroForOne?feeGrowthGlobal0X128:feeGrowthGlobal1X128,protocolFee:0,liquidity:cache.liquidityStart});while(state.amountSpecifiedRemaining!=0&&state.sqrtPriceX96!=sqrtPriceLimitX96){StepComputations memory step;step.sqrtPriceStartX96=state.sqrtPriceX96;(step.tickNext,step.initialized)=tickBitmap.nextInitializedTickWithinOneWord(state.tick,tickSpacing,zeroForOne);if(step.tickNext<TickMath.MIN_TICK){step.tickNext=TickMath.MIN_TICK;}else if(step.tickNext>TickMath.MAX_TICK){step.tickNext=TickMath.MAX_TICK;} step.sqrtPriceNextX96=TickMath.getSqrtRatioAtTick(step.tickNext);(state.sqrtPriceX96,step.amountIn,step.amountOut,step.feeAmount)=SwapMath.computeSwapStep(state.sqrtPriceX96,(zeroForOne?step.sqrtPriceNextX96<sqrtPriceLimitX96:step.sqrtPriceNextX96>sqrtPriceLimitX96)?sqrtPriceLimitX96:step.sqrtPriceNextX96,state.liquidity,state.amountSpecifiedRemaining,fee);if(exactInput){state.amountSpecifiedRemaining-=(step.amountIn+step.feeAmount).toInt256();state.amountCalculated=state.amountCalculated.sub(step.amountOut.toInt256());}else{state.amountSpecifiedRemaining+=step.amountOut.toInt256();state.amountCalculated=state.amountCalculated.add((step.amountIn+step.feeAmount).toInt256());} if(cache.feeProtocol>0){uint256 delta=step.feeAmount/cache.feeProtocol;step.feeAmount-=delta;state.protocolFee+=uint128(delta);} if(state.liquidity>0) state.feeGrowthGlobalX128+=FullMath.mulDiv(step.feeAmount,FixedPoint128.Q128,state.liquidity);if(state.sqrtPriceX96==step.sqrtPriceNextX96){if(step.initialized){if(!cache.computedLatestObservation){(cache.tickCumulative,cache.secondsPerLiquidityCumulativeX128)=observations.observeSingle(cache.blockTimestamp,0,slot0Start.tick,slot0Start.observationIndex,cache.liquidityStart,slot0Start.observationCardinality);cache.computedLatestObservation=true;} int128 liquidityNet=ticks.cross(step.tickNext,(zeroForOne?state.feeGrowthGlobalX128:feeGrowthGlobal0X128),(zeroForOne?feeGrowthGlobal1X128:state.feeGrowthGlobalX128),cache.secondsPerLiquidityCumulativeX128,cache.tickCumulative,cache.blockTimestamp);if(zeroForOne)liquidityNet=-liquidityNet;state.liquidity=LiquidityMath.addDelta(state.liquidity,liquidityNet);} state.tick=zeroForOne?step.tickNext-1:step.tickNext;}else if(state.sqrtPriceX96!=step.sqrtPriceStartX96){state.tick=TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);}} if(state.tick!=slot0Start.tick){(uint16 observationIndex,uint16 observationCardinality)=observations.write(slot0Start.observationIndex,cache.blockTimestamp,slot0Start.tick,cache.liquidityStart,slot0Start.observationCardinality,slot0Start.observationCardinalityNext);(slot0.sqrtPriceX96,slot0.tick,slot0.observationIndex,slot0.observationCardinality)=(state.sqrtPriceX96,state.tick,observationIndex,observationCardinality);}else{slot0.sqrtPriceX96=state.sqrtPriceX96;} if(cache.liquidityStart!=state.liquidity)liquidity=state.liquidity;if(zeroForOne){feeGrowthGlobal0X128=state.feeGrowthGlobalX128;if(state.protocolFee>0)protocolFees.token0+=state.protocolFee;}else{feeGrowthGlobal1X128=state.feeGrowthGlobalX128;if(state.protocolFee>0)protocolFees.token1+=state.protocolFee;} (amount0,amount1)=zeroForOne==exactInput?(amountSpecified-state.amountSpecifiedRemaining,state.amountCalculated):(state.amountCalculated,amountSpecified-state.amountSpecifiedRemaining);if(zeroForOne){if(amount1<0)TransferHelper.safeTransfer(token1,recipient,uint256(-amount1));uint256 balance0Before=balance0();IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0,amount1,data);require(balance0Before.add(uint256(amount0))<=balance0(),'IIA');}else{if(amount0<0)TransferHelper.safeTransfer(token0,recipient,uint256(-amount0));uint256 balance1Before=balance1();IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0,amount1,data);require(balance1Before.add(uint256(amount1))<=balance1(),'IIA');} emit Swap(msg.sender,recipient,amount0,amount1,state.sqrtPriceX96,state.liquidity,state.tick);slot0.unlocked=true;} function flash(address recipient,uint256 amount0,uint256 amount1,bytes calldata data)external override lock noDelegateCall{uint128 _liquidity=liquidity;require(_liquidity>0,'L');uint256 fee0=FullMath.mulDivRoundingUp(amount0,fee,1e6);uint256 fee1=FullMath.mulDivRoundingUp(amount1,fee,1e6);uint256 balance0Before=balance0();uint256 balance1Before=balance1();if(amount0>0)TransferHelper.safeTransfer(token0,recipient,amount0);if(amount1>0)TransferHelper.safeTransfer(token1,recipient,amount1);IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0,fee1,data);uint256 balance0After=balance0();uint256 balance1After=balance1();require(balance0Before.add(fee0)<=balance0After,'F0');require(balance1Before.add(fee1)<=balance1After,'F1');uint256 paid0=balance0After-balance0Before;uint256 paid1=balance1After-balance1Before;if(paid0>0){uint8 feeProtocol0=slot0.feeProtocol%16;uint256 fees0=feeProtocol0==0?0:paid0/feeProtocol0;if(uint128(fees0)>0)protocolFees.token0+=uint128(fees0);feeGrowthGlobal0X128+=FullMath.mulDiv(paid0-fees0,FixedPoint128.Q128,_liquidity);} if(paid1>0){uint8 feeProtocol1=slot0.feeProtocol>>4;uint256 fees1=feeProtocol1==0?0:paid1/feeProtocol1;if(uint128(fees1)>0)protocolFees.token1+=uint128(fees1);feeGrowthGlobal1X128+=FullMath.mulDiv(paid1-fees1,FixedPoint128.Q128,_liquidity);} emit Flash(msg.sender,recipient,amount0,amount1,paid0,paid1);} function setFeeProtocol(uint8 feeProtocol0,uint8 feeProtocol1)external override lock onlyFactoryOwner{require((feeProtocol0==0||(feeProtocol0>=4&&feeProtocol0<=10))&&(feeProtocol1==0||(feeProtocol1>=4&&feeProtocol1<=10)));uint8 feeProtocolOld=slot0.feeProtocol;slot0.feeProtocol=feeProtocol0+(feeProtocol1<<4);emit SetFeeProtocol(feeProtocolOld%16,feeProtocolOld>>4,feeProtocol0,feeProtocol1);} function collectProtocol(address recipient,uint128 amount0Requested,uint128 amount1Requested)external override lock onlyFactoryOwner returns(uint128 amount0,uint128 amount1){amount0=amount0Requested>protocolFees.token0?protocolFees.token0:amount0Requested;amount1=amount1Requested>protocolFees.token1?protocolFees.token1:amount1Requested;if(amount0>0){if(amount0==protocolFees.token0)amount0--;protocolFees.token0-=amount0;TransferHelper.safeTransfer(token0,recipient,amount0);} if(amount1>0){if(amount1==protocolFees.token1)amount1--;protocolFees.token1-=amount1;TransferHelper.safeTransfer(token1,recipient,amount1);} emit CollectProtocol(msg.sender,recipient,amount0,amount1);}}

pragma solidity>=0.5.0;import'./pool/IUniswapV3PoolImmutables.sol';import'./pool/IUniswapV3PoolState.sol';import'./pool/IUniswapV3PoolDerivedState.sol';import'./pool/IUniswapV3PoolActions.sol';import'./pool/IUniswapV3PoolOwnerActions.sol';import'./pool/IUniswapV3PoolEvents.sol';interface IUniswapV3Pool is IUniswapV3PoolImmutables,IUniswapV3PoolState,IUniswapV3PoolDerivedState,IUniswapV3PoolActions,IUniswapV3PoolOwnerActions,IUniswapV3PoolEvents {}

pragma solidity=0.7.6;abstract contract NoDelegateCall{address private immutable original;constructor(){original=address(this);} function checkNotDelegateCall()private view{require(address(this)==original);} modifier noDelegateCall(){checkNotDelegateCall();_;}}

pragma solidity>=0.7.0;library LowGasSafeMath{function add(uint256 x,uint256 y)internal pure returns(uint256 z){require((z=x+y)>=x);} function sub(uint256 x,uint256 y)internal pure returns(uint256 z){require((z=x-y)<=x);} function mul(uint256 x,uint256 y)internal pure returns(uint256 z){require(x==0||(z=x*y)/x==y);} function add(int256 x,int256 y)internal pure returns(int256 z){require((z=x+y)>=x==(y>=0));} function sub(int256 x,int256 y)internal pure returns(int256 z){require((z=x-y)<=x==(y>=0));}}

pragma solidity>=0.5.0;library SafeCast{function toUint160(uint256 y)internal pure returns(uint160 z){require((z=uint160(y))==y);} function toInt128(int256 y)internal pure returns(int128 z){require((z=int128(y))==y);} function toInt256(uint256 y)internal pure returns(int256 z){require(y<2**255);z=int256(y);}}

pragma solidity>=0.5.0;import'./LowGasSafeMath.sol';import'./SafeCast.sol';import'./TickMath.sol';import'./LiquidityMath.sol';library Tick{using LowGasSafeMath for int256;using SafeCast for int256;struct Info{uint128 liquidityGross;int128 liquidityNet;uint256 feeGrowthOutside0X128;uint256 feeGrowthOutside1X128;int56 tickCumulativeOutside;uint160 secondsPerLiquidityOutsideX128;uint32 secondsOutside;bool initialized;} function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing)internal pure returns(uint128){int24 minTick=(TickMath.MIN_TICK/tickSpacing)*tickSpacing;int24 maxTick=(TickMath.MAX_TICK/tickSpacing)*tickSpacing;uint24 numTicks=uint24((maxTick-minTick)/tickSpacing)+1;return type(uint128).max/numTicks;} function getFeeGrowthInside(mapping(int24=>Tick.Info)storage self,int24 tickLower,int24 tickUpper,int24 tickCurrent,uint256 feeGrowthGlobal0X128,uint256 feeGrowthGlobal1X128)internal view returns(uint256 feeGrowthInside0X128,uint256 feeGrowthInside1X128){Info storage lower=self[tickLower];Info storage upper=self[tickUpper];uint256 feeGrowthBelow0X128;uint256 feeGrowthBelow1X128;if(tickCurrent>=tickLower){feeGrowthBelow0X128=lower.feeGrowthOutside0X128;feeGrowthBelow1X128=lower.feeGrowthOutside1X128;}else{feeGrowthBelow0X128=feeGrowthGlobal0X128-lower.feeGrowthOutside0X128;feeGrowthBelow1X128=feeGrowthGlobal1X128-lower.feeGrowthOutside1X128;} uint256 feeGrowthAbove0X128;uint256 feeGrowthAbove1X128;if(tickCurrent<tickUpper){feeGrowthAbove0X128=upper.feeGrowthOutside0X128;feeGrowthAbove1X128=upper.feeGrowthOutside1X128;}else{feeGrowthAbove0X128=feeGrowthGlobal0X128-upper.feeGrowthOutside0X128;feeGrowthAbove1X128=feeGrowthGlobal1X128-upper.feeGrowthOutside1X128;} feeGrowthInside0X128=feeGrowthGlobal0X128-feeGrowthBelow0X128-feeGrowthAbove0X128;feeGrowthInside1X128=feeGrowthGlobal1X128-feeGrowthBelow1X128-feeGrowthAbove1X128;} function update(mapping(int24=>Tick.Info)storage self,int24 tick,int24 tickCurrent,int128 liquidityDelta,uint256 feeGrowthGlobal0X128,uint256 feeGrowthGlobal1X128,uint160 secondsPerLiquidityCumulativeX128,int56 tickCumulative,uint32 time,bool upper,uint128 maxLiquidity)internal returns(bool flipped){Tick.Info storage info=self[tick];uint128 liquidityGrossBefore=info.liquidityGross;uint128 liquidityGrossAfter=LiquidityMath.addDelta(liquidityGrossBefore,liquidityDelta);require(liquidityGrossAfter<=maxLiquidity,'LO');flipped=(liquidityGrossAfter==0)!=(liquidityGrossBefore==0);if(liquidityGrossBefore==0){if(tick<=tickCurrent){info.feeGrowthOutside0X128=feeGrowthGlobal0X128;info.feeGrowthOutside1X128=feeGrowthGlobal1X128;info.secondsPerLiquidityOutsideX128=secondsPerLiquidityCumulativeX128;info.tickCumulativeOutside=tickCumulative;info.secondsOutside=time;} info.initialized=true;} info.liquidityGross=liquidityGrossAfter;info.liquidityNet=upper?int256(info.liquidityNet).sub(liquidityDelta).toInt128():int256(info.liquidityNet).add(liquidityDelta).toInt128();} function clear(mapping(int24=>Tick.Info)storage self,int24 tick)internal{delete self[tick];} function cross(mapping(int24=>Tick.Info)storage self,int24 tick,uint256 feeGrowthGlobal0X128,uint256 feeGrowthGlobal1X128,uint160 secondsPerLiquidityCumulativeX128,int56 tickCumulative,uint32 time)internal returns(int128 liquidityNet){Tick.Info storage info=self[tick];info.feeGrowthOutside0X128=feeGrowthGlobal0X128-info.feeGrowthOutside0X128;info.feeGrowthOutside1X128=feeGrowthGlobal1X128-info.feeGrowthOutside1X128;info.secondsPerLiquidityOutsideX128=secondsPerLiquidityCumulativeX128-info.secondsPerLiquidityOutsideX128;info.tickCumulativeOutside=tickCumulative-info.tickCumulativeOutside;info.secondsOutside=time-info.secondsOutside;liquidityNet=info.liquidityNet;}}

pragma solidity>=0.5.0;import'./BitMath.sol';library TickBitmap{function position(int24 tick)private pure returns(int16 wordPos,uint8 bitPos){wordPos=int16(tick>>8);bitPos=uint8(tick%256);} function flipTick(mapping(int16=>uint256)storage self,int24 tick,int24 tickSpacing)internal{require(tick%tickSpacing==0);(int16 wordPos,uint8 bitPos)=position(tick/tickSpacing);uint256 mask=1<<bitPos;self[wordPos]^=mask;} function nextInitializedTickWithinOneWord(mapping(int16=>uint256)storage self,int24 tick,int24 tickSpacing,bool lte)internal view returns(int24 next,bool initialized){int24 compressed=tick/tickSpacing;if(tick<0&&tick%tickSpacing!=0)compressed--;if(lte){(int16 wordPos,uint8 bitPos)=position(compressed);uint256 mask=(1<<bitPos)-1+(1<<bitPos);uint256 masked=self[wordPos]&mask;initialized=masked!=0;next=initialized?(compressed-int24(bitPos-BitMath.mostSignificantBit(masked)))*tickSpacing:(compressed-int24(bitPos))*tickSpacing;}else{(int16 wordPos,uint8 bitPos)=position(compressed+1);uint256 mask=~((1<<bitPos)-1);uint256 masked=self[wordPos]&mask;initialized=masked!=0;next=initialized?(compressed+1+int24(BitMath.leastSignificantBit(masked)-bitPos))*tickSpacing:(compressed+1+int24(type(uint8).max-bitPos))*tickSpacing;}}}

pragma solidity>=0.5.0;import'./FullMath.sol';import'./FixedPoint128.sol';import'./LiquidityMath.sol';library Position{struct Info{uint128 liquidity;uint256 feeGrowthInside0LastX128;uint256 feeGrowthInside1LastX128;uint128 tokensOwed0;uint128 tokensOwed1;} function get(mapping(bytes32=>Info)storage self,address owner,int24 tickLower,int24 tickUpper)internal view returns(Position.Info storage position){position=self[keccak256(abi.encodePacked(owner,tickLower,tickUpper))];} function update(Info storage self,int128 liquidityDelta,uint256 feeGrowthInside0X128,uint256 feeGrowthInside1X128)internal{Info memory _self=self;uint128 liquidityNext;if(liquidityDelta==0){require(_self.liquidity>0,'NP');liquidityNext=_self.liquidity;}else{liquidityNext=LiquidityMath.addDelta(_self.liquidity,liquidityDelta);} uint128 tokensOwed0=uint128(FullMath.mulDiv(feeGrowthInside0X128-_self.feeGrowthInside0LastX128,_self.liquidity,FixedPoint128.Q128));uint128 tokensOwed1=uint128(FullMath.mulDiv(feeGrowthInside1X128-_self.feeGrowthInside1LastX128,_self.liquidity,FixedPoint128.Q128));if(liquidityDelta!=0)self.liquidity=liquidityNext;self.feeGrowthInside0LastX128=feeGrowthInside0X128;self.feeGrowthInside1LastX128=feeGrowthInside1X128;if(tokensOwed0>0||tokensOwed1>0){self.tokensOwed0+=tokensOwed0;self.tokensOwed1+=tokensOwed1;}}}

pragma solidity>=0.5.0;library Oracle{struct Observation{uint32 blockTimestamp;int56 tickCumulative;uint160 secondsPerLiquidityCumulativeX128;bool initialized;} function transform(Observation memory last,uint32 blockTimestamp,int24 tick,uint128 liquidity)private pure returns(Observation memory){uint32 delta=blockTimestamp-last.blockTimestamp;return Observation({blockTimestamp:blockTimestamp,tickCumulative:last.tickCumulative+int56(tick)*delta,secondsPerLiquidityCumulativeX128:last.secondsPerLiquidityCumulativeX128+ ((uint160(delta)<<128)/(liquidity>0?liquidity:1)),initialized:true});} function initialize(Observation[65535]storage self,uint32 time) internal returns(uint16 cardinality,uint16 cardinalityNext) {self[0]=Observation({blockTimestamp:time,tickCumulative:0,secondsPerLiquidityCumulativeX128:0,initialized:true});return(1,1);} function write(Observation[65535]storage self,uint16 index,uint32 blockTimestamp,int24 tick,uint128 liquidity,uint16 cardinality,uint16 cardinalityNext)internal returns(uint16 indexUpdated,uint16 cardinalityUpdated){Observation memory last=self[index];if(last.blockTimestamp==blockTimestamp)return(index,cardinality);if(cardinalityNext>cardinality&&index==(cardinality-1)){cardinalityUpdated=cardinalityNext;}else{cardinalityUpdated=cardinality;} indexUpdated=(index+1)%cardinalityUpdated;self[indexUpdated]=transform(last,blockTimestamp,tick,liquidity);} function grow(Observation[65535]storage self,uint16 current,uint16 next)internal returns(uint16){require(current>0,'I');if(next<=current)return current;for(uint16 i=current;i<next;i++)self[i].blockTimestamp=1;return next;} function lte(uint32 time,uint32 a,uint32 b)private pure returns(bool){if(a<=time&&b<=time)return a<=b;uint256 aAdjusted=a>time?a:a+2**32;uint256 bAdjusted=b>time?b:b+2**32;return aAdjusted<=bAdjusted;} function binarySearch(Observation[65535]storage self,uint32 time,uint32 target,uint16 index,uint16 cardinality)private view returns(Observation memory beforeOrAt,Observation memory atOrAfter){uint256 l=(index+1)%cardinality;uint256 r=l+cardinality-1;uint256 i;while(true){i=(l+r)/2;beforeOrAt=self[i%cardinality];if(!beforeOrAt.initialized){l=i+1;continue;} atOrAfter=self[(i+1)%cardinality];bool targetAtOrAfter=lte(time,beforeOrAt.blockTimestamp,target);if(targetAtOrAfter&&lte(time,target,atOrAfter.blockTimestamp))break;if(!targetAtOrAfter)r=i-1;else l=i+1;}} function getSurroundingObservations(Observation[65535]storage self,uint32 time,uint32 target,int24 tick,uint16 index,uint128 liquidity,uint16 cardinality)private view returns(Observation memory beforeOrAt,Observation memory atOrAfter){beforeOrAt=self[index];if(lte(time,beforeOrAt.blockTimestamp,target)){if(beforeOrAt.blockTimestamp==target){return(beforeOrAt,atOrAfter);}else{return(beforeOrAt,transform(beforeOrAt,target,tick,liquidity));}} beforeOrAt=self[(index+1)%cardinality];if(!beforeOrAt.initialized)beforeOrAt=self[0];require(lte(time,beforeOrAt.blockTimestamp,target),'OLD');return binarySearch(self,time,target,index,cardinality);} function observeSingle(Observation[65535]storage self,uint32 time,uint32 secondsAgo,int24 tick,uint16 index,uint128 liquidity,uint16 cardinality)internal view returns(int56 tickCumulative,uint160 secondsPerLiquidityCumulativeX128){if(secondsAgo==0){Observation memory last=self[index];if(last.blockTimestamp!=time)last=transform(last,time,tick,liquidity);return(last.tickCumulative,last.secondsPerLiquidityCumulativeX128);} uint32 target=time-secondsAgo;(Observation memory beforeOrAt,Observation memory atOrAfter)=getSurroundingObservations(self,time,target,tick,index,liquidity,cardinality);if(target==beforeOrAt.blockTimestamp){return(beforeOrAt.tickCumulative,beforeOrAt.secondsPerLiquidityCumulativeX128);}else if(target==atOrAfter.blockTimestamp){return(atOrAfter.tickCumulative,atOrAfter.secondsPerLiquidityCumulativeX128);}else{uint32 observationTimeDelta=atOrAfter.blockTimestamp-beforeOrAt.blockTimestamp;uint32 targetDelta=target-beforeOrAt.blockTimestamp;return(beforeOrAt.tickCumulative+ ((atOrAfter.tickCumulative-beforeOrAt.tickCumulative)/observationTimeDelta)*targetDelta,beforeOrAt.secondsPerLiquidityCumulativeX128+ uint160((uint256(atOrAfter.secondsPerLiquidityCumulativeX128-beforeOrAt.secondsPerLiquidityCumulativeX128)*targetDelta)/observationTimeDelta));}} function observe(Observation[65535]storage self,uint32 time,uint32[]memory secondsAgos,int24 tick,uint16 index,uint128 liquidity,uint16 cardinality)internal view returns(int56[]memory tickCumulatives,uint160[]memory secondsPerLiquidityCumulativeX128s){require(cardinality>0,'I');tickCumulatives=new int56[](secondsAgos.length);secondsPerLiquidityCumulativeX128s=new uint160[](secondsAgos.length);for(uint256 i=0;i<secondsAgos.length;i++){(tickCumulatives[i],secondsPerLiquidityCumulativeX128s[i])=observeSingle(self,time,secondsAgos[i],tick,index,liquidity,cardinality);}}}

pragma solidity>=0.4.0;library FullMath{function mulDiv(uint256 a,uint256 b,uint256 denominator)internal pure returns(uint256 result){uint256 prod0;uint256 prod1;assembly{let mm:=mulmod(a,b,not(0)) prod0:=mul(a,b) prod1:=sub(sub(mm,prod0),lt(mm,prod0))} if(prod1==0){require(denominator>0);assembly{result:=div(prod0,denominator)} return result;} require(denominator>prod1);uint256 remainder;assembly{remainder:=mulmod(a,b,denominator)} assembly{prod1:=sub(prod1,gt(remainder,prod0)) prod0:=sub(prod0,remainder)} uint256 twos=-denominator&denominator;assembly{denominator:=div(denominator,twos)} assembly{prod0:=div(prod0,twos)} assembly{twos:=add(div(sub(0,twos),twos),1)} prod0|=prod1*twos;uint256 inv=(3*denominator)^2;inv*=2-denominator*inv;inv*=2-denominator*inv;inv*=2-denominator*inv;inv*=2-denominator*inv;inv*=2-denominator*inv;inv*=2-denominator*inv;result=prod0*inv;return result;} function mulDivRoundingUp(uint256 a,uint256 b,uint256 denominator)internal pure returns(uint256 result){result=mulDiv(a,b,denominator);if(mulmod(a,b,denominator)>0){require(result<type(uint256).max);result++;}}}

pragma solidity>=0.4.0;library FixedPoint128{uint256 internal constant Q128=0x100000000000000000000000000000000;}

pragma solidity>=0.6.0;import'../interfaces/IERC20Minimal.sol';library TransferHelper{function safeTransfer(address token,address to,uint256 value)internal{(bool success,bytes memory data)=token.call(abi.encodeWithSelector(IERC20Minimal.transfer.selector,to,value));require(success&&(data.length==0||abi.decode(data,(bool))),'TF');}}

pragma solidity>=0.5.0;library TickMath{int24 internal constant MIN_TICK=-887272;int24 internal constant MAX_TICK=-MIN_TICK;uint160 internal constant MIN_SQRT_RATIO=4295128739;uint160 internal constant MAX_SQRT_RATIO=1461446703485210103287273052203988822378723970342;function getSqrtRatioAtTick(int24 tick)internal pure returns(uint160 sqrtPriceX96){uint256 absTick=tick<0?uint256(-int256(tick)):uint256(int256(tick));require(absTick<=uint256(MAX_TICK),'T');uint256 ratio=absTick&0x1!=0?0xfffcb933bd6fad37aa2d162d1a594001:0x100000000000000000000000000000000;if(absTick&0x2!=0)ratio=(ratio*0xfff97272373d413259a46990580e213a)>>128;if(absTick&0x4!=0)ratio=(ratio*0xfff2e50f5f656932ef12357cf3c7fdcc)>>128;if(absTick&0x8!=0)ratio=(ratio*0xffe5caca7e10e4e61c3624eaa0941cd0)>>128;if(absTick&0x10!=0)ratio=(ratio*0xffcb9843d60f6159c9db58835c926644)>>128;if(absTick&0x20!=0)ratio=(ratio*0xff973b41fa98c081472e6896dfb254c0)>>128;if(absTick&0x40!=0)ratio=(ratio*0xff2ea16466c96a3843ec78b326b52861)>>128;if(absTick&0x80!=0)ratio=(ratio*0xfe5dee046a99a2a811c461f1969c3053)>>128;if(absTick&0x100!=0)ratio=(ratio*0xfcbe86c7900a88aedcffc83b479aa3a4)>>128;if(absTick&0x200!=0)ratio=(ratio*0xf987a7253ac413176f2b074cf7815e54)>>128;if(absTick&0x400!=0)ratio=(ratio*0xf3392b0822b70005940c7a398e4b70f3)>>128;if(absTick&0x800!=0)ratio=(ratio*0xe7159475a2c29b7443b29c7fa6e889d9)>>128;if(absTick&0x1000!=0)ratio=(ratio*0xd097f3bdfd2022b8845ad8f792aa5825)>>128;if(absTick&0x2000!=0)ratio=(ratio*0xa9f746462d870fdf8a65dc1f90e061e5)>>128;if(absTick&0x4000!=0)ratio=(ratio*0x70d869a156d2a1b890bb3df62baf32f7)>>128;if(absTick&0x8000!=0)ratio=(ratio*0x31be135f97d08fd981231505542fcfa6)>>128;if(absTick&0x10000!=0)ratio=(ratio*0x9aa508b5b7a84e1c677de54f3e99bc9)>>128;if(absTick&0x20000!=0)ratio=(ratio*0x5d6af8dedb81196699c329225ee604)>>128;if(absTick&0x40000!=0)ratio=(ratio*0x2216e584f5fa1ea926041bedfe98)>>128;if(absTick&0x80000!=0)ratio=(ratio*0x48a170391f7dc42444e8fa2)>>128;if(tick>0)ratio=type(uint256).max/ratio;sqrtPriceX96=uint160((ratio>>32)+(ratio%(1<<32)==0?0:1));} function getTickAtSqrtRatio(uint160 sqrtPriceX96)internal pure returns(int24 tick){require(sqrtPriceX96>=MIN_SQRT_RATIO&&sqrtPriceX96<MAX_SQRT_RATIO,'R');uint256 ratio=uint256(sqrtPriceX96)<<32;uint256 r=ratio;uint256 msb=0;assembly{let f:=shl(7,gt(r,0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) msb:=or(msb,f) r:=shr(f,r)} assembly{let f:=shl(6,gt(r,0xFFFFFFFFFFFFFFFF)) msb:=or(msb,f) r:=shr(f,r)} assembly{let f:=shl(5,gt(r,0xFFFFFFFF)) msb:=or(msb,f) r:=shr(f,r)} assembly{let f:=shl(4,gt(r,0xFFFF)) msb:=or(msb,f) r:=shr(f,r)} assembly{let f:=shl(3,gt(r,0xFF)) msb:=or(msb,f) r:=shr(f,r)} assembly{let f:=shl(2,gt(r,0xF)) msb:=or(msb,f) r:=shr(f,r)} assembly{let f:=shl(1,gt(r,0x3)) msb:=or(msb,f) r:=shr(f,r)} assembly{let f:=gt(r,0x1) msb:=or(msb,f)} if(msb>=128)r=ratio>>(msb-127);else r=ratio<<(127-msb);int256 log_2=(int256(msb)-128)<<64;assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(63,f)) r:=shr(f,r)} assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(62,f)) r:=shr(f,r)} assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(61,f)) r:=shr(f,r)} assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(60,f)) r:=shr(f,r)} assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(59,f)) r:=shr(f,r)} assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(58,f)) r:=shr(f,r)} assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(57,f)) r:=shr(f,r)} assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(56,f)) r:=shr(f,r)} assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(55,f)) r:=shr(f,r)} assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(54,f)) r:=shr(f,r)} assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(53,f)) r:=shr(f,r)} assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(52,f)) r:=shr(f,r)} assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(51,f)) r:=shr(f,r)} assembly{r:=shr(127,mul(r,r)) let f:=shr(128,r) log_2:=or(log_2,shl(50,f))} int256 log_sqrt10001=log_2*255738958999603826347141;int24 tickLow=int24((log_sqrt10001-3402992956809132418596140100660247210)>>128);int24 tickHi=int24((log_sqrt10001+291339464771989622907027621153398088495)>>128);tick=tickLow==tickHi?tickLow:getSqrtRatioAtTick(tickHi)<=sqrtPriceX96?tickHi:tickLow;}}

pragma solidity>=0.5.0;library LiquidityMath{function addDelta(uint128 x,int128 y)internal pure returns(uint128 z){if(y<0){require((z=x-uint128(-y))<x,'LS');}else{require((z=x+uint128(y))>=x,'LA');}}}

pragma solidity>=0.5.0;import'./LowGasSafeMath.sol';import'./SafeCast.sol';import'./FullMath.sol';import'./UnsafeMath.sol';import'./FixedPoint96.sol';library SqrtPriceMath{using LowGasSafeMath for uint256;using SafeCast for uint256;function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96,uint128 liquidity,uint256 amount,bool add)internal pure returns(uint160){if(amount==0)return sqrtPX96;uint256 numerator1=uint256(liquidity)<<FixedPoint96.RESOLUTION;if(add){uint256 product;if((product=amount*sqrtPX96)/amount==sqrtPX96){uint256 denominator=numerator1+product;if(denominator>=numerator1) return uint160(FullMath.mulDivRoundingUp(numerator1,sqrtPX96,denominator));} return uint160(UnsafeMath.divRoundingUp(numerator1,(numerator1/sqrtPX96).add(amount)));}else{uint256 product;require((product=amount*sqrtPX96)/amount==sqrtPX96&&numerator1>product);uint256 denominator=numerator1-product;return FullMath.mulDivRoundingUp(numerator1,sqrtPX96,denominator).toUint160();}} function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96,uint128 liquidity,uint256 amount,bool add)internal pure returns(uint160){if(add){uint256 quotient=(amount<=type(uint160).max?(amount<<FixedPoint96.RESOLUTION)/liquidity:FullMath.mulDiv(amount,FixedPoint96.Q96,liquidity));return uint256(sqrtPX96).add(quotient).toUint160();}else{uint256 quotient=(amount<=type(uint160).max?UnsafeMath.divRoundingUp(amount<<FixedPoint96.RESOLUTION,liquidity):FullMath.mulDivRoundingUp(amount,FixedPoint96.Q96,liquidity));require(sqrtPX96>quotient);return uint160(sqrtPX96-quotient);}} function getNextSqrtPriceFromInput(uint160 sqrtPX96,uint128 liquidity,uint256 amountIn,bool zeroForOne)internal pure returns(uint160 sqrtQX96){require(sqrtPX96>0);require(liquidity>0);return zeroForOne?getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96,liquidity,amountIn,true):getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96,liquidity,amountIn,true);} function getNextSqrtPriceFromOutput(uint160 sqrtPX96,uint128 liquidity,uint256 amountOut,bool zeroForOne)internal pure returns(uint160 sqrtQX96){require(sqrtPX96>0);require(liquidity>0);return zeroForOne?getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96,liquidity,amountOut,false):getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96,liquidity,amountOut,false);} function getAmount0Delta(uint160 sqrtRatioAX96,uint160 sqrtRatioBX96,uint128 liquidity,bool roundUp)internal pure returns(uint256 amount0){if(sqrtRatioAX96>sqrtRatioBX96)(sqrtRatioAX96,sqrtRatioBX96)=(sqrtRatioBX96,sqrtRatioAX96);uint256 numerator1=uint256(liquidity)<<FixedPoint96.RESOLUTION;uint256 numerator2=sqrtRatioBX96-sqrtRatioAX96;require(sqrtRatioAX96>0);return roundUp?UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(numerator1,numerator2,sqrtRatioBX96),sqrtRatioAX96):FullMath.mulDiv(numerator1,numerator2,sqrtRatioBX96)/sqrtRatioAX96;} function getAmount1Delta(uint160 sqrtRatioAX96,uint160 sqrtRatioBX96,uint128 liquidity,bool roundUp)internal pure returns(uint256 amount1){if(sqrtRatioAX96>sqrtRatioBX96)(sqrtRatioAX96,sqrtRatioBX96)=(sqrtRatioBX96,sqrtRatioAX96);return roundUp?FullMath.mulDivRoundingUp(liquidity,sqrtRatioBX96-sqrtRatioAX96,FixedPoint96.Q96):FullMath.mulDiv(liquidity,sqrtRatioBX96-sqrtRatioAX96,FixedPoint96.Q96);} function getAmount0Delta(uint160 sqrtRatioAX96,uint160 sqrtRatioBX96,int128 liquidity)internal pure returns(int256 amount0){return liquidity<0?-getAmount0Delta(sqrtRatioAX96,sqrtRatioBX96,uint128(-liquidity),false).toInt256():getAmount0Delta(sqrtRatioAX96,sqrtRatioBX96,uint128(liquidity),true).toInt256();} function getAmount1Delta(uint160 sqrtRatioAX96,uint160 sqrtRatioBX96,int128 liquidity)internal pure returns(int256 amount1){return liquidity<0?-getAmount1Delta(sqrtRatioAX96,sqrtRatioBX96,uint128(-liquidity),false).toInt256():getAmount1Delta(sqrtRatioAX96,sqrtRatioBX96,uint128(liquidity),true).toInt256();}}

pragma solidity>=0.5.0;import'./FullMath.sol';import'./SqrtPriceMath.sol';library SwapMath{function computeSwapStep(uint160 sqrtRatioCurrentX96,uint160 sqrtRatioTargetX96,uint128 liquidity,int256 amountRemaining,uint24 feePips) internal pure returns(uint160 sqrtRatioNextX96,uint256 amountIn,uint256 amountOut,uint256 feeAmount) {bool zeroForOne=sqrtRatioCurrentX96>=sqrtRatioTargetX96;bool exactIn=amountRemaining>=0;if(exactIn){uint256 amountRemainingLessFee=FullMath.mulDiv(uint256(amountRemaining),1e6-feePips,1e6);amountIn=zeroForOne?SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96,sqrtRatioCurrentX96,liquidity,true):SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96,sqrtRatioTargetX96,liquidity,true);if(amountRemainingLessFee>=amountIn)sqrtRatioNextX96=sqrtRatioTargetX96;else sqrtRatioNextX96=SqrtPriceMath.getNextSqrtPriceFromInput(sqrtRatioCurrentX96,liquidity,amountRemainingLessFee,zeroForOne);}else{amountOut=zeroForOne?SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96,sqrtRatioCurrentX96,liquidity,false):SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96,sqrtRatioTargetX96,liquidity,false);if(uint256(-amountRemaining)>=amountOut)sqrtRatioNextX96=sqrtRatioTargetX96;else sqrtRatioNextX96=SqrtPriceMath.getNextSqrtPriceFromOutput(sqrtRatioCurrentX96,liquidity,uint256(-amountRemaining),zeroForOne);} bool max=sqrtRatioTargetX96==sqrtRatioNextX96;if(zeroForOne){amountIn=max&&exactIn?amountIn:SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96,sqrtRatioCurrentX96,liquidity,true);amountOut=max&&!exactIn?amountOut:SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96,sqrtRatioCurrentX96,liquidity,false);}else{amountIn=max&&exactIn?amountIn:SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96,sqrtRatioNextX96,liquidity,true);amountOut=max&&!exactIn?amountOut:SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96,sqrtRatioNextX96,liquidity,false);} if(!exactIn&&amountOut>uint256(-amountRemaining)){amountOut=uint256(-amountRemaining);} if(exactIn&&sqrtRatioNextX96!=sqrtRatioTargetX96){feeAmount=uint256(amountRemaining)-amountIn;}else{feeAmount=FullMath.mulDivRoundingUp(amountIn,feePips,1e6-feePips);}}}

pragma solidity>=0.5.0;interface IUniswapV3PoolDeployer{function parameters() external view returns(address factory,address token0,address token1,uint24 fee,int24 tickSpacing);}

pragma solidity>=0.5.0;interface IUniswapV3Factory{event OwnerChanged(address indexed oldOwner,address indexed newOwner);event PoolCreated(address indexed token0,address indexed token1,uint24 indexed fee,int24 tickSpacing,address pool);event FeeAmountEnabled(uint24 indexed fee,int24 indexed tickSpacing);function owner()external view returns(address);function feeAmountTickSpacing(uint24 fee)external view returns(int24);function getPool(address tokenA,address tokenB,uint24 fee)external view returns(address pool);function createPool(address tokenA,address tokenB,uint24 fee)external returns(address pool);function setOwner(address _owner)external;function enableFeeAmount(uint24 fee,int24 tickSpacing)external;}

pragma solidity>=0.5.0;interface IERC20Minimal{function balanceOf(address account)external view returns(uint256);function transfer(address recipient,uint256 amount)external returns(bool);function allowance(address owner,address spender)external view returns(uint256);function approve(address spender,uint256 amount)external returns(bool);function transferFrom(address sender,address recipient,uint256 amount)external returns(bool);event Transfer(address indexed from,address indexed to,uint256 value);event Approval(address indexed owner,address indexed spender,uint256 value);}

pragma solidity>=0.5.0;interface IUniswapV3MintCallback{function uniswapV3MintCallback(uint256 amount0Owed,uint256 amount1Owed,bytes calldata data)external;}

pragma solidity>=0.5.0;interface IUniswapV3SwapCallback{function uniswapV3SwapCallback(int256 amount0Delta,int256 amount1Delta,bytes calldata data)external;}

pragma solidity>=0.5.0;interface IUniswapV3FlashCallback{function uniswapV3FlashCallback(uint256 fee0,uint256 fee1,bytes calldata data)external;}

pragma solidity>=0.5.0;interface IUniswapV3PoolImmutables{function factory()external view returns(address);function token0()external view returns(address);function token1()external view returns(address);function fee()external view returns(uint24);function tickSpacing()external view returns(int24);function maxLiquidityPerTick()external view returns(uint128);}

pragma solidity>=0.5.0;interface IUniswapV3PoolState{function slot0() external view returns(uint160 sqrtPriceX96,int24 tick,uint16 observationIndex,uint16 observationCardinality,uint16 observationCardinalityNext,uint8 feeProtocol,bool unlocked);function feeGrowthGlobal0X128()external view returns(uint256);function feeGrowthGlobal1X128()external view returns(uint256);function protocolFees()external view returns(uint128 token0,uint128 token1);function liquidity()external view returns(uint128);function ticks(int24 tick) external view returns(uint128 liquidityGross,int128 liquidityNet,uint256 feeGrowthOutside0X128,uint256 feeGrowthOutside1X128,int56 tickCumulativeOutside,uint160 secondsPerLiquidityOutsideX128,uint32 secondsOutside,bool initialized);function tickBitmap(int16 wordPosition)external view returns(uint256);function positions(bytes32 key) external view returns(uint128 _liquidity,uint256 feeGrowthInside0LastX128,uint256 feeGrowthInside1LastX128,uint128 tokensOwed0,uint128 tokensOwed1);function observations(uint256 index) external view returns(uint32 blockTimestamp,int56 tickCumulative,uint160 secondsPerLiquidityCumulativeX128,bool initialized);}

pragma solidity>=0.5.0;interface IUniswapV3PoolDerivedState{function observe(uint32[]calldata secondsAgos) external view returns(int56[]memory tickCumulatives,uint160[]memory secondsPerLiquidityCumulativeX128s);function snapshotCumulativesInside(int24 tickLower,int24 tickUpper) external view returns(int56 tickCumulativeInside,uint160 secondsPerLiquidityInsideX128,uint32 secondsInside);}

pragma solidity>=0.5.0;interface IUniswapV3PoolActions{function initialize(uint160 sqrtPriceX96)external;function mint(address recipient,int24 tickLower,int24 tickUpper,uint128 amount,bytes calldata data)external returns(uint256 amount0,uint256 amount1);function collect(address recipient,int24 tickLower,int24 tickUpper,uint128 amount0Requested,uint128 amount1Requested)external returns(uint128 amount0,uint128 amount1);function burn(int24 tickLower,int24 tickUpper,uint128 amount)external returns(uint256 amount0,uint256 amount1);function swap(address recipient,bool zeroForOne,int256 amountSpecified,uint160 sqrtPriceLimitX96,bytes calldata data)external returns(int256 amount0,int256 amount1);function flash(address recipient,uint256 amount0,uint256 amount1,bytes calldata data)external;function increaseObservationCardinalityNext(uint16 observationCardinalityNext)external;}

pragma solidity>=0.5.0;interface IUniswapV3PoolOwnerActions{function setFeeProtocol(uint8 feeProtocol0,uint8 feeProtocol1)external;function collectProtocol(address recipient,uint128 amount0Requested,uint128 amount1Requested)external returns(uint128 amount0,uint128 amount1);}

pragma solidity>=0.5.0;interface IUniswapV3PoolEvents{event Initialize(uint160 sqrtPriceX96,int24 tick);event Mint(address sender,address indexed owner,int24 indexed tickLower,int24 indexed tickUpper,uint128 amount,uint256 amount0,uint256 amount1);event Collect(address indexed owner,address recipient,int24 indexed tickLower,int24 indexed tickUpper,uint128 amount0,uint128 amount1);event Burn(address indexed owner,int24 indexed tickLower,int24 indexed tickUpper,uint128 amount,uint256 amount0,uint256 amount1);event Swap(address indexed sender,address indexed recipient,int256 amount0,int256 amount1,uint160 sqrtPriceX96,uint128 liquidity,int24 tick);event Flash(address indexed sender,address indexed recipient,uint256 amount0,uint256 amount1,uint256 paid0,uint256 paid1);event IncreaseObservationCardinalityNext(uint16 observationCardinalityNextOld,uint16 observationCardinalityNextNew);event SetFeeProtocol(uint8 feeProtocol0Old,uint8 feeProtocol1Old,uint8 feeProtocol0New,uint8 feeProtocol1New);event CollectProtocol(address indexed sender,address indexed recipient,uint128 amount0,uint128 amount1);}

pragma solidity>=0.5.0;library BitMath{function mostSignificantBit(uint256 x)internal pure returns(uint8 r){require(x>0);if(x>=0x100000000000000000000000000000000){x>>=128;r+=128;} if(x>=0x10000000000000000){x>>=64;r+=64;} if(x>=0x100000000){x>>=32;r+=32;} if(x>=0x10000){x>>=16;r+=16;} if(x>=0x100){x>>=8;r+=8;} if(x>=0x10){x>>=4;r+=4;} if(x>=0x4){x>>=2;r+=2;} if(x>=0x2)r+=1;} function leastSignificantBit(uint256 x)internal pure returns(uint8 r){require(x>0);r=255;if(x&type(uint128).max>0){r-=128;}else{x>>=128;} if(x&type(uint64).max>0){r-=64;}else{x>>=64;} if(x&type(uint32).max>0){r-=32;}else{x>>=32;} if(x&type(uint16).max>0){r-=16;}else{x>>=16;} if(x&type(uint8).max>0){r-=8;}else{x>>=8;} if(x&0xf>0){r-=4;}else{x>>=4;} if(x&0x3>0){r-=2;}else{x>>=2;} if(x&0x1>0)r-=1;}}

pragma solidity>=0.5.0;library UnsafeMath{function divRoundingUp(uint256 x,uint256 y)internal pure returns(uint256 z){assembly{z:=add(div(x,y),gt(mod(x,y),0))}}}

pragma solidity>=0.4.0;library FixedPoint96{uint8 internal constant RESOLUTION=96;uint256 internal constant Q96=0x1000000000000000000000000;}

{
  "optimizer": {
    "enabled": true,
    "runs": 800
  },
  "metadata": {
    "bytecodeHash": "none"
  },
  "outputSelection": {
    "*": {
      "*": [
        "evm.bytecode",
        "evm.deployedBytecode",
        "abi"
      ]
    }
  },
  "libraries": {}
}