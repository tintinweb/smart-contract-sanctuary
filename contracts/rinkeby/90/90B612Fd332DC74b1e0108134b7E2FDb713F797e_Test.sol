/**
 *Submitted for verification at Etherscan.io on 2022-01-13
*/

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

library MathLib {

    // Table index into the trigonometric table
    uint constant INDEX_WIDTH = 4;
    // Interpolation between successive entries in the tables
    uint constant INTERP_WIDTH = 8;
    uint constant INDEX_OFFSET = 12 - INDEX_WIDTH;
    uint constant INTERP_OFFSET = INDEX_OFFSET - INTERP_WIDTH;
    int constant ANGLES_IN_CYCLE = 16384;
    uint16 constant QUADRANT_HIGH_MASK = 8192;
    uint16 constant QUADRANT_LOW_MASK = 4096;
    uint constant SINE_TABLE_SIZE = 16;
    uint8 constant RATIO_MIN_VALUE = 2;

    // constant sine lookup table generated by gen_tables.py
    // We have no other choice but this since constant arrays don't yet exist
    uint8 constant entry_bytes = 2;
    bytes constant sin_table = "\x00\x00\x0c\x8c\x18\xf9\x25\x28\x30\xfb\x3c\x56\x47\x1c\x51\x33\x5a\x82\x62\xf1\x6a\x6d\x70\xe2\x76\x41\x7a\x7c\x7d\x89\x7f\x61\x7f\xff";

    /**
     * Convenience function to apply a mask on an integer to extract a certain
     * number of bits. Using exponents since solidity still does not support
     * shifting.
     *
     * @param _value The integer whose bits we want to get
     * @param _width The width of the bits (in bits) we want to extract
     * @param _offset The offset of the bits (in bits) we want to extract
     * @return An integer containing _width bits of _value starting at the
     *         _offset bit
     */
    function bits(uint _value, uint _width, uint _offset) internal pure returns (uint) {
        return (_value / (2 ** _offset)) & (((2 ** _width)) - 1);
    }

    /**
     * Convenience function to apply a mask on an integer to extract a certain
     * number of bits. Using exponents since solidity still does not support
     * shifting.
     *
     * @param _value The integer whose bits we want to get
     * @return An integer containing _width bits of _value starting at the
     *         _offset bit
     */
    function log_2(uint256 _value) internal pure returns (uint8) {
        uint8 log2_res = 0;
        if (_value < 256) {
            while (_value > 1) {
                _value >>= 1;
                log2_res += 1;
            }
        } else {
            for (uint8 s = 128; s > 0; s >>= 1) {
                if (_value >= (1 << s)) {
                    _value >>= s;
                    log2_res |= s;
                }
            }
        }

        return log2_res;
    }

    function sin_table_lookup(uint index) internal pure returns (uint16) {
        bytes memory table = sin_table;
        uint offset = (index + 1) * entry_bytes;
        uint16 trigint_value;
        assembly {
            trigint_value := mload(add(table, offset))
        }

        return trigint_value;
    }

    function sqrt(uint256 y) internal pure returns (uint256) {
      uint256 result;
      if (y > 3) {
          result = y;
          uint256 x = y / 2 + 1;
          while (x < result) {
              result = x;
              x = (y / x + x) / 2;
          }
      } else if (y != 0) {
          result = 1;
      }

      return result;
    }

    function abs(int256 x) internal pure returns (int256) {
        return x < 0 ? x*(-1) : x;
    }

    /**
     * Return the sine of an integer approximated angle as a signed 16-bit
     * integer.
     *
     * @param param A 14-bit angle. This divides the circle into 16384
     *               angle units, instead of the standard 360 degrees.
     * @return The sine result as a number in the range -32767 to 32767.
     */
    function sin(int256 param) internal pure returns (int) {
        while(param < 0) {
            param = param + 16384;
        }
        uint _angle = uint(param % 16384);
        uint interp = bits(_angle, INTERP_WIDTH, INTERP_OFFSET);
        uint index = bits(_angle, INDEX_WIDTH, INDEX_OFFSET);

        bool is_odd_quadrant = (_angle & QUADRANT_LOW_MASK) == 0;
        bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0;

        if (!is_odd_quadrant) {
            index = SINE_TABLE_SIZE - 1 - index;
        }

        uint x1 = sin_table_lookup(index);
        uint x2 = sin_table_lookup(index + 1);
        uint approximation = ((x2 - x1) * interp) / (2 ** INTERP_WIDTH);

        int sine;
        if (is_odd_quadrant) {
            sine = int(x1) + int(approximation);
        } else {
            sine = int(x2) - int(approximation);
        }

        if (is_negative_quadrant) {
            sine *= -1;
        }

        return sine;
    }

    /**
     * Return the cos of an integer approximated angle.
     * It functions just like the sin() method but uses the trigonometric
     * identity sin(x + pi/2) = cos(x) to quickly calculate the cos.
     */
    function cos(int256 param) internal pure returns (int) {
        while(param < 0) {
            param = param + 16384;
        }
        int _angle = param % 16384;

        if (_angle > 16384 - 4096) {
            _angle = 4096 - 16384 - _angle;
        } else {
            _angle += 4096;
        }
       return sin(int(_angle));
    }

    /**
     * Return the angle of an integer approximated ratio as a signed 256-bit
     * integer.
     *
     * @param _ratio A 256-bit(unit 1) ratio as a number in the range 0 to infinite.
     * @return The arctan result is A 256-bit angle. This divides the circle into 4 * 340282366920938463463374607431768211455 (2^256)
     *               angle units, instead of the standard 360 degrees.                785118600829010179644344535919513282844767027200
     */
    function arctan(uint256 _ratio) internal pure returns (uint256) {
        uint128[256] memory arctan_table = [
            0x1,
            0x2,
            0x5,
            0xa,
            0x14,
            0x28,
            0x51,
            0xa2,
            0x145,
            0x28b,
            0x517,
            0xa2f,
            0x145f,
            0x28be,
            0x517c,
            0xa2f9,
            0x145f3,
            0x28be6,
            0x517cc,
            0xa2f98,
            0x145f30,
            0x28be60,
            0x517cc1,
            0xa2f983,
            0x145f306,
            0x28be60d,
            0x517cc1b,
            0xa2f9836,
            0x145f306d,
            0x28be60db,
            0x517cc1b7,
            0xa2f9836e,
            0x145f306dc,
            0x28be60db9,
            0x517cc1b72,
            0xa2f9836e4,
            0x145f306dc9,
            0x28be60db93,
            0x517cc1b727,
            0xa2f9836e4e,
            0x145f306dc9c,
            0x28be60db939,
            0x517cc1b7272,
            0xa2f9836e4e4,
            0x145f306dc9c8,
            0x28be60db9391,
            0x517cc1b72722,
            0xa2f9836e4e44,
            0x145f306dc9c88,
            0x28be60db93910,
            0x517cc1b727220,
            0xa2f9836e4e441,
            0x145f306dc9c882,
            0x28be60db939105,
            0x517cc1b727220a,
            0xa2f9836e4e4415,
            0x145f306dc9c882a,
            0x28be60db9391054,
            0x517cc1b727220a9,
            0xa2f9836e4e44152,
            0x145f306dc9c882a5,
            0x28be60db9391054a,
            0x517cc1b727220a94,
            0xa2f9836e4e441529,
            0x145f306dc9c882a53,
            0x28be60db9391054a7,
            0x517cc1b727220a94f,
            0xa2f9836e4e441529f,
            0x145f306dc9c882a53f,
            0x28be60db9391054a7f,
            0x517cc1b727220a94fe,
            0xa2f9836e4e441529fc,
            0x145f306dc9c882a53f8,
            0x28be60db9391054a7f0,
            0x517cc1b727220a94fe1,
            0xa2f9836e4e441529fc2,
            0x145f306dc9c882a53f84,
            0x28be60db9391054a7f09,
            0x517cc1b727220a94fe13,
            0xa2f9836e4e441529fc27,
            0x145f306dc9c882a53f84e,
            0x28be60db9391054a7f09d,
            0x517cc1b727220a94fe13a,
            0xa2f9836e4e441529fc275,
            0x145f306dc9c882a53f84ea,
            0x28be60db9391054a7f09d5,
            0x517cc1b727220a94fe13a5,
            0xa2f9836e4e441529fc2721,
            0x145f306dc9c882a53f84cfd,
            0x28be60db9391054a7f08fca,
            0x517cc1b727220a94fe0ce18,
            0xa2f9836e4e441529fbf104a,
            0x145f306dc9c882a53f69c164,
            0x28be60db9391054a7e308945,
            0x517cc1b727220a94f749466f,
            0xa2f9836e4e441529c5d42c02,
            0x145f306dc9c882a5245b55128,
            0x28be60db93910549a5bd26b6b,
            0x517cc1b727220a8e33ae31fb0,
            0xa2f9836e4e4414f3a8fb88628,
            0x145f306dc9c8828a15ef034288,
            0x28be60db93910471325a9836cd,
            0x517cc1b7272203ca9899bdfb7a,
            0xa2f9836e4e43ded6d057e8660e,
            0x145f306dc9c8677ba99d33447c5,
            0x28be60db93902bfdcfcc184c872,
            0x517cc1b7271b402f8425bf6cdb4,
            0xa2f9836e4e0dc1fe2cb80c6334b,
            0x145f306dc9ad590f57cd762752a0,
            0x28be60db92b7b89b41544beba46f,
            0x517cc1b72057a51b112aed731e45,
            0xa2f9836e17f0e95aad539e405542,
            0x145f306dae9eecbdc8ff826b71243,
            0x28be60daba445614e76d187ce4f82,
            0x517cc1b05cbc91abd2fe7f4921e75,
            0xa2f98337fb186652dd8577a994773,
            0x145f3052a032dc1e23c00e5d9aaf49,
            0x28be600246e9ed9fd0ea488467200a,
            0x517cbaecc2acdee4d07cb50e3ba109,
            0xa2f94d1b430cdbf245e9bac7b0f2ad,
            0x145f15447510aba8b0c1b2b7aaa6c7a,
            0x28bd87970a098a6135afd62d2d16923,
            0x5175f85641189e15a72537a0b6bdce8,
            0xa2c350c39626bb303300048a6da76f3,
            0x144447507776686dfe49572c7c78a5a9,
            0x27ece16d7b8e7a377d0fcf2824878347,
            0x4b90147677cc21995a23db6b8d4656bf,
            0x80000000000000000000000000000000,
            0xb46feb898833de66a5dc249472b9a940,
            0xd8131e92847185c882f030d7db787cb8,
            0xebbbb8af8889979201b6a8d383875a56,
            0xf5d3caf3c69d944cfccfffb75925890c,
            0xfae8a07a9bee761ea58dac85f4942317,
            0xfd7427868f5f6759eca5029d2d2e96dc,
            0xfeba0eabb8aef54574f3e4d485559385,
            0xff5d06b2e4bcf3240dba1645384f0d52,
            0xffae8345133d53211b2f834af1c45ef6,
            0xffd7419ffdb91612602f15b77b98dff5,
            0xffeba0cfad5fcd23e1dc3ff1a26550b6,
            0xfff5d067cc804e799ad227a88566b88c,
            0xfffae833e4fa3436e542d0180b6de18a,
            0xfffd7419f2545bba9eb1892e7831b07d,
            0xfffeba0cf925161134237007d948edbc,
            0xffff5d067c91e80f16a552ac61bfaabd,
            0xffffae833e48dfa85ae4eed5128ce1ba,
            0xffffd7419f246d484764beabb4145b90,
            0xffffeba0cf923652a6f0a83289d8ad5f,
            0xfffff5d067c91b1f23e01d347f39ccb4,
            0xfffffae833e48d8e4bfd07bda409324b,
            0xfffffd7419f246c6fd4023033e7b378d,
            0xfffffeba0cf92363798845662ccbb83a,
            0xffffff5d067c91b1bc21292fa81799f1,
            0xffffffae833e48d8ddfc356766420485,
            0xffffffd7419f246c6efb8ecda567c932,
            0xffffffeba0cf9236377d75ea10fcbd77,
            0xfffffff5d067c91b1bbeb0c5704779d7,
            0xfffffffae833e48d8ddf571cc51ce04f,
            0xfffffffd7419f246c6efab65a42d9494,
            0xfffffffeba0cf9236377d5adba4aaed7,
            0xffffffff5d067c91b1bbead63a2bd3fd,
            0xffffffffae833e48d8ddf56b08b6b990,
            0xffffffffd7419f246c6efab581cf76ba,
            0xffffffffeba0cf9236377d5ac0963e9b,
            0xfffffffff5d067c91b1bbead6040efb5,
            0xfffffffffae833e48d8ddf56b01f31e7,
            0xfffffffffd7419f246c6efab580f7035,
            0xfffffffffeba0cf9236377d5ac07b302,
            0xffffffffff5d067c91b1bbead603d8de,
            0xffffffffffae833e48d8ddf56b01ec5a,
            0xffffffffffd7419f246c6efab580f62a,
            0xffffffffffeba0cf9236377d5ac07b15,
            0xfffffffffff5d067c91b1bbead603d8a,
            0xfffffffffffae833e48d8ddf56b01ec5,
            0xfffffffffffd7419f246c6efab580f62,
            0xfffffffffffeba0cf9236377d5ac07b1,
            0xffffffffffff5d067c91b1bbead603d8,
            0xffffffffffffae833e48d8ddf56b01ec,
            0xffffffffffffd7419f246c6efab580f6,
            0xffffffffffffeba0cf9236377d5ac07b,
            0xfffffffffffff5d067c91b1bbead603d,
            0xfffffffffffffae833e48d8ddf56b01e,
            0xfffffffffffffd7419f246c6efab580f,
            0xfffffffffffffeba0cf9236377d5ac07,
            0xffffffffffffff5d067c91b1bbead603,
            0xffffffffffffffae833e48d8ddf56b01,
            0xffffffffffffffd7419f246c6efab580,
            0xffffffffffffffeba0cf9236377d5ac0,
            0xfffffffffffffff5d067c91b1bbead60,
            0xfffffffffffffffae833e48d8ddf56b0,
            0xfffffffffffffffd7419f246c6efab58,
            0xfffffffffffffffeba0cf9236377d5ac,
            0xffffffffffffffff5d067c91b1bbead6,
            0xffffffffffffffffae833e48d8ddf56b,
            0xffffffffffffffffd7419f246c6efab5,
            0xffffffffffffffffeba0cf9236377d5a,
            0xfffffffffffffffff5d067c91b1bbead,
            0xfffffffffffffffffae833e48d8ddf56,
            0xfffffffffffffffffd7419f246c6efab,
            0xfffffffffffffffffeba0cf9236377d5,
            0xffffffffffffffffff5d067c91b1bbea,
            0xffffffffffffffffffae833e48d8ddf5,
            0xffffffffffffffffffd7419f246c6efa,
            0xffffffffffffffffffeba0cf9236377d,
            0xfffffffffffffffffff5d067c91b1bbe,
            0xfffffffffffffffffffae833e48d8ddf,
            0xfffffffffffffffffffd7419f246c6ef,
            0xfffffffffffffffffffeba0cf9236377,
            0xffffffffffffffffffff5d067c91b1bb,
            0xffffffffffffffffffffae833e48d8dd,
            0xffffffffffffffffffffd7419f246c6e,
            0xffffffffffffffffffffeba0cf923637,
            0xfffffffffffffffffffff5d067c91b1b,
            0xfffffffffffffffffffffae833e48d8d,
            0xfffffffffffffffffffffd7419f246c6,
            0xfffffffffffffffffffffeba0cf92363,
            0xffffffffffffffffffffff5d067c91b1,
            0xffffffffffffffffffffffae833e48d8,
            0xffffffffffffffffffffffd7419f246c,
            0xffffffffffffffffffffffeba0cf9236,
            0xfffffffffffffffffffffff5d067c91b,
            0xfffffffffffffffffffffffae833e48d,
            0xfffffffffffffffffffffffd7419f246,
            0xfffffffffffffffffffffffeba0cf923,
            0xffffffffffffffffffffffff5d067c91,
            0xffffffffffffffffffffffffae833e48,
            0xffffffffffffffffffffffffd7419f24,
            0xffffffffffffffffffffffffeba0cf92,
            0xfffffffffffffffffffffffff5d067c9,
            0xfffffffffffffffffffffffffae833e4,
            0xfffffffffffffffffffffffffd7419f2,
            0xfffffffffffffffffffffffffeba0cf9,
            0xffffffffffffffffffffffffff5d067c,
            0xffffffffffffffffffffffffffae833e,
            0xffffffffffffffffffffffffffd7419f,
            0xffffffffffffffffffffffffffeba0cf,
            0xfffffffffffffffffffffffffff5d067,
            0xfffffffffffffffffffffffffffae833,
            0xfffffffffffffffffffffffffffd7419,
            0xfffffffffffffffffffffffffffeba0c,
            0xffffffffffffffffffffffffffff5d06,
            0xffffffffffffffffffffffffffffae83,
            0xffffffffffffffffffffffffffffd741,
            0xffffffffffffffffffffffffffffeba0,
            0xfffffffffffffffffffffffffffff5d0,
            0xfffffffffffffffffffffffffffffae8,
            0xfffffffffffffffffffffffffffffd74,
            0xfffffffffffffffffffffffffffffeba,
            0xffffffffffffffffffffffffffffff5d,
            0xffffffffffffffffffffffffffffffae,
            0xffffffffffffffffffffffffffffffd7,
            0xffffffffffffffffffffffffffffffeb,
            0xfffffffffffffffffffffffffffffff5,
            0xfffffffffffffffffffffffffffffffa,
            0xfffffffffffffffffffffffffffffffd,
            0xfffffffffffffffffffffffffffffffe,
            0xffffffffffffffffffffffffffffffff
        ];

        if (_ratio < RATIO_MIN_VALUE) 
            return 0;
        uint8 bit = log_2(_ratio);
        uint256 base = 1 << bit;
        uint256 x1 = arctan_table[bit];
        uint256 x2 = arctan_table[bit - 1];
        return ((x1 - x2) * (_ratio - base)) / base + x2;
    }
}

struct Orbit2D {
    int256 a;
    int256 e;
    int256 M;
    int256 T;
    int256 n;
}

struct Orbit3D {
    int256 a;
    int256 e;
    int256 M;
    int256 T;
    int256 Omega;
    int256 omega;
    int256 I;
    int256[3][3] Euler_angle_transformation_matrix;
    Orbit2D orbit2d;
}

struct Orbit {
    int256 a0;       // a [AU] - semi-major axis (default 1)
    int256 e0;       // e [0-1] - eccentricity (default 0)
    int256 M0;       // M0 - mean anomaly at time zero (default 0; recommended to use J2000 epoch for Solar System)
    int256 T0;       // T [sec] - orbital period (default 1)
    int256 Omega0;   // Omega [rad] - longitude of the ascending node (default 0)
    int256 omega0;   // omega [rad] - argument of the pericenter (default 0)
    int256 I0;       // I [rad] - inclination (default 0)
    mapping (bytes => int256) roc_funcs;
    Orbit3D orbit3d;
}


pragma solidity ^0.8.0;

library Orbit2DFuns {
    uint8 constant Decimals = 8;
    int256 constant PI = 314159265;

    /**
     * Sets the mean angular velocity (n) for the class
     * Needs to be run every time the period (T) is set or updated
     */
    function _update_n( Orbit2D storage self ) internal {
        self.n = 100 * 2 * PI / self.T;     //100*self.n to correct closely
    }

    /**
     * To be used for changes in orbital parameters, e.g. perihelion shift
     */
    function update( Orbit2D storage self, string memory key, int256 value ) internal {
        if (keccak256(bytes(key)) == keccak256(bytes('a')))
            self.a = value;
        if (keccak256(bytes(key)) == keccak256(bytes('e')))
            self.e = value;
        if (keccak256(bytes(key)) == keccak256(bytes('M')))
            self.M = value;
        if (keccak256(bytes(key)) == keccak256(bytes('T'))) {
            self.T = value;
            self.n = 100 * 2 * PI / value;
        }
    }

    /**
     * Arguments: t [sec] - relative time from point zero (default J2000 epoch) 
     * Returns: radius [AU] and true anomaly [rad]
     */
    function get_rv( Orbit2D storage self, int256 t ) internal view returns (int256, int256) {
        int256 M = self.n * t/100  + self.M;  // actual mean anomaly
        int256 E;                         // actual eccentric anomaly
        int256 temp;                      // Temporary memory for deep computations

        // condition to check if fsolve is success.
        // fsolve_cond = (np.pi-2/E0) * (np.pi-2/E0) - 4*(np.pi*np.pi/4 - 2 - 2*M0/E0) : Python format
        int256 fsolve_cond = (PI- int(10**Decimals) * 2*int(10**Decimals)/self.e);
        fsolve_cond = fsolve_cond * fsolve_cond;
        temp = int(10**Decimals) * 2*int(10**Decimals)*M/self.e;
        temp = 4*(PI*PI/4 - int(10**Decimals) * 2*int(10**Decimals) - temp );
        fsolve_cond = fsolve_cond - temp;

        if(fsolve_cond > 0) {
            int256 E0 = ((PI- int(10**Decimals) * 2*int(10**Decimals)/self.e) + int(MathLib.sqrt(uint(fsolve_cond))))/2;
            int256 E1 = ((PI- int(10**Decimals) * 2*int(10**Decimals)/self.e) - int(MathLib.sqrt(uint(fsolve_cond))))/2;
            int256 E0_offset = E0-self.e*MathLib.sin(int(8192*E0/PI))/32767;
            int256 E1_offset = E1-self.e*MathLib.sin(int(8192*E1/PI))/32767;
            E = MathLib.abs(E0_offset) < MathLib.abs(E1_offset) ? E0:E1;

            for(uint i=0; i<5; i++) {
                temp = int(10**Decimals) * (E - self.e*MathLib.sin(int(8192*E/PI))/32767 - M);
                temp = E - temp/(int(10**Decimals) - MathLib.cos(int(8192*E/PI))/32767);
                E = temp;
            }

            // Radius (distance from baricenter) => r = self.a * ( 1.0 - self.e * np.cos( E ) ) : Python format
            int256 r = self.a * ( int(10**Decimals) - self.e * MathLib.cos(int(8192*E/PI))/32767 ) / (int(10**Decimals));   
            // True anomaly => v = 2.0 * np.arctan( np.sqrt( ( 1.0 + self.e ) / ( 1.0 - self.e ) ) * np.tan( E / 2.0 ) ) : Python format                            // radius (distance from baricenter)
            temp = int(MathLib.sqrt(uint( int(10**Decimals) * int(10**Decimals) * (int(10**Decimals) + self.e )/( int(10**Decimals) - self.e ))));
            int256 ratio = temp * MathLib.sin(int(4096*E/PI)) /  MathLib.cos(int(4096*E/PI));
            ratio = ratio * int(2**128) /int(10**Decimals);
            temp = ratio < 0 ? int(MathLib.arctan(uint(ratio*(-1))))*(-1): int(MathLib.arctan(uint(ratio)));
            int256 v = (PI/2) * int(2*10**Decimals) * temp / int(2**128 * 10**Decimals )  ;  // true anomaly
            return(r, v);
        } else {
          // fsolve is false.
          return(0, 0);
        }
    }


    /**
     * Same as get_rv() but returns the objects position in cartesian coordinates 
     * Returns: x, y [AU] - x-axis is in the direction of pericenter, y-axis is right-hand perpendicular
     */
    function get_xy( Orbit2D storage self, int256 t ) internal view returns (int256, int256) {
        int256 r; 
        int256 v;
        (r, v) = get_rv(self, t);

        int256 x = r * MathLib.cos(int(8192*v/PI))/32767;
        int256 y = r * MathLib.sin(int(8192*v/PI))/32767;

        return(x, y);

    }

}

pragma solidity ^0.8.0;

library Orbit3DFuns {

    uint8 constant Decimals = 8;
    int256 constant PI = 314159265;

    function _update_Euler_angle_transformation_matrix( Orbit3D storage self) internal {
        int256 cosO = int(10**Decimals) * MathLib.cos(int(8192*self.Omega/PI))/32767;
        int256 sinO = int(10**Decimals) * MathLib.sin(int(8192*self.Omega/PI))/32767;

        int256 cosI = int(10**Decimals) * MathLib.cos(int(8192*self.I/PI))/32767;
        int256 sinI = int(10**Decimals) * MathLib.sin(int(8192*self.I/PI))/32767;

        int256 coso = int(10**Decimals) * MathLib.cos(int(8192*self.omega/PI))/32767;
        int256 sino = int(10**Decimals) * MathLib.sin(int(8192*self.omega/PI))/32767;

        self.Euler_angle_transformation_matrix[0][0] = (int(10**Decimals)*cosO*coso- sinO*sino*cosI)/(int(10**Decimals)*int(10**Decimals));
        self.Euler_angle_transformation_matrix[0][1] = (-int(10**Decimals)*cosO*sino- sinO*coso*cosI)/(int(10**Decimals)*int(10**Decimals));
        self.Euler_angle_transformation_matrix[0][2] = sinO*sinI/int(10**Decimals);
        self.Euler_angle_transformation_matrix[1][0] = (int(10**Decimals)*sinO*coso + cosO*cosI*sino)/(int(10**Decimals)*int(10**Decimals));
        self.Euler_angle_transformation_matrix[1][1] = (cosO*coso*cosI -int(10**Decimals)*sinO*sino)/(int(10**Decimals)*int(10**Decimals));
        self.Euler_angle_transformation_matrix[1][2] = -cosO*sinI/int(10**Decimals);
        self.Euler_angle_transformation_matrix[2][0] = sinI*sino/int(10**Decimals);
        self.Euler_angle_transformation_matrix[2][1] = sinI*coso/int(10**Decimals);
        self.Euler_angle_transformation_matrix[2][2] = cosI;
    }

    /**
     * Updates class parameters
     * To be used for changes in orbital parameters, e.g. perihelion shift
     */
    function update( Orbit3D storage self, string memory key, int256 value ) internal {
        if (keccak256(bytes(key)) == keccak256(bytes('a')))
            self.a = value;
        if (keccak256(bytes(key)) == keccak256(bytes('e')))
            self.e = value;
        if (keccak256(bytes(key)) == keccak256(bytes('M')))
            self.M = value;
        if (keccak256(bytes(key)) == keccak256(bytes('T'))) 
            self.T = value;
        if (keccak256(bytes(key)) == keccak256(bytes('Omega'))) {
            self.Omega = value;
            _update_Euler_angle_transformation_matrix(self);
        }
        if (keccak256(bytes(key)) == keccak256(bytes('omega'))) {
            self.omega = value;
            _update_Euler_angle_transformation_matrix(self);
        }
        if (keccak256(bytes(key)) == keccak256(bytes('I'))) {
            self.I = value;
            _update_Euler_angle_transformation_matrix(self);
        }
        
        Orbit2DFuns.update(self.orbit2d, key, value);
    }

    /**
     * Argument: t [sec] - time since time zero [default to J2000 epoch]
     * Returns: objects possition x, y, z in [AU] - x is directed at vernal equinox; y,z are right-handed ortogonal
     */
    function get_xyz( Orbit3D storage self, int256 t) internal view returns (int256, int256, int256) {
        int256 p_2d_x;
        int256 p_2d_y;
        (p_2d_x, p_2d_y) = Orbit2DFuns.get_xy(self.orbit2d, t);

        int256 x = (self.Euler_angle_transformation_matrix[0][0] * p_2d_x + self.Euler_angle_transformation_matrix[0][1] * p_2d_y)/int(10**Decimals);
        int256 y = (self.Euler_angle_transformation_matrix[1][0] * p_2d_x + self.Euler_angle_transformation_matrix[1][1] * p_2d_y)/int(10**Decimals);
        int256 z = (self.Euler_angle_transformation_matrix[2][0] * p_2d_x + self.Euler_angle_transformation_matrix[2][1] * p_2d_y)/int(10**Decimals);

        return(x, y, z);

    }

    /**
     * Argument: t [sec] - time since time zero [default to J2000 epoch]
     * Returns: objects possition x, y in [AU] - x is directed at vernal equinox; y is right-handed ortogonal
     */
    function get_xy( Orbit3D storage self, int256 t) internal view returns (int256, int256) {
        int256 p_2d_x;
        int256 p_2d_y;
        (p_2d_x, p_2d_y) = Orbit2DFuns.get_xy(self.orbit2d, t);
        
        return(p_2d_x, p_2d_y);
    } 

}

pragma solidity ^0.8.0;

library OrbitFuns {

    uint8 constant Decimals = 8;
    int256 constant PI = 314159265;

    /**
     * Updates class parameters
     * To be used for changes in orbital parameters, e.g. perihelion shift
     */
    function update( Orbit storage self, string memory key, int256 value ) internal {
        if (keccak256(bytes(key)) == keccak256(bytes('a')))
            self.a0 = value;
        if (keccak256(bytes(key)) == keccak256(bytes('e')))
            self.e0 = value;
        if (keccak256(bytes(key)) == keccak256(bytes('M')))
            self.M0 = value;
        if (keccak256(bytes(key)) == keccak256(bytes('T'))) 
            self.T0 = value;
        if (keccak256(bytes(key)) == keccak256(bytes('Omega'))) 
            self.Omega0 = value;
        if (keccak256(bytes(key)) == keccak256(bytes('omega'))) 
            self.omega0 = value;
        if (keccak256(bytes(key)) == keccak256(bytes('I'))) 
            self.I0 = value;

        Orbit3DFuns.update(self.orbit3d, key, value);
    }


    /**
     * Argument: t [sec] - time since time zero [default to J2000 epoch]
     * Returns: objects possition x, y, z in [AU] - x is directed at vernal equinox; y,z are right-handed ortogonal
     */
    function get_xyz( Orbit storage self, int256 t) internal returns (int256, int256, int256) {
        string[7] memory params = ['a','e','M','T','Omega','omega','I'];
        for(uint i = 0; i < params.length; i++) {
            if( self.roc_funcs[bytes(params[i])] != 0) {
                int256 newVal;
                if (keccak256(bytes(params[i])) == keccak256(bytes('a')))
                    newVal = self.a0 + self.roc_funcs[bytes(params[i])] * t;
                if (keccak256(bytes(params[i])) == keccak256(bytes('e')))
                    newVal = self.e0 + self.roc_funcs[bytes(params[i])] * t;
                if (keccak256(bytes(params[i])) == keccak256(bytes('M')))
                    newVal = self.M0 + self.roc_funcs[bytes(params[i])] * t;
                if (keccak256(bytes(params[i])) == keccak256(bytes('T'))) 
                    newVal = self.T0 + self.roc_funcs[bytes(params[i])] * t;
                if (keccak256(bytes(params[i])) == keccak256(bytes('Omega')))
                    newVal = self.Omega0 + self.roc_funcs[bytes(params[i])] * t;
                if (keccak256(bytes(params[i])) == keccak256(bytes('omega'))) 
                    newVal = self.omega0 + self.roc_funcs[bytes(params[i])] * t;
                if (keccak256(bytes(params[i])) == keccak256(bytes('I'))) 
                    newVal = self.I0 + self.roc_funcs[bytes(params[i])] * t;
                Orbit3DFuns.update(self.orbit3d, params[i], newVal);
            }
        }

        (int256 x, int256 y, int256 z) = Orbit3DFuns.get_xyz(self.orbit3d, t);

        return(x, y, z);

    }

}



pragma solidity ^0.8.0;

contract Test {

    using Orbit2DFuns for Orbit2D;
    using Orbit3DFuns for Orbit3D;
    using OrbitFuns for Orbit;
    // Orbit2D orbit2d;
    Orbit3D orbit3d;
    mapping (bytes => Orbit3D) private Solar_System_Keplerian_Elements;

    constructor() { 
        {
            int256[3][3] memory matrix;
            Orbit2D memory orbit2d =  Orbit2D({a:38709893, e:20563069, M: 305073760, T:760065407544000, n:8267});
            matrix = [[int256(21989544), int256(-97126040),int256(9110012)], [int256(97371598),int256(21284672),int256(-8107696)], [int256(5935648),int256(10653410),int256(99253579)]];
            orbit3d =  Orbit3D({a:38709893, e:20563069, M: 305073760, T:760065407544000, I:12225804, Omega:84354677, omega:50832330, Euler_angle_transformation_matrix: matrix, orbit2d:orbit2d });
        //    orbit3d._update_Euler_angle_transformation_matrix();
            Solar_System_Keplerian_Elements[bytes('Mercury')] = orbit3d;
        }
        {
            int256[3][3] memory matrix;
            Orbit2D memory orbit2d =  Orbit2D({a:72333199, e:677323, M: 88046188, T:1940826194496000, n:3237});
            matrix = [[int256(-66165487), int256(-74759120),int256(5762142)], [int256(74824365),int256(-66328376),int256(-1364163)], [int256(4841772),int256(3408881),int256(99824530)]];
            orbit3d =  Orbit3D({a:72333199, e:677323, M: 88046188, T:1940826194496000, I:12225804, Omega:133833051, omega:95735306, Euler_angle_transformation_matrix: matrix, orbit2d:orbit2d });
        //    orbit3d._update_Euler_angle_transformation_matrix();
            Solar_System_Keplerian_Elements[bytes('Venus')] = orbit3d;
        }
        {
            int256[3][3] memory matrix;
            Orbit2D memory orbit2d =  Orbit2D({a:100000011, e:1671022, M: -4333373, T:3155814950400000, n:1991});
            matrix = [[int256(-22405287), int256(-97457699),int256(0)], [int256( 97457699),int256(-22405287),int256(-87)], [int256(85),int256(-19),int256(100000000)]];
            orbit3d =  Orbit3D({a:100000011, e:1671022, M: -4333373, T:3155814950400000, I:12225804, Omega:0, omega:179676742, Euler_angle_transformation_matrix: matrix, orbit2d:orbit2d });
        //    orbit3d._update_Euler_angle_transformation_matrix();
            Solar_System_Keplerian_Elements[bytes('Earth')] = orbit3d;
        }
        {
            int256[3][3] memory matrix;
            Orbit2D memory orbit2d =  Orbit2D({a:152366231, e:9341233, M: 33881169, T:59360879217024000, n:106});
            matrix = [[int256(91345435), int256(40619790),int256(2458499)], [int256(-40576104),int256(91373931),int256(-2093935)], [int256(-3096979),int256(915151),int256(99947842)]];
            orbit3d =  Orbit3D({a:152366231, e:9341233, M: 33881169, T:59360879217024000, I:3229923, Omega:86530876, omega:499971031, Euler_angle_transformation_matrix: matrix, orbit2d:orbit2d });
        //    orbit3d._update_Euler_angle_transformation_matrix();
            Solar_System_Keplerian_Elements[bytes('Mars')] = orbit3d;
        }
        {
            int256[3][3] memory matrix;
            Orbit2D memory orbit2d =  Orbit2D({a:520336301, e:4839266, M: 34296644, T:37427965311744000, n:168});
            matrix = [[int256(96677441), int256(-25464826),int256(2239428)], [int256(25461952),int256(96703231),int256(417324)], [int256(-2271870),int256(166744),int256(99974051)]];
            orbit3d =  Orbit3D({a:520336301, e:4839266, M: 34296644, T:37427965311744000, I:2278178, Omega:175503590, omega:-149753264, Euler_angle_transformation_matrix: matrix, orbit2d:orbit2d });
        //    orbit3d._update_Euler_angle_transformation_matrix();
            Solar_System_Keplerian_Elements[bytes('Jupiter')] = orbit3d;
        }
        {
            int256[3][3] memory matrix;
            Orbit2D memory orbit2d =  Orbit2D({a:953707032, e:5415060, M: -74154886, T:92970308438784000, n:68});
            matrix = [[int256(-4274500), int256(-99829742),int256(3968795)], [int256(99896211),int256(-4208035),int256(1743422)], [int256(-1573445),int256(4039199),int256(99906002)]];
            orbit3d =  Orbit3D({a:953707032, e:5415060, M: -74154886, T:92970308438784000, I:4336200, Omega:198470185, omega:-37146017, Euler_angle_transformation_matrix: matrix, orbit2d:orbit2d });
        //    orbit3d._update_Euler_angle_transformation_matrix();
            Solar_System_Keplerian_Elements[bytes('Saturn')] = orbit3d;
        }
        {
            int256[3][3] memory matrix;
            Orbit2D memory orbit2d =  Orbit2D({a:3006896348, e:858587, M: 453626222, T:520078303825920000, n:12});
            matrix = [[int256(70710505), int256(-70673294),int256(2304314)], [int256(70643638),int256(70747826),int256(2054634)], [int256(-3082329),int256(175009),int256(99952332)]];
            orbit3d =  Orbit3D({a:3006896348, e:858587, M: 453626222, T:520078303825920000, I:3087784, Omega:229897718, omega:-151407906, Euler_angle_transformation_matrix: matrix, orbit2d:orbit2d });
        //    orbit3d._update_Euler_angle_transformation_matrix();
            Solar_System_Keplerian_Elements[bytes('Neptune')] = orbit3d;
        }
        {
            int256[3][3] memory matrix;
            Orbit2D memory orbit2d =  Orbit2D({a:1919126393, e:4716771, M: 248304397, T:265120013983104000, n:24});
            matrix = [[int256(-98750424), int256(-15706107),int256(1293045)], [int256(15702652),int256(-98758764),int256(-365167)], [int256(1334348),int256(-157561),int256(99990973)]];
            orbit3d =  Orbit3D({a:1919126393, e:4716771, M: 248304397, T:265120013983104000, I:1343659, Omega:129555580, omega:168833308, Euler_angle_transformation_matrix: matrix, orbit2d:orbit2d });
        //    orbit3d._update_Euler_angle_transformation_matrix();
            Solar_System_Keplerian_Elements[bytes('Uranus')] = orbit3d;
        }
        {
            int256[3][3] memory matrix;
            Orbit2D memory orbit2d =  Orbit2D({a:3006896348, e:858587, M: 453626222, T:520078303825920000, n:12});            
            matrix = [[int256(70710505), int256(-70673294),int256(2304314)], [int256(70643638),int256(70747826),int256(2054634)], [int256(-3082329),int256(175009),int256(99952332)]];
            orbit3d =  Orbit3D({a:3006896348, e:858587, M: 453626222, T:520078303825920000, I:3087784, Omega:229897718, omega:-151407906, Euler_angle_transformation_matrix: matrix, orbit2d:orbit2d });
        //    orbit3d._update_Euler_angle_transformation_matrix();
            Solar_System_Keplerian_Elements[bytes('Neptune')] = orbit3d;
        }        
        {
            int256[3][3] memory matrix;
            Orbit2D memory orbit2d =  Orbit2D({a:3948168677, e:24880766, M: 25939170, T:782957689194239900, n:8});
            matrix = [[int256(-68040055), int256(67870818),int256(27642411)], [int256(-68138896),int256(-72474109),int256(10227141)], [int256(26974835),int256(-11876681),int256(95557850)]];
            orbit3d =  Orbit3D({a:3948168677, e:24880766, M: 25939170, T:782957689194239900, I:29917997, Omega:192515872, omega:198554397, Euler_angle_transformation_matrix: matrix, orbit2d:orbit2d });
        //    orbit3d._update_Euler_angle_transformation_matrix();
            Solar_System_Keplerian_Elements[bytes('Pluto')] = orbit3d;
        }

    }

    function get_relative_2D_pos(string memory object, string memory observer, int256 t ) public view returns (int256, int256) {
        int256 pos_x;
        int256 pos_y;
        int256 obs_x = 0;
        int256 obs_y = 0;
        // objective planet's absolute position.
        (pos_x, pos_y) = Solar_System_Keplerian_Elements[bytes(object)].get_xy(t);
        // observer planet's absolute position.
        (obs_x, obs_y) = Solar_System_Keplerian_Elements[bytes(observer)].get_xy(t);
        
        return (pos_x-obs_x, pos_y-obs_y);
    }

    function get_absolutive_2D_pos(string memory object, int256 t ) public view returns (int256, int256) {
        int256 pos_x;
        int256 pos_y;

        // objective planet's absolute position.
        (pos_x, pos_y) = Solar_System_Keplerian_Elements[bytes(object)].get_xy(t);
        
        return (pos_x, pos_y);
    }

    function get_relative_3D_pos(string memory object, string memory observer, int256 t ) public view returns (int256, int256, int256) {
        int256 pos_x;
        int256 pos_y;
        int256 pos_z;
        int256 obs_x = 0;
        int256 obs_y = 0;
        int256 obs_z = 0;
        
        // objective planet's absolute position.
        (pos_x, pos_y, pos_z) = Solar_System_Keplerian_Elements[bytes(object)].get_xyz(t);
        // observer planet's absolute position.
        if(keccak256(bytes(observer)) == keccak256(bytes(''))) {
            (obs_x, obs_y, obs_z) = Solar_System_Keplerian_Elements[bytes(observer)].get_xyz(t);
        } 
        
        return (pos_x-obs_x, pos_y-obs_y, pos_z-obs_z);
    }

    function get_absolutive_3D_pos(string memory object, int256 t ) public view returns (int256, int256, int256) {
        int256 pos_x;
        int256 pos_y;
        int256 pos_z;
        // objective planet's absolute position.
        (pos_x, pos_y, pos_z) = Solar_System_Keplerian_Elements[bytes(object)].get_xyz(t);
        
        return (pos_x, pos_y, pos_z);
    }

    function update_euler_matrix(string memory planet) public {
        Solar_System_Keplerian_Elements[bytes(planet)]._update_Euler_angle_transformation_matrix();
    }


    function read_euler_matrix(string memory planet) public view returns (int256[3][3] memory) {
        return Solar_System_Keplerian_Elements[bytes(planet)].Euler_angle_transformation_matrix;
    }


    function get_orbit2d_rv(string memory planet, int256 t) public view returns (int256, int256) {
        int256 res_r;
        int256 res_v;

        (res_r, res_v) = Solar_System_Keplerian_Elements[bytes(planet)].orbit2d.get_rv(t);
        return (res_r, res_v);
    }


    function test_cos(int256 angle) public pure returns (int256) {
        int256 PI = 314159265;
        int256 cos_res = 10**8 * MathLib.cos(int(8192*angle/PI))/32767;

        return cos_res;
    }

    function test_sin(int256 angle) public pure returns (int256) {
        int256 PI = 314159265;
        int256 sin_res = 10**8 * MathLib.sin(int(8192*angle/PI))/32767;

        return sin_res;
    }

    function test_arctan(int256 _ratio) public pure returns (int256) {
        int256 ratio = _ratio * int(2**128) /int(10**8);
        int256 temp = ratio < 0 ? int(MathLib.arctan(uint(ratio*(-1))))*(-1): int(MathLib.arctan(uint(ratio)));
        int256 arctan_res = 10**8 * temp / (2**128);

        return arctan_res;
    }


}